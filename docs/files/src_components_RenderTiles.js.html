<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v0.11.4 API Documentation : src\components\RenderTiles.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.11.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.EventRender.html">platypus.components.EventRender</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimation.html">platypus.components.RenderAnimation</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.StateRender.html">platypus.components.StateRender</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.PlatypusPlugin.html">platypus.PlatypusPlugin</a></li>
                                <li><a href="../classes/platypus.Scene.html">platypus.Scene</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/window.Array.html">window.Array</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                                <li><a href="../classes/window.String.html">window.String</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\RenderTiles.js      
                        </script>
                        <h1 class="file-heading">File:src\components\RenderTiles.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component handles rendering tile map backgrounds.
                         *
                         * When rendering the background, this component figures out what tiles are being displayed and caches them so they are rendered as one image rather than individually.
                         *
                         * As the camera moves, the cache is updated by blitting the relevant part of the old cached image into a new cache and then rendering tiles that have shifted into the camera&#x27;s view into the cache.
                         *
                         * @namespace platypus.components
                         * @class RenderTiles
                         * @uses platypus.Component
                         */
                        /* global include, platypus, recycle, springroll */
                        (function () {
                            &#x27;use strict&#x27;;
                        
                            var EDGE_BLEED = 1,
                                EDGES_BLEED = EDGE_BLEED * 2,
                                AABB              = include(&#x27;platypus.AABB&#x27;),
                                PIXIAnimation     = include(&#x27;platypus.PIXIAnimation&#x27;),
                                Application       = include(&#x27;springroll.Application&#x27;),
                                CanvasRenderer    = include(&#x27;PIXI.CanvasRenderer&#x27;),
                                Container         = include(&#x27;PIXI.Container&#x27;),
                                Graphics          = include(&#x27;PIXI.Graphics&#x27;),
                                ParticleContainer = Container, //Excluding ParticleContainer atm due to https://github.com/pixijs/pixi.js/issues/4008 -- include(&#x27;PIXI.particles.ParticleContainer&#x27;),
                                Rectangle         = include(&#x27;PIXI.Rectangle&#x27;),
                                RenderTexture     = include(&#x27;PIXI.RenderTexture&#x27;),
                                Sprite            = include(&#x27;PIXI.Sprite&#x27;),
                                clearRenderTexture = function (renderer, renderTexture, clearColor) { // This is pulled from https://github.com/pixijs/pixi.js/pull/3647 and should be in a future build of PIXI
                                    var baseTexture = renderTexture.baseTexture,
                                        renderTarget = baseTexture._glRenderTargets[renderer.CONTEXT_UID];
                                        
                                    if (renderTarget) {
                                        renderTarget.clear(clearColor);
                                    }
                                },
                                doNothing = function () {
                                    return null;
                                },
                                tempCache = AABB.setUp(),
                                sort = function (a, b) {
                                    return a.z - b.z;
                                },
                                getPowerOfTwo = function (amount) {
                                    var x = 1;
                        
                                    while (x &lt; amount) {
                                        x *= 2;
                                    }
                        
                                    return x;
                                },
                                transformCheck = function (value, tile) {
                                    var v = +(value.substring(4)),
                                        x = 0;
                        
                                    if (0x80000000 &amp; v) {
                                        tile.scale.x = -1;
                                    }
                                    if (0x40000000 &amp; v) {
                                        tile.scale.y = -1;
                                    }
                                    if (0x20000000 &amp; v) {
                                        x = tile.scale.x;
                                        tile.scale.x = tile.scale.y;
                                        tile.scale.y = -x;
                                        tile.rotation = Math.PI / 2;
                                    }
                        
                                    return 0x0fffffff &amp; v;
                                },
                                Template = function (tile, id) {
                                    this.id = id;
                                    this.instances = Array.setUp(tile);
                                    this.index = 0;
                                    tile.template = this; // backwards reference for clearing index later.
                                },
                                nullTemplate = {
                                    getNext: doNothing,
                                    destroy: doNothing
                                },
                                prototype = Template.prototype;
                        
                            prototype.getNext = function () {
                                var instance = this.instances[this.index],
                                    template = null;
                        
                                if (!instance) {
                                    template = this.instances[0];
                                    instance = this.instances[this.index] = new Sprite(template.texture);
                        
                                    // Copy properties
                                    instance.scale    = template.scale;
                                    instance.rotation = template.rotation;
                                    instance.anchor   = template.anchor;
                                }
                        
                                this.index += 1;
                        
                                return instance;
                            };
                        
                            prototype.clear = function () {
                                this.index = 0;
                            };
                            
                            prototype.destroy = function () {
                                var i = 0;
                                
                                for (i = 0; i &lt; this.instances.length; i++) {
                                    this.instances[i].destroy();
                                }
                                
                                this.instances.recycle();
                                this.recycle();
                            };
                        
                            recycle.add(Template, !!springroll.Debug, &#x27;Template&#x27;);
                        
                            return platypus.createComponentClass({
                        
                                id: &#x27;RenderTiles&#x27;,
                        
                                properties: {
                                    /**
                                     * The amount of space in pixels around the edge of the camera that we include in the buffered image. If not set, largest buffer allowed by maximumBuffer is used.
                                     *
                                     * @property buffer
                                     * @type number
                                     * @default 0
                                     */
                                    buffer: 0,
                        
                                    /**
                                     * Determines whether to cache the entire map across one or more texture caches. By default this is &#x60;false&#x60;; however, if the entire map fits on one or two texture caches, this is set to &#x60;true&#x60; since it is more efficient than dynamic buffering.
                                     *
                                     * @property cacheAll
                                     * @type Boolean
                                     * @default false
                                     */
                                    cacheAll: false,
                        
                                    /**
                                     * Whether to cache entities on this layer if the entity&#x27;s render component requests caching.
                                     *
                                     * @property entityCache
                                     * @type boolean
                                     * @default false
                                     */
                                    entityCache: false,
                        
                                    /**
                                     * This is a two dimensional array of the spritesheet indexes that describe the map that you&#x27;re rendering.
                                     *
                                     * @property imageMap
                                     * @type Array
                                     * @default []
                                     */
                                    imageMap: [],
                        
                                    /**
                                     * The amount of space that is buffered. Defaults to 2048 x 2048 or a smaller area that encloses the tile layer.
                                     *
                                     * @property maximumBuffer
                                     * @type number
                                     * @default 2048
                                     */
                                    maximumBuffer: 2048,
                        
                                    /**
                                     * The x-scale the tilemap is being displayed at.
                                     *
                                     * @property scaleX
                                     * @type number
                                     * @default 1
                                     */
                                    scaleX: 1,
                        
                                    /**
                                     * The y-scale the tilemap is being displayed at.
                                     *
                                     * @property scaleY
                                     * @type number
                                     * @default 1
                                     */
                                    scaleY: 1,
                        
                                    /**
                                     * A sprite sheet describing all the tile images.
                                     *
                                     * Accepts an array of sprite sheet data since 0.8.4
                                     *
                                     * @property spriteSheet
                                     * @type Object|Array|String
                                     * @default null
                                     */
                                    spriteSheet: null,
                        
                                    /**
                                     * Whether to cache the tile map to a large texture.
                                     *
                                     * @property tileCache
                                     * @type boolean
                                     * @default true
                                     * @since 0.6.4
                                     */
                                    tileCache: true,
                        
                                    /**
                                     * This is the height in pixels of individual tiles.
                                     *
                                     * @property tileHeight
                                     * @type number
                                     * @default 10
                                     */
                                    tileHeight: 10,
                        
                                    /**
                                     * This is the width in pixels of individual tiles.
                                     *
                                     * @property tileWidth
                                     * @type number
                                     * @default 10
                                     */
                                    tileWidth: 10,
                                    
                                    /**
                                     * The map&#x27;s top offset.
                                     *
                                     * @property top
                                     * @type Number
                                     * @default 0
                                     * @since 0.7.5
                                     */
                                    top: 0,
                                    
                                    /**
                                     * The map&#x27;s left offset.
                                     *
                                     * @property left
                                     * @type Number
                                     * @default 0
                                     * @since 0.7.5
                                     */
                                    left: 0
                                },
                        
                                initialize: function () {
                                    var imgMap = this.imageMap;
                        
                                    this.doMap            = null; //list of display objects that should overlay tile map.
                                    this.cachedDisplayObjects = null;
                                    this.populate         = this.populateTiles;
                        
                                    this.tiles            = {};
                        
                                    this.renderer         = Application.instance.display.renderer;
                                    this.tilesSprite      = null;
                                    this.cacheTexture     = null;
                                    this.mapContainer      = null;
                                    this.laxCam = AABB.setUp();
                        
                                    // temp values
                                    this.worldWidth    = this.tileWidth;
                                    this.worldHeight   = this.tileHeight;
                        
                                    this.cache = AABB.setUp();
                                    this.cachePixels = AABB.setUp();
                        
                                    // Set up containers
                                    this.spriteSheet = PIXIAnimation.formatSpriteSheet(this.spriteSheet);
                                    this.tileContainer = ((this.spriteSheet.images.length &gt; 1) || (this.renderer instanceof CanvasRenderer)) ? new Container() : new ParticleContainer(15000, {position: true, rotation: true, scale: true});
                                    this.mapContainer = new Container();
                                    this.mapContainer.addChild(this.tileContainer);
                                    
                                    this.reorderedStage = false;
                                    this.updateCache = false;
                        
                                    // Prepare map tiles
                                    this.imageMap = Array.setUp(this.createMap(imgMap));
                        
                                    this.tilesWidth  = this.imageMap[0].length;
                                    this.tilesHeight = this.imageMap[0][0].length;
                                    this.layerWidth  = this.tilesWidth  * this.tileWidth;
                                    this.layerHeight = this.tilesHeight * this.tileHeight;
                        
                                    // Set up buffer cache size
                                    this.cacheWidth  = Math.min(getPowerOfTwo(this.layerWidth  + EDGES_BLEED), this.maximumBuffer);
                                    this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + EDGES_BLEED), this.maximumBuffer);
                        
                                    if (!this.tileCache) {
                                        this.buffer = 0; // prevents buffer logic from running if tiles aren&#x27;t being cached.
                                        this.cacheAll = false; // so tiles are updated as camera moves.
                                    }
                        
                                    this.ready = false;
                                },
                        
                                events: {
                                    /**
                                     * This event is triggered before &#x60;handle-render&#x60; and provides the container that this component will require to display. In this case it compiles the array of tiles that make up the map and adds the tilesSprite displayObject to the stage.
                                     *
                                     * @method &#x27;handle-render-load&#x27;
                                     * @param data.container {PIXI.Container} Container to contain this tile-rendering.
                                     */
                                    &quot;handle-render-load&quot;: function (resp) {
                                        var extrusionMargin = 2,
                                            mapContainer = this.mapContainer,
                                            parentContainer = null,
                                            sprite = null,
                                            z = this.owner.z;
                        
                                        if (resp &amp;&amp; resp.container) {
                                            this.ready = true;
                                            parentContainer = this.parentContainer = resp.container;
                        
                                            if (parentContainer &amp;&amp; !this.reorderedStage) {
                                                parentContainer.reorder = true;
                                                this.reorderedStage = true;
                                            }
                        
                                            this.updateRegion(0);
                        
                                            if (!this.tileCache) {
                                                this.render = doNothing;
                        
                                                mapContainer.scale.x = this.scaleX;
                                                mapContainer.scale.y = this.scaleY;
                                                mapContainer.x = this.left;
                                                mapContainer.y = this.top;
                                                mapContainer.z = z;
                                                parentContainer.addChild(mapContainer);
                                            } else {
                                                this.mapContainerWrapper = new Container();
                                                this.mapContainerWrapper.addChild(mapContainer);
                        
                                                if ((this.layerWidth &lt;= this.cacheWidth) &amp;&amp; (this.layerHeight &lt;= this.cacheHeight)) { // We never need to recache.
                                                    this.cacheAll   = true;
                        
                                                    this.render = this.renderCache;
                                                    this.cacheTexture = RenderTexture.create(this.cacheWidth, this.cacheHeight);
                        
                                                    this.tilesSprite = sprite = new Sprite(this.cacheTexture);
                                                    sprite.scale.x = this.scaleX;
                                                    sprite.scale.y = this.scaleY;
                                                    sprite.z = z;
                        
                                                    this.cache.setBounds(0, 0, this.tilesWidth - 1, this.tilesHeight - 1);
                                                    this.update(this.cacheTexture, this.cache);
                                                    parentContainer.addChild(sprite);
                                                } else if (this.cacheAll || ((this.layerWidth &lt;= this.cacheWidth * 2) &amp;&amp; (this.layerHeight &lt;= this.cacheHeight)) || ((this.layerWidth &lt;= this.cacheWidth) &amp;&amp; (this.layerHeight &lt;= this.cacheHeight * 2))) { // We cache everything across several textures creating a cache grid.
                                                    this.cacheAll = true;
                        
                                                    // Make sure there&#x27;s room for the one-pixel extrusion around edges of caches
                                                    this.cacheWidth = Math.min(getPowerOfTwo(this.layerWidth + extrusionMargin), this.maximumBuffer);
                                                    this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + extrusionMargin), this.maximumBuffer);
                                                    this.updateRegion(extrusionMargin);
                        
                                                    this.render = this.renderCacheWithExtrusion;
                                                    this.cacheGrid = this.createGrid(parentContainer);
                        
                                                    this.updateCache = true;
                                                } else {
                                                    this.render = this.renderCache;
                                                    this.cacheAll = false;
                        
                                                    this.cacheTexture = RenderTexture.create(this.cacheWidth, this.cacheHeight);
                        
                                                    this.tilesSprite = new Sprite(this.cacheTexture);
                                                    this.tilesSprite.scale.x = this.scaleX;
                                                    this.tilesSprite.scale.y = this.scaleY;
                                                    this.tilesSprite.z = z;
                        
                                                    // Set up copy buffer and circular pointers
                                                    this.cacheTexture.alternate = RenderTexture.create(this.cacheWidth, this.cacheHeight);
                                                    this.tilesSpriteCache = new Sprite(this.cacheTexture.alternate);
                        
                                                    this.cacheTexture.alternate.alternate = this.cacheTexture;
                                                    parentContainer.addChild(this.tilesSprite);
                                                }
                                            }
                                        }
                                    },
                        
                                    /**
                                     * If this component should cache entities, it checks peers for a &quot;renderCache&quot; display object and adds the display object to its list of objects to render on top of the tile set.
                                     *
                                     * @method &#x27;cache-sprite&#x27;
                                     * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.
                                     */
                                    &quot;cache-sprite&quot;: function (entity) {
                                        this.cacheSprite(entity);
                                    },
                        
                                    /**
                                     * If this component should cache entities, it checks peers for a &quot;renderCache&quot; display object and adds the display object to its list of objects to render on top of the tile set.
                                     *
                                     * @method &#x27;peer-entity-added&#x27;
                                     * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.
                                     */
                                    &quot;peer-entity-added&quot;: function (entity) {
                                        this.cacheSprite(entity);
                                    },
                        
                                    /**
                                     * This event adds a layer of tiles to render on top of the existing layer of rendered tiles.
                                     *
                                     * @method &#x27;add-tiles&#x27;
                                     * @param message.imageMap {Array} This is a 2D mapping of tile indexes to be rendered.
                                     */
                                    &quot;add-tiles&quot;: function (definition) {
                                        var map = definition.imageMap;
                        
                                        if (map) {
                                            this.imageMap.push(this.createMap(map));
                                            this.updateCache = true;
                                        }
                                    },
                        
                                    /**
                                     * This event edits the tile index of a rendered tile.
                                     *
                                     * @method &#x27;change-tile&#x27;
                                     * @param tile {String} A string representing the name of the tile to switch to.
                                     * @param x {Number} The column of the tile to edit.
                                     * @param y {Number} The row of the tile to edit.
                                     * @param [z] {Number} If RenderTiles has multiple layers, this value specifies the layer, with &#x60;0&#x60; being the bottom-most layer.
                                     */
                                    &quot;change-tile&quot;: function (tile, x, y, z) {
                                        var map = this.imageMap;
                        
                                        if (map) {
                                            this.updateTile(tile, map[z || 0], x, y);
                                            this.updateCache = true;
                                        }
                                    },
                        
                                    /**
                                     * Provides the width and height of the world.
                                     *
                                     * @method &#x27;camera-loaded&#x27;
                                     * @param camera {Object}
                                     * @param camera.world {platypus.AABB} The dimensions of the world.
                                     * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.
                                     */
                                    &quot;camera-loaded&quot;: function (camera) {
                                        this.worldWidth  = camera.world.width;
                                        this.worldHeight = camera.world.height;
                        
                                        if (this.buffer &amp;&amp; !this.cacheAll) { // do this here to set the correct mask before the first caching.
                                            this.updateBufferRegion(camera.viewport);
                                        }
                                    },
                        
                                    /**
                                     * Triggered when the camera moves, this function updates which tiles need to be rendered and caches the image.
                                     *
                                     * @method &#x27;camera-update&#x27;
                                     * @param camera {Object} Provides information about the camera.
                                     * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.
                                     */
                                    &quot;camera-update&quot;: function (camera) {
                                        if (this.ready) {
                                            this.updateCamera(camera);
                                        }
                                    },
                        
                                    /**
                                     * On receiving this message, determines whether to update which tiles need to be rendered and caches the image.
                                     *
                                     * @method &#x27;handle-render&#x27;
                                     */
                                    &quot;handle-render&quot;: function () {
                                        if (this.updateCache) {
                                            this.updateCache = false;
                                            if (this.cacheGrid) {
                                                this.updateGrid();
                                            } else {
                                                this.update(this.cacheTexture, this.cache);
                                            }
                                        }
                                    }
                                },
                        
                                methods: {
                                    cacheSprite: function (entity) {
                                        var x = 0,
                                            y = 0,
                                            object = entity.cacheRender,
                                            bounds = null,
                                            top = 0,
                                            bottom = 0,
                                            right = 0,
                                            left = 0;
                        
                                        // Determine whether to merge this image with the background.
                                        if (this.entityCache &amp;&amp; object) { //TODO: currently only handles a single display object on the cached entity.
                                            if (!this.doMap) {
                                                this.doMap = Array.setUp();
                                                this.cachedDisplayObjects = Array.setUp();
                                                this.populate = this.populateTilesAndEntities;
                                            }
                                            this.cachedDisplayObjects.push(object);
                        
                                            // Determine range:
                                            bounds = object.getBounds(object.transformMatrix);
                                            bounds.x -= this.left;
                                            bounds.y -= this.top;
                                            top    = Math.max(0, Math.floor(bounds.y / this.tileHeight));
                                            bottom = Math.min(this.tilesHeight, Math.ceil((bounds.y + bounds.height) / this.tileHeight));
                                            left   = Math.max(0, Math.floor(bounds.x / this.tileWidth));
                                            right  = Math.min(this.tilesWidth, Math.ceil((bounds.x + bounds.width) / this.tileWidth));
                        
                                            // Find tiles that should include this display object
                                            for (x = left; x &lt; right; x++) {
                                                if (!this.doMap[x]) {
                                                    this.doMap[x] = Array.setUp();
                                                }
                                                for (y = top; y &lt; bottom; y++) {
                                                    if (!this.doMap[x][y]) {
                                                        this.doMap[x][y] = Array.setUp();
                                                    }
                                                    this.doMap[x][y].push(object);
                                                }
                                            }
                        
                                            // Prevent subsequent draws
                                            entity.removeComponent(&#x27;RenderSprite&#x27;);
                        
                                            this.updateCache = true; //TODO: This currently causes a blanket cache update - may be worthwhile to only recache if this entity&#x27;s location is currently in a cache (either cacheGrid or the current viewable area).
                                        }
                                    },
                        
                                    convertCamera: function (camera) {
                                        var worldWidth  = this.worldWidth / this.scaleX,
                                            worldPosX   = worldWidth - camera.width,
                                            worldHeight = this.worldHeight / this.scaleY,
                                            worldPosY   = worldHeight - camera.height,
                                            laxCam      = this.laxCam;
                        
                                        if ((worldWidth === this.layerWidth) || !worldPosX) {
                                            laxCam.moveX(camera.x);
                                        } else {
                                            laxCam.moveX((camera.left - this.left) * (this.layerWidth - camera.width) / worldPosX + camera.halfWidth + this.left);
                                        }
                        
                                        if ((worldHeight === this.layerHeight) || !worldPosY) {
                                            laxCam.moveY(camera.y);
                                        } else {
                                            laxCam.moveY((camera.top - this.top) * (this.layerHeight - camera.height) / worldPosY + camera.halfHeight + this.top);
                                        }
                        
                                        if (camera.width !== laxCam.width || camera.height !== laxCam.height) {
                                            laxCam.resize(camera.width, camera.height);
                                        }
                        
                                        return laxCam;
                                    },
                        
                                    createTile: function (imageName) {
                                        var tile = null,
                                            anim = &#x27;&#x27;;
                        
                                        // &quot;tile-1&quot; is empty, so it remains a null reference.
                                        if (imageName === &#x27;tile-1&#x27;) {
                                            return nullTemplate;
                                        }
                        
                                        tile = new PIXIAnimation(this.spriteSheet);
                                        anim = &#x27;tile&#x27; + transformCheck(imageName, tile);
                                        tile.gotoAndStop(anim);
                        
                                        return Template.setUp(tile, imageName);
                                    },
                        
                                    createMap: function (mapDefinition) {
                                        var x = 0,
                                            y = 0,
                                            index = &#x27;&#x27;,
                                            map   = null;
                        
                                        if (typeof mapDefinition[0][0] !== &#x27;string&#x27;) { // This is not a map definition: it&#x27;s an actual RenderTiles map.
                                            return mapDefinition;
                                        }
                        
                                        map = Array.setUp();
                                        for (x = 0; x &lt; mapDefinition.length; x++) {
                                            map[x] = Array.setUp();
                                            for (y = 0; y &lt; mapDefinition[x].length; y++) {
                                                index = mapDefinition[x][y];
                                                this.updateTile(index, map, x, y);
                                            }
                                        }
                                        
                                        return map;
                                    },
                                    
                                    updateCamera: function (camera) {
                                        var x = 0,
                                            y = 0,
                                            inFrame = false,
                                            sprite  = null,
                                            ctw     = 0,
                                            cth     = 0,
                                            ctw2    = 0,
                                            cth2    = 0,
                                            cache   = this.cache,
                                            cacheP  = this.cachePixels,
                                            vp      = camera.viewport,
                                            resized = (this.buffer &amp;&amp; ((vp.width !== this.laxCam.width) || (vp.height !== this.laxCam.height))),
                                            tempC   = tempCache,
                                            laxCam  = this.convertCamera(vp);
                        
                                        if (!this.cacheAll &amp;&amp; (cacheP.empty || !cacheP.contains(laxCam)) &amp;&amp; (this.imageMap.length &gt; 0)) {
                                            if (resized) {
                                                this.updateBufferRegion(laxCam);
                                            }
                                            ctw     = this.cacheTilesWidth - 1;
                                            cth     = this.cacheTilesHeight - 1;
                                            ctw2    = ctw / 2;
                                            cth2    = cth / 2;
                        
                                            //only attempt to draw children that are relevant
                                            tempC.setAll(Math.round((laxCam.x - this.left) / this.tileWidth - ctw2) + ctw2, Math.round((laxCam.y - this.top) / this.tileHeight - cth2) + cth2, ctw, cth);
                                            if (tempC.left &lt; 0) {
                                                tempC.moveX(tempC.halfWidth);
                                            } else if (tempC.right &gt; this.tilesWidth - 1) {
                                                tempC.moveX(this.tilesWidth - 1 - tempC.halfWidth);
                                            }
                                            if (tempC.top &lt; 0) {
                                                tempC.moveY(tempC.halfHeight);
                                            } else if (tempC.bottom &gt; this.tilesHeight - 1) {
                                                tempC.moveY(this.tilesHeight - 1 - tempC.halfHeight);
                                            }
                                            
                                            if (!this.tileCache) {
                                                this.update(null, tempC);
                                            } else if (cache.empty || !tempC.contains(cache)) {
                                                this.tilesSpriteCache.texture = this.cacheTexture;
                                                this.cacheTexture = this.cacheTexture.alternate;
                                                this.tilesSprite.texture = this.cacheTexture;
                                                this.update(this.cacheTexture, tempC, this.tilesSpriteCache, cache);
                                            }
                        
                                            // Store pixel bounding box for checking later.
                                            cacheP.setAll((cache.x + 0.5) * this.tileWidth + this.left, (cache.y + 0.5) * this.tileHeight + this.top, (cache.width + 1) * this.tileWidth, (cache.height + 1) * this.tileHeight);
                                        }
                        
                                        if (this.cacheGrid) {
                                            for (x = 0; x &lt; this.cacheGrid.length; x++) {
                                                for (y = 0; y &lt; this.cacheGrid[x].length; y++) {
                                                    sprite = this.cacheGrid[x][y];
                                                    cacheP.setAll((x + 0.5) * this.cacheClipWidth + this.left, (y + 0.5) * this.cacheClipHeight + this.top, this.cacheClipWidth, this.cacheClipHeight);
                        
                                                    inFrame = cacheP.intersects(laxCam);
                                                    if (sprite.visible &amp;&amp; !inFrame) {
                                                        sprite.visible = false;
                                                    } else if (!sprite.visible &amp;&amp; inFrame) {
                                                        sprite.visible = true;
                                                    }
                                                    
                                                    if (sprite.visible &amp;&amp; inFrame) {
                                                        sprite.x = vp.left - laxCam.left + x * this.cacheClipWidth + this.left;
                                                        sprite.y = vp.top  - laxCam.top  + y * this.cacheClipHeight + this.top;
                                                    }
                                                }
                                            }
                                        } else if (this.tileCache) {
                                            this.tilesSprite.x = vp.left - laxCam.left + cache.left * this.tileWidth + this.left;
                                            this.tilesSprite.y = vp.top  - laxCam.top  + cache.top  * this.tileHeight + this.top;
                                        }
                                    },
                        
                                    updateTile: function (index, map, x, y) {
                                        var tile = null,
                                            tiles = this.tiles;
                                        
                                        if (index.id) {
                                            index = index.id;
                                        }
                                        tile = tiles[index];
                                        if (!tile &amp;&amp; (tile !== null)) { // Empty grid spaces are null, so we needn&#x27;t create a new tile.
                                            tile = tiles[index] = this.createTile(index);
                                        }
                                        map[x][y] = tile;
                                    },
                        
                                    createGrid: function (parentContainer) {
                                        var ch = this.cacheHeight,
                                            cw = this.cacheWidth,
                                            cth = this.cacheTilesHeight,
                                            ctw = this.cacheTilesWidth,
                                            h = 0,
                                            w = 0,
                                            outerMargin = EDGES_BLEED,
                                            extrusion = EDGE_BLEED,
                                            rt = null,
                                            sx = this.scaleX,
                                            sy = this.scaleY,
                                            th = this.tileHeight,
                                            tw = this.tileWidth,
                                            tsh = this.tilesHeight,
                                            tsw = this.tilesWidth,
                                            x = 0,
                                            y = 0,
                                            z = this.owner.z,
                                            col = null,
                                            ct = null,
                                            cg = Array.setUp();
                        
                                        for (x = 0; x &lt; tsw; x += ctw) {
                                            col = Array.setUp();
                                            cg.push(col);
                                            for (y = 0; y &lt; tsh; y += cth) {
                                                // This prevents us from using too large of a cache for the right and bottom edges of the map.
                                                w = Math.min(getPowerOfTwo((tsw - x) * tw + outerMargin), cw);
                                                h = Math.min(getPowerOfTwo((tsh - y) * th + outerMargin), ch);
                        
                                                rt = RenderTexture.create(w, h);
                                                rt.frame = new Rectangle(extrusion, extrusion, (((w - outerMargin) / tw) &gt;&gt; 0) * tw + extrusion, (((h - outerMargin) / th) &gt;&gt; 0) * th + extrusion);
                                                ct = new Sprite(rt);
                                                ct.z = z;
                                                ct.scale.x = sx;
                                                ct.scale.y = sy;
                                                col.push(ct);
                                                parentContainer.addChild(ct);
                        
                                                z -= 0.000001; // so that tiles of large caches overlap consistently.
                                            }
                                        }
                                        
                                        return cg;
                                    },
                                    
                                    updateRegion: function (margin) {
                                        var tw = this.tileWidth * this.scaleX,
                                            th = this.tileHeight * this.scaleY,
                                            ctw = Math.min(this.tilesWidth,  ((this.cacheWidth - EDGES_BLEED)  / tw)  &gt;&gt; 0),
                                            cth = Math.min(this.tilesHeight, ((this.cacheHeight - EDGES_BLEED) / th) &gt;&gt; 0);
                        
                                        if (!ctw) {
                                            platypus.debug.warn(&#x27;&quot;&#x27; + this.owner.type + &#x27;&quot; RenderTiles: The tiles are &#x27; + tw + &#x27;px wide which is larger than &#x27; + (this.cacheWidth - EDGES_BLEED) + &#x27;px (maximum cache size of &#x27; + this.cacheWidth + &#x27;px minus a 2px edge bleed). Increase the maximum cache size or reduce tile size.&#x27;);
                                        }
                                        if (!cth) {
                                            platypus.debug.warn(&#x27;&quot;&#x27; + this.owner.type + &#x27;&quot; RenderTiles: The tiles are &#x27; + th + &#x27;px high which is larger than &#x27; + (this.cacheHeight - EDGES_BLEED) + &#x27;px (maximum cache size of &#x27; + this.cacheHeight + &#x27;px minus a 2px edge bleed). Increase the maximum cache size or reduce tile size.&#x27;);
                                        }
                        
                                        this.cacheTilesWidth  = ctw;
                                        this.cacheTilesHeight = cth;
                                        this.cacheClipWidth   = ctw * tw;
                                        this.cacheClipHeight  = cth * th;
                        
                                        if (this.tileCache) {
                                            this.mapContainer.mask = new Graphics().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth + margin, this.cacheClipHeight + margin).endFill();
                                        }
                                    },
                        
                                    updateBufferRegion: function (viewport) {
                                        var tw = this.tileWidth * this.scaleX,
                                            th = this.tileHeight * this.scaleY;
                        
                                        this.cacheTilesWidth  = Math.min(this.tilesWidth,  Math.ceil((viewport.width  + this.buffer * 2) / tw), (this.cacheWidth  / tw) &gt;&gt; 0);
                                        this.cacheTilesHeight = Math.min(this.tilesHeight, Math.ceil((viewport.height + this.buffer * 2) / th), (this.cacheHeight / th) &gt;&gt; 0);
                        
                                        this.cacheClipWidth   = this.cacheTilesWidth  * tw;
                                        this.cacheClipHeight  = this.cacheTilesHeight * th;
                        
                                        this.mapContainer.mask = new Graphics().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth, this.cacheClipHeight).endFill();
                                    },
                        
                                    update: function (texture, bounds, tilesSpriteCache, oldBounds) {
                                        this.populate(bounds, oldBounds);
                        
                                        this.render(bounds, texture, this.mapContainer, this.mapContainerWrapper, tilesSpriteCache, oldBounds);
                        
                                        if (oldBounds) {
                                            oldBounds.set(bounds);
                                        }
                                    },
                                    
                                    populateTiles: function (bounds, oldBounds) {
                                        var x = 0,
                                            y = 0,
                                            z = 0,
                                            layer = 0,
                                            tile  = null,
                                            tiles = Array.setUp();
                        
                                        this.tileContainer.removeChildren();
                                        for (x = bounds.left; x &lt;= bounds.right; x++) {
                                            for (y = bounds.top; y &lt;= bounds.bottom; y++) {
                                                if (!oldBounds || oldBounds.empty || (y &gt; oldBounds.bottom) || (y &lt; oldBounds.top) || (x &gt; oldBounds.right) || (x &lt; oldBounds.left)) {
                                                    for (layer = 0; layer &lt; this.imageMap.length; layer++) {
                                                        tile = this.imageMap[layer][x][y].getNext();
                                                        if (tile) {
                                                            if (tile.template) {
                                                                tiles.push(tile.template);
                                                            }
                                                            tile.x = (x + 0.5) * this.tileWidth;
                                                            tile.y = (y + 0.5) * this.tileHeight;
                                                            this.tileContainer.addChild(tile);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                        
                                        // Clear out tile instances
                                        for (z = 0; z &lt; tiles.length; z++) {
                                            tiles[z].clear();
                                        }
                                        tiles.recycle();
                                    },
                                    
                                    populateTilesAndEntities: function (bounds, oldBounds) {
                                        var x = 0,
                                            y = 0,
                                            z = 0,
                                            layer   = 0,
                                            tile    = null,
                                            ent     = null,
                                            ents    = Array.setUp(),
                                            tiles   = Array.setUp(),
                                            oList   = null;
                        
                                        this.tileContainer.removeChildren();
                                        for (x = bounds.left; x &lt;= bounds.right; x++) {
                                            for (y = bounds.top; y &lt;= bounds.bottom; y++) {
                                                if (!oldBounds || oldBounds.empty || (y &gt; oldBounds.bottom) || (y &lt; oldBounds.top) || (x &gt; oldBounds.right) || (x &lt; oldBounds.left)) {
                                                    // draw tiles
                                                    for (layer = 0; layer &lt; this.imageMap.length; layer++) {
                                                        tile = this.imageMap[layer][x][y].getNext();
                                                        if (tile) {
                                                            if (tile.template) {
                                                                tiles.push(tile.template);
                                                            }
                                                            tile.x = (x + 0.5) * this.tileWidth;
                                                            tile.y = (y + 0.5) * this.tileHeight;
                                                            this.tileContainer.addChild(tile);
                                                        }
                                                    }
                        
                                                    // check for cached entities
                                                    if (this.doMap[x] &amp;&amp; this.doMap[x][y]) {
                                                        oList = this.doMap[x][y];
                                                        for (z = 0; z &lt; oList.length; z++) {
                                                            if (!oList[z].drawn) {
                                                                oList[z].drawn = true;
                                                                ents.push(oList[z]);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                        
                                        this.mapContainer.removeChildren();
                                        this.mapContainer.addChild(this.tileContainer);
                        
                                        // Draw cached entities
                                        if (ents.length) {
                                            ents.sort(sort);
                                            for (z = 0; z &lt; ents.length; z++) {
                                                ent = ents[z];
                                                delete ent.drawn;
                                                this.mapContainer.addChild(ent);
                                                if (ent.mask) {
                                                    this.mapContainer.addChild(ent.mask);
                                                }
                                            }
                                        }
                        
                                        // Clear out tile instances
                                        for (z = 0; z &lt; tiles.length; z++) {
                                            tiles[z].clear();
                                        }
                                        
                                        tiles.recycle();
                                        ents.recycle();
                                    },
                                    
                                    renderCache: function (bounds, dest, src, wrapper, oldCache, oldBounds) {
                                        var renderer = this.renderer;
                        
                                        if (oldCache &amp;&amp; !oldBounds.empty) {
                                            oldCache.x = oldBounds.left * this.tileWidth;
                                            oldCache.y = oldBounds.top * this.tileHeight;
                                            src.addChild(oldCache); // To copy last rendering over.
                                        }
                        
                                        clearRenderTexture(renderer, dest);
                                        src.x = -bounds.left * this.tileWidth;
                                        src.y = -bounds.top * this.tileHeight;
                                        renderer.render(wrapper, dest);
                                        dest.requiresUpdate = true;
                                    },
                        
                                    renderCacheWithExtrusion: function (bounds, dest, src, wrapper) {
                                        var extrusion = 1,
                                            border = new Graphics(),
                                            renderer = this.renderer;
                        
                                        // This mask makes only the extruded border drawn for the next 4 draws so that inner holes aren&#x27;t extruded in addition to the outer rim.
                                        border.lineStyle(1, 0x000000);
                                        border.drawRect(0.5, 0.5, this.cacheClipWidth + 1, this.cacheClipHeight + 1);
                        
                                        clearRenderTexture(renderer, dest);
                        
                                        // There is probably a better way to do this. Currently for the extrusion, everything is rendered once offset in the n, s, e, w directions and then once in the middle to create the effect.
                                        wrapper.mask = border;
                                        src.x = -bounds.left * this.tileWidth;
                                        src.y = -bounds.top * this.tileHeight + extrusion;
                                        renderer.render(wrapper, dest);
                                        src.x = -bounds.left * this.tileWidth + extrusion;
                                        src.y = -bounds.top * this.tileHeight;
                                        renderer.render(wrapper, dest);
                                        src.x = -bounds.left * this.tileWidth + extrusion * 2;
                                        src.y = -bounds.top * this.tileHeight + extrusion;
                                        renderer.render(wrapper, dest);
                                        src.x = -bounds.left * this.tileWidth + extrusion;
                                        src.y = -bounds.top * this.tileHeight + extrusion * 2;
                                        renderer.render(wrapper, dest);
                                        wrapper.mask = null;
                                        src.x = -bounds.left * this.tileWidth + extrusion;
                                        src.y = -bounds.top * this.tileHeight + extrusion;
                                        renderer.render(wrapper, dest);
                                        dest.requiresUpdate = true;
                                    },
                                    
                                    updateGrid: function () {
                                        var cache = this.cache,
                                            cth = this.cacheTilesHeight,
                                            ctw = this.cacheTilesWidth,
                                            tsh = this.tilesHeight - 1,
                                            tsw = this.tilesWidth - 1,
                                            x = 0,
                                            y = 0,
                                            grid = this.cacheGrid;
                        
                                        for (x = 0; x &lt; grid.length; x++) {
                                            for (y = 0; y &lt; grid[x].length; y++) {
                                                cache.setBounds(x * ctw, y * cth, Math.min((x + 1) * ctw, tsw), Math.min((y + 1) * cth, tsh));
                                                this.update(grid[x][y].texture, cache);
                                            }
                                        }
                                    },
                        
                                    toJSON: function () { // This component is added by another component, so it shouldn&#x27;t be returned for reconstruction.
                                        var imageMap = this.imageMap[0],
                                            imgMap = [],
                                            x = imageMap.length,
                                            y = 0;
                                        
                                        while (x--) {
                                            y = imageMap[x].length;
                                            imgMap[x] = [];
                                            while (y--) {
                                                imgMap[x][y] = imageMap[x][y].id;
                                            }
                                        }
                        
                                        return {
                                            type: &#x27;RenderTiles&#x27;,
                                            buffer: this.buffer,
                                            cacheAll: this.cacheAll,
                                            entityCache: this.entityCache,
                                            imageMap: imgMap,
                                            maximumBuffer: this.maximumBuffer,
                                            scaleX: this.scaleX,
                                            scaleY: this.scaleY,
                                            spriteSheet: this.spriteSheet,
                                            tileCache: this.tileCache,
                                            tileHeight: this.tileHeight,
                                            tileWidth: this.tileWidth,
                                            top: this.top,
                                            left: this.left
                                        };
                                    },
                        
                                    destroy: function () {
                                        var x = 0,
                                            y = 0,
                                            key = &#x27;&#x27;,
                                            grid = this.cacheGrid,
                                            map = this.doMap,
                                            img = this.imageMap;
                                            
                                        if (grid) {
                                            for (x = 0; x &lt; grid.length; x++) {
                                                for (y = 0; y &lt; grid[x].length; y++) {
                                                    grid[x][y].texture.destroy(true);
                                                    this.parentContainer.removeChild(grid[x][y]);
                                                }
                                            }
                                            grid.recycle(2);
                                            delete this.cacheGrid;
                                        } else if (this.tilesSprite) {
                                            if (this.tilesSprite.texture.alternate) {
                                                this.tilesSprite.texture.alternate.destroy(true);
                                            }
                                            this.tilesSprite.texture.destroy(true);
                                            this.parentContainer.removeChild(this.tilesSprite);
                                        } else {
                                            this.parentContainer.removeChild(this.mapContainer);
                                        }
                                        
                                        img.recycle(2);
                                        
                                        for (key in this.tiles) {
                                            if (this.tiles.hasOwnProperty(key)) {
                                                this.tiles[key].destroy();
                                            }
                                        }
                                        this.tiles = null;
                                        this.parentContainer = null;
                                        this.tilesSprite = null;
                                        this.spriteSheet.recycleSpriteSheet();
                                        
                                        if (map) {
                                            for (x = 0; x &lt; this.cachedDisplayObjects.length; x++) {
                                                this.cachedDisplayObjects[x].destroy();
                                            }
                                            this.cachedDisplayObjects.recycle();
                        
                                            for (x = 0; x &lt; map.length; x++) {
                                                if (map[x]) {
                                                    for (y = 0; y &lt; map.length; y++) {
                                                        if (map[x][y]) {
                                                            map[x][y].recycle();
                                                        }
                                                    }
                                                    map[x].recycle();
                                                }
                                            }
                                            map.recycle();
                                        }
                                        
                                        this.laxCam.recycle();
                                        this.cache.recycle();
                                        this.cachePixels.recycle();
                                    }
                                },
                                
                                getAssetList: (function () {
                                    var
                                        getImages = function (ss, spriteSheets) {
                                            if (ss) {
                                                if (typeof ss === &#x27;string&#x27;) {
                                                    return getImages(spriteSheets[ss], spriteSheets);
                                                } else if (ss.images) {
                                                    return ss.images.greenSlice();
                                                }
                                            }
                        
                                            return Array.setUp();
                                        };
                                    
                                    return function (component, props, defaultProps) {
                                        var arr = null,
                                            i = 0,
                                            images = null,
                                            spriteSheets = platypus.game.settings.spriteSheets,
                                            ss = component.spriteSheet || props.spriteSheet || defaultProps.spriteSheet;
                                        
                                        if (ss) {
                                            if (typeof ss === &#x27;string&#x27; &amp;&amp; (ss !== &#x27;import&#x27;)) {
                                                return getImages(ss, spriteSheets);
                                            } else if (Array.isArray(ss)) {
                                                i = ss.length;
                                                images = Array.setUp();
                                                while (i--) {
                                                    arr = getImages(ss[i], spriteSheets);
                                                    images.union(arr);
                                                    arr.recycle();
                                                }
                                                return images;
                                            } else if (ss.images) {
                                                return ss.images.greenSlice();
                                            }
                                        }
                                        
                                        return Array.setUp();
                                    };
                                }())
                            });
                        }());
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
