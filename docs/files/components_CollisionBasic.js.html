<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v0.10.4 API Documentation : components\CollisionBasic.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.10.4</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.EventRender.html">platypus.components.EventRender</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimation.html">platypus.components.RenderAnimation</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.StateRender.html">platypus.components.StateRender</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.PlatypusPlugin.html">platypus.PlatypusPlugin</a></li>
                                <li><a href="../classes/platypus.Scene.html">platypus.Scene</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/window.Array.html">window.Array</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                                <li><a href="../classes/window.String.html">window.String</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = components\CollisionBasic.js      
                        </script>
                        <h1 class="file-heading">File:components\CollisionBasic.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component causes this entity to collide with other entities. It must be part of a collision group and will receive messages when colliding with other entities in the collision group.
                         *
                         * Multiple collision components may be added to a single entity if distinct messages should be triggered for certain collision areas on the entity or if the soft collision area is a different shape from the solid collision area. Be aware that too many additional collision areas may adversely affect performance.
                         *
                         * @namespace platypus.components
                         * @class CollisionBasic
                         * @uses platypus.Component
                         */
                        /* global include, platypus */
                        (function () {
                            &#x27;use strict&#x27;;
                            
                            var AABB = include(&#x27;platypus.AABB&#x27;),
                                CollisionShape = include(&#x27;platypus.CollisionShape&#x27;),
                                Data = include(&#x27;platypus.Data&#x27;),
                                DataMap = include(&#x27;platypus.DataMap&#x27;),
                                Vector = include(&#x27;platypus.Vector&#x27;),
                        
                                /**
                                 * On receiving a &#x27;hit-by&#x27; message, custom messages are triggered on the entity corresponding with the component&#x27;s &#x60;solidCollisions&#x60; and &#x60;softCollisions&#x60; key/value mappings.
                                 *
                                 * @event *
                                 * @param collision {Object} A list of key/value pairs describing the collision.
                                 */
                                entityBroadcast = (function () {
                                    var stringBroadcast = function (event, collisionType, solidOrSoft, value) {
                                            if (value.myType === collisionType) {
                                                if (value.hitType === solidOrSoft) {
                                                    this.owner.triggerEvent(event, value);
                                                }
                                            }
                                        },
                                        arrayBroadcast = function (event, collisionType, solidOrSoft, value) {
                                            var i = 0;
                                            
                                            if (value.myType === collisionType) {
                                                if (value.hitType === solidOrSoft) {
                                                    for (i = 0; i &lt; event.length; i++) {
                                                        this.owner.triggerEvent(event[i], value);
                                                    }
                                                }
                                            }
                                        },
                                        directionalBroadcast = function (event, collisionType, solidOrSoft, collisionInfo) {
                                            var dx = collisionInfo.x,
                                                dy = collisionInfo.y;
                        
                                            if (collisionInfo.entity &amp;&amp; !(dx || dy)) {
                                                dx = collisionInfo.entity.x - this.owner.x;
                                                dy = collisionInfo.entity.y - this.owner.y;
                                            }
                        
                                            if (collisionInfo.myType === collisionType) {
                                                if (collisionInfo.hitType === solidOrSoft) {
                                                    if ((dy &gt; 0) &amp;&amp; event.bottom) {
                                                        this.owner.trigger(event.bottom, collisionInfo);
                                                    } else if ((dy &lt; 0) &amp;&amp; event.top) {
                                                        this.owner.trigger(event.top, collisionInfo);
                                                    }
                                                    if ((dx &gt; 0) &amp;&amp; event.right) {
                                                        this.owner.trigger(event.right, collisionInfo);
                                                    } else if ((dx &lt; 0) &amp;&amp; event.left) {
                                                        this.owner.trigger(event.left, collisionInfo);
                                                    }
                                                    if (event.all) {
                                                        this.owner.trigger(event.all, collisionInfo);
                                                    }
                                                }
                                            }
                                        };
                                    
                                    return function (self, event, solidOrSoft) {
                                        if (typeof event === &#x27;string&#x27;) {
                                            return stringBroadcast.bind(self, event, self.collisionType, solidOrSoft);
                                        } else if (Array.isArray(event)) {
                                            return arrayBroadcast.bind(self, event, self.collisionType, solidOrSoft);
                                        } else {
                                            return directionalBroadcast.bind(self, event, self.collisionType, solidOrSoft);
                                        }
                                    };
                                }()),
                                setupCollisionFunctions = (function () {
                                    var entityGetAABB = function (aabb, colFuncs, collisionType) {
                                            var keys = colFuncs.keys,
                                                i = keys.length,
                                                funcs = null;
                        
                                            if (!collisionType) {
                                                aabb.reset();
                                                while (i--) {
                                                    aabb.include(colFuncs.get(keys[i]).getAABB());
                                                }
                                                return aabb;
                                            } else {
                                                funcs = colFuncs.get(collisionType);
                                                if (funcs) {
                                                    return funcs.getAABB();
                                                } else {
                                                    return null;
                                                }
                                            }
                                        },
                                        entityGetPreviousAABB = function (colFuncs, collisionType) {
                                            var colFunc = colFuncs.get(collisionType);
                                            
                                            if (colFunc) {
                                                return colFunc.getPreviousAABB();
                                            } else {
                                                return null;
                                            }
                                        },
                                        entityGetShapes = function (colFuncs, collisionType) {
                                            var colFunc = colFuncs.get(collisionType);
                                            
                                            if (colFunc) {
                                                return colFunc.getShapes();
                                            } else {
                                                return null;
                                            }
                                        },
                                        entityGetPrevShapes = function (colFuncs, collisionType) {
                                            var colFunc = colFuncs.get(collisionType);
                                            
                                            if (colFunc) {
                                                return colFunc.getPrevShapes();
                                            } else {
                                                return null;
                                            }
                                        },
                                        entityPrepareCollision = function (colFuncs, x, y) {
                                            var keys = colFuncs.keys,
                                                i = keys.length;
                                            
                                            while (i--) {
                                                colFuncs.get(keys[i]).prepareCollision(x, y);
                                            }
                                        },
                                        entityRelocateEntity = (function () {
                                            var handleStuck = function (position, data, owner) {
                                                    var m = 0,
                                                        s = data.stuck;
                        
                                                    if (s) {
                                                        m = position.magnitude();
                                                        if (data.thatShape.owner &amp;&amp; (Math.abs(s) &gt; 1)) {
                                                            s *= 0.05;
                                                        }
                                                        if (!m || (m &gt; Math.abs(s))) {
                                                            if (data.vector.x) {
                                                                position.x = s;
                                                                position.y = 0;
                                                            }
                                                            if (data.vector.y) {
                                                                position.x = 0;
                                                                position.y = s;
                                                            }
                                                            if (owner.stuckWith) {
                                                                owner.stuckWith.recycle();
                                                            }
                                                            owner.stuckWith = Vector.setUp(data.thatShape.x, data.thatShape.y);
                                                        }
                                                    }
                                                },
                                                message = {
                                                    position: null,
                                                    unstick: null
                                                };
                                            
                                            return function (vector, collisionData) {
                                                var colX = collisionData.xData[0],
                                                    colY = collisionData.yData[0],
                                                    msg = message,
                                                    v = null;
                        
                                                if (colX) {
                                                    v = Vector.setUp(0, 0, 0);
                                                    handleStuck(v, colX, this);
                                                }
                        
                                                if (colY) {
                                                    v = v || Vector.setUp(0, 0, 0);
                                                    handleStuck(v, colY, this);
                                                }
                        
                                                msg.position = vector;
                                                msg.unstick = v;
                                                this.triggerEvent(&#x27;relocate-entity&#x27;, msg);
                                                
                                                if (v) {
                                                    v.recycle();
                                                }
                                            };
                                        }()),
                                        entityMovePreviousX = function (colFuncs, x) {
                                            var keys = colFuncs.keys,
                                                i = keys.length;
                                            
                                            while (i--) {
                                                colFuncs.get(keys[i]).movePreviousX(x);
                                            }
                                        },
                                        entityGetCollisionTypes = function () {
                                            return this.collisionTypes;
                                        },
                                        entityGetSolidCollisions = function () {
                                            return this.solidCollisionMap;
                                        },
                                        getAABB = function () {
                                            return this.getAABB();
                                        },
                                        getPreviousAABB = function () {
                                            return this.getPreviousAABB();
                                        },
                                        getShapes = function () {
                                            return this.getShapes();
                                        },
                                        getPrevShapes = function () {
                                            return this.getPrevShapes();
                                        },
                                        prepareCollision = function (x, y) {
                                            this.prepareCollision(x, y);
                                        },
                                        movePreviousX = function (x) {
                                            this.movePreviousX(x);
                                        };
                                    
                                    return function (self, entity) {
                                        var colFuncs = entity.collisionFunctions;
                                        
                                        // This allows the same component type to be added multiple times.
                                        if (!colFuncs) {
                                            colFuncs = entity.collisionFunctions = DataMap.setUp();
                                            entity.aabb = AABB.setUp();
                                            entity.getAABB = entityGetAABB.bind(entity, entity.aabb, colFuncs);
                                            entity.getPreviousAABB = entityGetPreviousAABB.bind(entity, colFuncs);
                                            entity.getShapes = entityGetShapes.bind(entity, colFuncs);
                                            entity.getPrevShapes = entityGetPrevShapes.bind(entity, colFuncs);
                                            entity.prepareCollision = entityPrepareCollision.bind(entity, colFuncs);
                                            entity.relocateEntity = entityRelocateEntity.bind(entity);
                                            entity.movePreviousX = entityMovePreviousX.bind(entity, colFuncs);
                                            entity.getCollisionTypes = entityGetCollisionTypes.bind(entity);
                                            entity.getSolidCollisions = entityGetSolidCollisions.bind(entity);
                                        }
                        
                                        colFuncs.set(self.collisionType, Data.setUp(
                                            &quot;getAABB&quot;, getAABB.bind(self),
                                            &quot;getPreviousAABB&quot;, getPreviousAABB.bind(self),
                                            &quot;getShapes&quot;, getShapes.bind(self),
                                            &quot;getPrevShapes&quot;, getPrevShapes.bind(self),
                                            &quot;prepareCollision&quot;, prepareCollision.bind(self),
                                            &quot;movePreviousX&quot;, movePreviousX.bind(self)
                                        ));
                                    };
                                }());
                        
                            return platypus.createComponentClass({
                                
                                id: &#x27;CollisionBasic&#x27;,
                        
                                properties: {
                                    /**
                                     * Defines how this entity should be recognized by other colliding entities.
                                     *
                                     * @property collisionType
                                     * @type String
                                     * @default &quot;none&quot;
                                     */
                                    collisionType: &quot;none&quot;,
                        
                                    /**
                                     * Defines the type of colliding shape.
                                     *
                                     * @property shapeType
                                     * @type String
                                     * @default &quot;rectangle&quot;
                                     */
                                    shapeType: &quot;rectangle&quot;,
                                    
                                    /**
                                     * Determines whether the collision area should transform on orientation changes.
                                     *
                                     * @property ignoreOrientation
                                     * @type boolean
                                     * @default false
                                     */
                                    ignoreOrientation: false,
                                    
                                    /**
                                     * Determines the x-axis center of the collision shape.
                                     *
                                     * @property regX
                                     * @type number
                                     * @default width / 2
                                     */
                                    regX: null,
                                    
                                    /**
                                     * Determines the y-axis center of the collision shape.
                                     *
                                     * @property regY
                                     * @type number
                                     * @default height / 2
                                     */
                                    regY: null,
                                    
                                    /**
                                     * Sets the width of the collision area in world coordinates.
                                     *
                                     * @property width
                                     * @type number
                                     * @default 0
                                     */
                                    width: 0,
                                    
                                    /**
                                     * Sets the height of the collision area in world coordinates.
                                     *
                                     * @property height
                                     * @type number
                                     * @default 0
                                     */
                                    height: 0,
                                    
                                    /**
                                     * Sets the radius of a circle collision area in world coordinates.
                                     *
                                     * @property radius
                                     * @type number
                                     * @default 0
                                     */
                                    radius: 0,
                                    
                                    /**
                                     * Determines which collision types this entity should consider soft, meaning this entity may pass through them, but triggers collision messages on doing so. Example:
                                     *
                                     *     {
                                     *         &quot;water&quot;: &quot;soaked&quot;,       // This triggers a &quot;soaked&quot; message on the entity when it passes over a &quot;water&quot; collision-type entity.
                                     *         &quot;lava&quot;: [&quot;burn&quot;, &quot;ouch&quot;] // This triggers both messages on the entity when it passes over a &quot;lava&quot; collision-type entity.
                                     *     }
                                     *
                                     * @property softCollisions
                                     * @type Object
                                     * @default null
                                     */
                                    softCollisions: null,
                                    
                                    /**
                                     * Determines which collision types this entity should consider solid, meaning this entity should not pass through them. Example:
                                     *
                                     *     {
                                     *         &quot;boulder&quot;: &quot;&quot;,                       // This specifies that this entity should not pass through other &quot;boulder&quot; collision-type entities.
                                     *         &quot;diamond&quot;: &quot;crack-up&quot;,               // This specifies that this entity should not pass through &quot;diamond&quot; collision-type entities, but if it touches one, it triggers a &quot;crack-up&quot; message on the entity.
                                     *         &quot;marble&quot;: [&quot;flip&quot;, &quot;dance&quot;, &quot;crawl&quot;] // This specifies that this entity should not pass through &quot;marble&quot; collision-type entities, but if it touches one, it triggers all three specified messages on the entity.
                                     *     }
                                     *
                                     * @property solidCollisions
                                     * @type Object
                                     * @default null
                                     */
                                    solidCollisions: null,
                                    
                                    /**
                                     * This is the margin around the entity&#x27;s width and height. This is an alternative method for specifying the collision shape in terms of the size of the entity. Can also pass in an object specifying the following parameters if the margins vary per side: top, bottom, left, and right.
                                     *
                                     * @property margin
                                     * @type number|Object
                                     * @default 0
                                     */
                                    margin: 0,
                                    
                                    /**
                                     * Defines one or more shapes to create the collision area. Defaults to a single shape with the width, height, regX, and regY properties of the entity if not specified. See [CollisionShape](CollisionShape.html) for the full list of properties.
                                     *
                                     * @property shapes
                                     * @type Array
                                     * @default null
                                     */
                                    shapes: null
                                },
                                
                                publicProperties: {
                                    /**
                                     * This property should be set to true if entity doesn&#x27;t move for better optimization. This causes other entities to check against this entity, but this entity performs no checks of its own. Available on the entity as &#x60;entity.immobile&#x60;.
                                     *
                                     * @property immobile
                                     * @type boolean
                                     * @default false
                                     */
                                    immobile: false,
                        
                                    /**
                                     * Whether this entity should be tested across its entire movement path. This is necessary for fast-moving entities, but shouldn&#x27;t be used for others due to the processing overhead. Available on the entity as &#x60;entity.bullet&#x60;.
                                     *
                                     * @property bullet
                                     * @type boolean
                                     * @default false
                                     */
                                    bullet: false,
                                    
                                    /**
                                     * Whether the entity is only solid when being collided with from the top.
                                     *
                                     * @property jumpThrough
                                     * @type boolean
                                     * @default: false
                                     */
                                    jumpThrough: false
                                },
                                
                                initialize: function (definition) {
                                    var arr = null,
                                        x            = 0,
                                        key          = &#x27;&#x27;,
                                        shapes       = null,
                                        regX         = this.regX,
                                        regY         = this.regY,
                                        width        = this.width,
                                        height       = this.height,
                                        radius       = this.radius,
                                        marginLeft   = 0,
                                        marginRight  = 0,
                                        marginTop    = 0,
                                        marginBottom = 0;
                        
                                    if (typeof this.margin === &quot;number&quot;) {
                                        marginLeft   = this.margin;
                                        marginRight  = this.margin;
                                        marginTop    = this.margin;
                                        marginBottom = this.margin;
                                    } else {
                                        marginLeft   = this.margin.left || 0;
                                        marginRight  = this.margin.right || 0;
                                        marginTop    = this.margin.top || 0;
                                        marginBottom = this.margin.bottom || 0;
                                    }
                                    
                                    if (regX === null) {
                                        regX = this.regX = width / 2;
                                    }
                                    
                                    if (regY === null) {
                                        regY = this.regY = height / 2;
                                    }
                                    
                                    Vector.assign(this.owner, &#x27;position&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;);
                                    Vector.assign(this.owner, &#x27;previousPosition&#x27;, &#x27;previousX&#x27;, &#x27;previousY&#x27;, &#x27;previousZ&#x27;);
                                    this.owner.previousX = this.owner.previousX || this.owner.x;
                                    this.owner.previousY = this.owner.previousY || this.owner.y;
                                    
                                    this.aabb     = AABB.setUp();
                                    this.prevAABB = AABB.setUp();
                                    
                                    if (this.shapes) {
                                        shapes = this.shapes;
                                    } else if (this.shapeType === &#x27;circle&#x27;) {
                                        radius = radius || (((width || 0) + (height || 0)) / 4);
                                        shapes = [{
                                            regX: (isNaN(regX) ? radius : regX) - (marginRight - marginLeft) / 2,
                                            regY: (isNaN(regY) ? radius : regY) - (marginBottom - marginTop) / 2,
                                            radius: radius,
                                            type: this.shapeType
                                        }];
                                    } else {
                                        shapes = [{
                                            //regX: (isNaN(regX) ? (width  || 0) / 2 : regX) - (marginRight  - marginLeft) / 2,
                                            //regY: (isNaN(regY) ? (height || 0) / 2 : regY) - (marginBottom - marginTop)  / 2,
                                            regX: (isNaN(regX) ? (width  || 0) / 2 : regX) + marginLeft,
                                            regY: (isNaN(regY) ? (height || 0) / 2 : regY) + marginTop,
                                            points: definition.points,
                                            width: (width  || 0) + marginLeft + marginRight,
                                            height: (height || 0) + marginTop  + marginBottom,
                                            type: this.shapeType
                                        }];
                                    }
                                    
                                    this.owner.collisionTypes = this.owner.collisionTypes || Array.setUp();
                                    this.owner.collisionTypes.push(this.collisionType);
                                    
                                    this.shapes = Array.setUp();
                                    this.prevShapes = Array.setUp();
                                    this.entities = null;
                                    for (x = 0; x &lt; shapes.length; x++) {
                                        this.shapes.push(CollisionShape.setUp(this.owner, shapes[x], this.collisionType));
                                        this.prevShapes.push(CollisionShape.setUp(this.owner, shapes[x], this.collisionType));
                                        this.prevAABB.include(this.prevShapes[x].aABB);
                                        this.aabb.include(this.shapes[x].aABB);
                                    }
                                    
                                    setupCollisionFunctions(this, this.owner);
                                    
                                    this.owner.solidCollisionMap = this.owner.solidCollisionMap || DataMap.setUp();
                                    arr = this.owner.solidCollisionMap.set(this.collisionType, Array.setUp());
                                    if (this.solidCollisions) {
                                        for (key in this.solidCollisions) {
                                            if (this.solidCollisions.hasOwnProperty(key)) {
                                                arr.push(key);
                                                if (this.solidCollisions[key]) { // To make sure it&#x27;s not an empty string.
                                                    this.addEventListener(&#x27;hit-by-&#x27; + key, entityBroadcast(this, this.solidCollisions[key], &#x27;solid&#x27;));
                                                }
                                            }
                                        }
                                    }
                            
                                    this.owner.softCollisionMap = this.owner.softCollisionMap || DataMap.setUp();
                                    arr = this.owner.softCollisionMap.set(this.collisionType, Array.setUp());
                                    if (this.softCollisions) {
                                        for (key in this.softCollisions) {
                                            if (this.softCollisions.hasOwnProperty(key)) {
                                                arr.push(key);
                                                if (this.softCollisions[key]) { // To make sure it&#x27;s not an empty string.
                                                    this.addEventListener(&#x27;hit-by-&#x27; + key, entityBroadcast(this, this.softCollisions[key], &#x27;soft&#x27;));
                                                }
                                            }
                                        }
                                    }
                                    
                                    this.stuck = false;
                                },
                                
                                events: {
                                    /**
                                     * On receiving this message, the component triggers &#x60;add-collision-entity&#x60; on the parent.
                                     *
                                     * @method &#x27;collide-on&#x27;
                                     * @param type {String} If specified, only collision components of this type are added to the collision list.
                                     */
                                    &quot;collide-on&quot;: function (type) {
                                        var owner = this.owner,
                                            colType = this.collisionType,
                                            colTypes = owner.collisionTypes;
                                        
                                        /**
                                         * On receiving &#x27;collide-on&#x27;, this message is triggered on the parent to turn on collision.
                                         *
                                         * @event &#x27;add-collision-entity&#x27;
                                         * @param entity {platypus.Entity} The entity this component is attached to.
                                         */
                                        if ((typeof type !== &#x27;string&#x27;) || (type === colType)) {
                                            if (colTypes.indexOf(colType) === -1) {
                                                colTypes.push(colType);
                                            }
                                            owner.parent.triggerEvent(&#x27;add-collision-entity&#x27;, owner);
                                            this.active = true;
                                        }
                                    },
                                    
                                    /**
                                     * On receiving this message, the component triggers &#x60;remove-collision-entity&#x60; on the parent.
                                     *
                                     * @method &#x27;collide-off&#x27;
                                     * @param type {String} If specified, only collision components of this type are removed from the collision list.
                                     */
                                    &quot;collide-off&quot;: function (type) {
                                        var index = 0,
                                            owner = this.owner,
                                            parent = owner.parent,
                                            colType = this.collisionType,
                                            colTypes = owner.collisionTypes;
                                        
                                        /**
                                         * On receiving &#x27;collide-off&#x27;, this message is triggered on the parent to turn off collision.
                                         *
                                         * @event &#x27;remove-collision-entity&#x27;
                                         * @param entity {platypus.Entity} The entity this component is attached to.
                                         */
                                        if ((typeof type !== &#x27;string&#x27;) || (type === colType)) {
                                            parent.triggerEvent(&#x27;remove-collision-entity&#x27;, owner);
                                            index = colTypes.indexOf(colType);
                                            if (index &gt;= 0) {
                                                colTypes.greenSplice(index);
                                            }
                                            this.active = false;
                        
                                            if (colTypes.length) {
                                                parent.triggerEvent(&#x27;add-collision-entity&#x27;, owner);
                                            }
                                        }
                                    },
                                    
                                    /**
                                     * This message causes the entity&#x27;s x,y coordinates to update.
                                     *
                                     * @method &#x27;relocate-entity&#x27;
                                     * @param position {platypus.Vector} The new coordinates.
                                     * @param [position.relative=false] {boolean} Determines whether the provided x,y coordinates are relative to the entity&#x27;s current position.
                                     */
                                    &quot;relocate-entity&quot;: function (resp) {
                                        var unstick = resp.unstick,
                                            um      = 0,
                                            i       = 0,
                                            x       = 0,
                                            y       = 0,
                                            aabb    = this.aabb,
                                            owner   = this.owner,
                                            shape   = null,
                                            shapes  = this.shapes;
                                        
                                        if (unstick) {
                                            um = unstick.magnitude();
                                        }
                                        
                                        if (this.move) {
                                            this.move.recycle();
                                            this.move = null;
                                        }
                                        
                                        if (resp.relative) {
                                            owner.position.setVector(owner.previousPosition).add(resp.position);
                                        } else {
                                            owner.position.setVector(resp.position);
                                        }
                        
                                        if (this.stuck) {
                                            if (um &gt; 0) {
                                                owner.position.add(unstick);
                                            } else {
                                                this.stuck = false;
                                            }
                                        }
                                        
                                        x = owner.x;
                                        y = owner.y;
                                        
                                        aabb.reset();
                                        i = shapes.length;
                                        while (i--) {
                                            shape = shapes[i];
                                            shape.update(x, y);
                                            aabb.include(shape.aABB);
                                        }
                        
                                        owner.previousPosition.setVector(owner.position);
                                        
                                        if (um &gt; 0) { // to force check in all directions for ultimate stuck resolution (esp. for stationary entities)
                                            if (!this.stuck) {
                                                this.stuck = true;
                                            }
                                            this.move = owner.stuckWith.copy().add(-x, -y).normalize();
                                        }
                                    },
                                    
                                    /**
                                     * If the entity is stuck to another entity, this component tries to unstick the entity on each logic step.
                                     *
                                     * @method &#x27;handle-logic&#x27;
                                     */
                                    &quot;handle-logic&quot;: function () {
                                        if (this.move) {
                                            this.owner.position.add(this.move); // By trying to move into it, we should get pushed back out.
                                        }
                                    },
                                    
                                    /**
                                     * Collision shapes are updated to reflect the new orientation when this message occurs.
                                     *
                                     * @method &#x27;orientation-updated&#x27;
                                     * @param matrix {Array} A 2D matrix describing the new orientation.
                                     */
                                    &quot;orientation-updated&quot;: function (matrix) {
                                        var i = 0;
                                        
                                        if (!this.ignoreOrientation) {
                                            for (i = 0; i &lt; this.shapes.length; i++) {
                                                this.shapes[i].multiply(matrix);
                                            }
                                        }
                                    }
                                },
                                
                                methods: {
                                    getAABB: function () {
                                        return this.aabb;
                                    },
                                    
                                    getPreviousAABB: function () {
                                        return this.prevAABB;
                                    },
                                    
                                    getShapes: function () {
                                        return this.shapes;
                                    },
                                    
                                    getPrevShapes: function () {
                                        return this.prevShapes;
                                    },
                                    
                                    prepareCollision: function (x, y) {
                                        var i          = 0,
                                            shape      = null,
                                            prevShapes = this.shapes,
                                            shapes     = this.prevShapes,
                                            aabb       = this.aabb;
                                        
                                        this.owner.x = x;
                                        this.owner.y = y;
                                        
                                        this.prevShapes = prevShapes;
                                        this.shapes = shapes;
                                        
                                        this.prevAABB.set(aabb);
                                        aabb.reset();
                                        
                                        // update shapes
                                        i = shapes.length;
                                        while (i--) {
                                            shape = shapes[i];
                                            shape.update(x, y);
                                            aabb.include(shape.aABB);
                                        }
                                    },
                                    
                                    movePreviousX: function (x) {
                                        var i = 0;
                                        
                                        this.prevAABB.moveX(x);
                                        for (i = 0; i &lt; this.prevShapes.length; i++) {
                                            this.prevShapes[i].setXWithEntityX(x);
                                        }
                                    },
                                    
                                    destroy: function () {
                                        var colFuncs = this.owner.collisionFunctions,
                                            collisionType = this.collisionType,
                                            i = this.owner.collisionTypes.indexOf(collisionType),
                                            owner = this.owner;
                                        
                                        owner.parent.triggerEvent(&#x27;remove-collision-entity&#x27;, owner);
                        
                                        this.aabb.recycle();
                                        delete this.aabb;
                                        this.prevAABB.recycle();
                                        delete this.prevAABB;
                                        
                                        if (i &gt;= 0) {
                                            owner.collisionTypes.greenSplice(i);
                                        }
                                        
                                        if (owner.solidCollisionMap.has(collisionType)) {
                                            owner.solidCollisionMap.delete(collisionType).recycle();
                                        }
                                        if (owner.softCollisionMap.has(collisionType)) {
                                            owner.softCollisionMap.delete(collisionType).recycle();
                                        }
                        
                                        colFuncs.delete(collisionType).recycle();
                                        
                                        i = this.shapes.length;
                                        while (i--) {
                                            this.shapes[i].recycle();
                                            this.prevShapes[i].recycle();
                                        }
                                        this.shapes.recycle();
                                        this.prevShapes.recycle();
                                        delete this.shapes;
                                        delete this.prevShapes;
                        
                                        delete this.entities;
                        
                                        if (owner.collisionTypes.length) {
                                            owner.parent.triggerEvent(&#x27;add-collision-entity&#x27;, owner);
                                        } else { //remove collision functions
                                            colFuncs.recycle();
                                            owner.collisionFunctions = null;
                                            owner.solidCollisionMap.recycle();
                                            owner.solidCollisionMap = null;
                                            owner.softCollisionMap.recycle();
                                            owner.softCollisionMap = null;
                                            owner.aabb.recycle();
                                            owner.aabb = null;
                                        }
                                    }
                                }
                            });
                        }());
                            
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
