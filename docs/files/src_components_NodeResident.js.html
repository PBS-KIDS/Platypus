<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v1.0.1 API Documentation : src\components\NodeResident.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 1.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.EventRender.html">platypus.components.EventRender</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicDragDrop.html">platypus.components.LogicDragDrop</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicRotationalMovement.html">platypus.components.LogicRotationalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelativePosition.html">platypus.components.RelativePosition</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimation.html">platypus.components.RenderAnimation</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderText.html">platypus.components.RenderText</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.StateRender.html">platypus.components.StateRender</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.Tween.html">platypus.components.Tween</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.PlatypusPlugin.html">platypus.PlatypusPlugin</a></li>
                                <li><a href="../classes/platypus.Scene.html">platypus.Scene</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/window.Array.html">window.Array</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                                <li><a href="../classes/window.String.html">window.String</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\NodeResident.js      
                        </script>
                        <h1 class="file-heading">File:src\components\NodeResident.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                        # COMPONENT **NodeResident**
                        This component connects an entity to its parent&#x27;s [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.
                        
                        ## Dependencies
                        - [[NodeMap]] (on entity&#x27;s parent) - This component uses the &#x60;NodeMap&#x60; to determine its location and navigate to other nodes.
                        - [[HandlerLogic]] (on entity&#x27;s parent) - This component listens for a logic tick message to maintain and update its location.
                        
                        ## Messages
                        
                        ### Listens for:
                        - **handle-logic** - On a &#x60;tick&#x60; logic message, the component updates its location and triggers messages regarding its neighbors.
                          - @param message.delta (Number) - This component uses the current time to determine its progress along an edge if moving from node to node on the map.
                        - **on-node** - Sets the entity&#x27;s position to the sent node, updates its coordinates, and triggers messages regarding its neighbors if any.
                          - @param node (Node) - The node that this entity should be located on.
                        - **leave-node** - Removes the entity from its current node if it&#x27;s on one.
                        - **goto-node** - Begins moving the entity along edges to get to sent node.
                          - @param node (Node) - The node that this entity should move to.
                        - **follow** - Causes this entity to follow another entity. The leading entity must also have a &#x60;NodeResident&#x60; component and exist in the NodeMap.
                          - @param entity (Entity) - The entity that this entity should follow.
                        
                        ### Local Broadcasts:
                        - **next-to-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all neighboring entities, as well as on itself on behalf of neighboring entities.
                          - @param entity (Entity) - The entity that is next to the listening entity.
                        - **with-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all entities residing on the same node, as well as on itself on behalf of all resident entities.
                          - @param entity (Entity) - The entity that is with the listening entity.
                        - **left-node** - Triggered when the entity leaves a node.
                          - @param node (Node) - The node that the entity just left.
                        - **[Messages specified in definition]** - When the entity is placed on a node, it checks out the type of node and triggers a message on the entity if an event is listed for the current node type.
                        
                        ## States
                        - **on-node** - This state is true when the entity is on a node.
                        - **moving** - This state is true when the entity is moving from one node to another.
                        - **going-[direction]** - This state is true when the entity is moving (or has just moved) in a direction (determined by the NodeMap) from one node to another.
                          
                        ## JSON Definition
                            {
                              &quot;type&quot;: &quot;NodeResident&quot;,
                              
                              &quot;nodeId&quot;: &quot;city-hall&quot;,
                              // Optional. The id of the node that this entity should start on. Uses the entity&#x27;s nodeId property if not set here.
                              
                              &quot;nodes&quot;: {&quot;path&quot;: &quot;walking&quot;, &quot;sidewalk&quot;: &quot;walking&quot;, &quot;road&quot;: &quot;driving&quot;],
                              // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.
                              
                              &quot;shares&quot;: [&#x27;friends&#x27;,&#x27;neighbors&#x27;,&#x27;city-council-members&#x27;],
                              // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity can reside with any entities on the same node.
                              
                              &quot;speed&quot;: 5,
                              // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).
                              
                              &quot;updateOrientation&quot;: true
                              // Optional. Determines whether the entity&#x27;s orientation is updated by movement across the NodeMap. Default is false.
                            }
                        */
                        
                        /**
                         * This component connects an entity to its parent&#x27;s [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.
                         *
                         * @namespace platypus.components
                         * @class NodeResident
                         * @uses platypus.Component
                         */
                        /* global platypus */
                        (function () {
                            &#x27;use strict&#x27;;
                            
                            var createGateway = function (nodeDefinition, map, gateway) {
                                    return function () {
                                        // ensure it&#x27;s a node if one is available at this gateway
                                        var node = map.getNode(nodeDefinition);
                        
                                        if (this.isPassable(node)) {
                                            this.destinationNodes.length = 0;
                                            this.destinationNodes.push(node);
                        
                                            if (this.node) {
                                                this.onEdge(node);
                                            } else {
                                                this.distance = 0;
                                            }
                                            this.progress = 0;
                        
                                            this.setState(&#x27;going-&#x27; + gateway);
                                            return true;
                                        }
                        
                                        return false;
                                    };
                                },
                                distance = function (origin, destination) {
                                    var x = destination.x - origin.x,
                                        y = destination.y - origin.y,
                                        z = destination.z - origin.z;
                        
                                    return Math.sqrt(x * x + y * y + z * z);
                                },
                                angle = function (origin, destination, distance, ratio) {
                                    var x = destination.x - origin.x,
                                        y = destination.y - origin.y,
                                        a = 0;
                        
                                    if (origin.rotation &amp;&amp; destination.rotation) {
                                        x = (origin.rotation + 180) % 360;
                                        y = (destination.rotation + 180) % 360;
                                        return (x * (1 - ratio) + y * ratio + 180) % 360;
                                    } else {
                                        if (!distance) {
                                            return a;
                                        }
                        
                                        a = Math.acos(x / distance);
                                        if (y &lt; 0) {
                                            a = (Math.PI * 2) - a;
                                        }
                                        return a * 180 / Math.PI;
                                    }
                                },
                                axisProgress = function (r, o, d, f) {
                                    return o * (1 - r) + d * r + f;
                                },
                                isFriendly = function (entities, kinds) {
                                    var x = 0,
                                        y = 0,
                                        found = false;
                        
                                    if (kinds === null) {
                                        return true;
                                    }
                        
                                    for (x = 0; x &lt; entities.length; x++) {
                                        for (y = 0; y &lt; kinds.length; y++) {
                                            if (entities[x].type === kinds[y]) {
                                                found = true;
                                            }
                                        }
                                        if (!found) {
                                            return false;
                                        } else {
                                            found = false;
                                        }
                                    }
                        
                                    return true;
                                };
                        
                            return platypus.createComponentClass({
                                
                                id: &#x27;NodeResident&#x27;,
                                
                                publicProperties: {
                        
                                    /**
                                     * This describes the rate at which a node resident should progress along an edge to another node. This property is set on the entity itself and can be manipulated in real-time.
                                     *
                                     * @property speed
                                     * @type Number
                                     * @default 0
                                     */
                                    speed: 0
                                },
                                
                                initialize: function (definition) {
                                    var offset = definition.offset || this.owner.nodeOffset || {};
                                    
                                    this.nodeId = this.owner.nodeId = definition.nodeId || this.owner.nodeId;
                                    
                                    this.neighbors = {};
                                    this.friendlyNodes = definition.nodes || null;
                                    this.friendlyEntities = definition.shares || null;
                                    this.snapToNodes = definition.snapToNodes || false;
                                    this.updateOrientation = definition.updateOrientation || false;
                                    this.distance = 0;
                                    this.buffer   = definition.buffer || 0;
                                    this.progress = 0;
                                    this.offset = {
                                        x: offset.x || 0,
                                        y: offset.y || 0,
                                        z: offset.z || 0
                                    };
                                    this.destinationNodes = Array.setUp();
                                    this.algorithm = definition.algorithm || distance;
                                    
                                    this.state = this.owner.state;
                                    this.state.set(&#x27;moving&#x27;, false);
                                    this.state.set(&#x27;on-node&#x27;, false);
                                    this.currentState = &#x27;&#x27;;
                                },
                                
                                events: {
                                    &quot;set-algorithm&quot;: function (algorithm) {
                                        this.algorithm = algorithm || distance;
                                    },
                                    &quot;handle-logic&quot;: function (resp) {
                                        var i = 0,
                                            ratio    = 0,
                                            momentum = 0,
                                            node     = null,
                                            arr = null;
                                        
                                        if (!this.owner.node) {
                                            arr = Array.setUp(this.owner.x, this.owner.y);
                                            this.owner.triggerEvent(&#x27;on-node&#x27;, this.owner.parent.getClosestNode(arr));
                                            arr.recycle();
                                            
                                            /**
                                             * This event is triggered if the entity is placed on the map but not assigned a node. It is moved to the nearest node and &quot;in-location&quot; is triggered.
                                             *
                                             * @event &#x27;in-location&#x27;
                                             * @param entity {platypus.Entity} The entity that is in location.
                                             */
                                            this.owner.triggerEvent(&#x27;in-location&#x27;, this.owner);
                                        }
                        
                                        if (this.followEntity) {
                                            node = this.followEntity.node || this.followEntity;
                                            if (node &amp;&amp; node.isNode &amp;&amp; (node !== this.node)) {
                                                this.lag = 0;
                                                this.state.set(&#x27;moving&#x27;, this.gotoNode());
                                                if (this.followDistance) {
                                                    momentum = this.lag;
                                                }
                                            } else {
                                                this.followEntity = null;
                                            }
                                        } else {
                                            momentum = this.speed * resp.delta;
                                        }
                        
                                        // if goto-node was blocked, try again.
                                        if (this.blocked) {
                                            this.blocked = false;
                                            if (this.goingToNode) {
                                                this.owner.triggerEvent(&#x27;goto-closest-node&#x27;, this.goingToNode);
                                            }
                                        }
                                        
                                        if (this.destinationNodes.length) {
                                            this.state.set(&#x27;moving&#x27;, (this.speed !== 0));
                                            if (this.node) {
                                                this.onEdge(this.destinationNodes[0]);
                                            } else if (!this.lastNode) {
                                                this.owner.triggerEvent(&#x27;on-node&#x27;, this.destinationNodes[0]);
                                                this.destinationNodes.greenSplice(0);
                                                if (!this.destinationNodes.length) {
                                                    this.state.set(&#x27;moving&#x27;, false);
                                                    return;
                                                }
                                            }
                                            
                                            if (this.snapToNodes) {
                                                for (i = 0; i &lt; this.destinationNodes.length; i++) {
                                                    this.owner.triggerEvent(&#x27;on-node&#x27;, this.destinationNodes[i]);
                                                }
                                                this.destinationNodes.length = 0;
                                            } else {
                                                while (this.destinationNodes.length &amp;&amp; momentum) {
                                                    if ((this.progress + momentum) &gt;= this.distance) {
                                                        node = this.destinationNodes[0];
                                                        momentum -= (this.distance - this.progress);
                                                        this.progress = 0;
                                                        this.destinationNodes.greenSplice(0);
                                                        this.owner.triggerEvent(&#x27;on-node&#x27;, node);
                                                        if (this.destinationNodes.length &amp;&amp; momentum) {
                                                            this.onEdge(this.destinationNodes[0]);
                                                        }
                                                    } else {
                                                        this.progress += momentum;
                                                        ratio = this.progress / this.distance;
                                                        this.owner.x = axisProgress(ratio, this.lastNode.x, this.destinationNodes[0].x, this.offset.x);
                                                        this.owner.y = axisProgress(ratio, this.lastNode.y, this.destinationNodes[0].y, this.offset.y);
                                                        this.owner.z = axisProgress(ratio, this.lastNode.z, this.destinationNodes[0].z, this.offset.z);
                                                        if (this.updateOrientation) {
                                                            this.owner.rotation = angle(this.lastNode, this.destinationNodes[0], this.distance, ratio);
                                                        }
                                                        momentum = 0;
                                                    }
                                                }
                                            }
                                        } else {
                                            this.state.set(&#x27;moving&#x27;, false);
                                        }
                                    },
                                    &quot;on-node&quot;: function (node) {
                                        var j = 0,
                                            entities = null;
                                        
                                        this.owner.node = this.node = node; //TODO: not sure if this needs to be accessible outside this component.
                                        this.node.removeFromEdge(this.owner);
                                        if (this.lastNode) {
                                            this.lastNode.removeFromEdge(this.owner);
                                        }
                                        this.node.addToNode(this.owner);
                                        
                                        this.setState(&#x27;on-node&#x27;);
                                        
                                        this.owner.x = this.node.x + this.offset.x;
                                        this.owner.y = this.node.y + this.offset.y;
                                        this.owner.z = this.node.z + this.offset.z;
                                        if (this.updateOrientation &amp;&amp; this.node.rotation) {
                                            this.owner.rotation = this.node.rotation;
                                        }
                                        
                                        //add listeners for directions
                                        this.owner.triggerEvent(&#x27;set-directions&#x27;);
                                        
                                        //trigger mapped messages for node types
                                        if (this.friendlyNodes &amp;&amp; this.friendlyNodes[node.type]) {
                                            this.owner.trigger(this.friendlyNodes[node.type], node);
                                        }
                        
                                        //trigger &quot;with&quot; events
                                        entities = node.contains;
                                        for (j = 0; j &lt; entities.length; j++) {
                                            if (this.owner !== entities[j]) {
                                                entities[j].triggerEvent(&quot;with-&quot; + this.owner.type, this.owner);
                                                this.owner.triggerEvent(&quot;with-&quot; + entities[j].type, entities[j]);
                                            }
                                        }
                                    },
                                    &quot;leave-node&quot;: function () {
                                        if (this.node) {
                                            this.node.removeFromNode(this.owner);
                                            this.owner.triggerEvent(&#x27;left-node&#x27;, this.node);
                                            this.owner.triggerEvent(&#x27;remove-directions&#x27;);
                                        }
                                        this.lastNode = this.node;
                                        this.node = null;
                                    },
                                    &quot;goto-node&quot;: function (node) {
                                        this.gotoNode(node);
                                    },
                                    &quot;follow&quot;: function (entityOrNode) {
                                        if (entityOrNode.entity) {
                                            this.followDistance = entityOrNode.distance;
                                            this.followEntity = entityOrNode.entity;
                                        } else {
                                            this.followDistance = 0;
                                            this.followEntity = entityOrNode;
                                        }
                                    },
                                    &quot;goto-closest-node&quot;: (function () {
                                        var checkList = function (here, list) {
                                                var i = 0;
                        
                                                for (i = 0; i &lt; list.length; i++) {
                                                    if (list[i] === here) {
                                                        return true;
                                                    }
                                                }
                        
                                                return false;
                                            },
                                            checkType = function (here, type) {
                                                return (here.type === type);
                                            },
                                            checkObjectType = function (here, node) {
                                                return (here.type === node.type);
                                            };
                                        
                                        return function (nodesOrNodeType) {
                                            var travResp = null,
                                                depth    = 20, //arbitrary limit
                                                origin   = this.node || this.lastNode,
                                                test     = null,
                                                steps    = nodesOrNodeType.steps || 0,
                                                nodes    = null;
                        
                                            this.goingToNode = nodesOrNodeType;
                                            
                                            if (typeof nodesOrNodeType === &#x27;string&#x27;) {
                                                test = checkType;
                                            } else if (typeof nodesOrNodeType.type === &#x27;string&#x27;) {
                                                test = checkObjectType;
                                            } else {
                                                test = checkList;
                                            }
                                            
                                            if (origin &amp;&amp; nodesOrNodeType &amp;&amp; !test(origin, nodesOrNodeType)) {
                                                nodes = Array.setUp();
                                                travResp = this.traverseNode({
                                                    depth: depth,
                                                    origin: origin,
                                                    position: origin,
                                                    test: test,
                                                    destination: nodesOrNodeType,
                                                    nodes: nodes,
                                                    shortestPath: Infinity,
                                                    distance: 0,
                                                    found: false,
                                                    algorithm: this.algorithm,
                                                    blocked: false
                                                });
                                                
                                                travResp.distance -= this.progress;
                                                
                                                if (travResp.found) {
                                                    //TODO: should probably set this up apart from this containing function
                                                    if (this.followEntity) {
                                                        if (!this.followDistance) {
                                                            this.setPath(travResp, steps);
                                                        } else if ((travResp.distance + (this.followEntity.progress || 0)) &gt; this.followDistance) {
                                                            this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;
                                                            this.setPath(travResp, steps);
                                                        } else {
                                                            this.lag = 0;
                                                        }
                                                    } else {
                                                        this.setPath(travResp, steps);
                                                    }
                                                } else if (travResp.blocked) {
                                                    this.blocked = true;
                                                }
                                                
                                                nodes.recycle();
                                            }
                                        };
                                    }()),
                                    &quot;set-directions&quot;: function () {
                                        var i = &#x27;&#x27;,
                                            j = 0,
                                            entities = null,
                                            node     = this.node,
                                            nextNode = null;
                                        
                                        this.owner.triggerEvent(&#x27;remove-directions&#x27;);
                                        
                                        for (i in node.neighbors) {
                                            if (node.neighbors.hasOwnProperty(i)) {
                                                this.neighbors[i] = createGateway(node.neighbors[i], node.map, i);
                                                this.addEventListener(i, this.neighbors[i]);
                        
                                                //trigger &quot;next-to&quot; events
                                                nextNode = node.map.getNode(node.neighbors[i]);
                                                if (nextNode) {
                                                    entities = nextNode.contains;
                                                    for (j = 0; j &lt; entities.length; j++) {
                                                        entities[j].triggerEvent(&quot;next-to-&quot; + this.owner.type, this.owner);
                                                        this.owner.triggerEvent(&quot;next-to-&quot; + entities[j].type, entities[j]);
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    &quot;remove-directions&quot;: function () {
                                        var i = &#x27;&#x27;;
                                        
                                        for (i in this.neighbors) {
                                            if (this.neighbors.hasOwnProperty(i)) {
                                                this.removeEventListener(i, this.neighbors[i]);
                                                delete this.neighbors[i];
                                            }
                                        }
                                    }
                                },
                                
                                methods: {
                                    gotoNode: (function () {
                                        var test = function (here, there) {
                                            return (here === there);
                                        };
                                        
                                        return function (node) {
                                            var travResp = null,
                                                depth = 20, //arbitrary limit
                                                origin = this.node || this.lastNode,
                                                nodes = null,
                                                moving = false;
                                            
                                            if (!node &amp;&amp; this.followEntity) {
                                                node = this.followEntity.node || this.followEntity.lastNode || this.followEntity;
                                            }
                                            
                                            if (origin &amp;&amp; node &amp;&amp; (this.node !== node)) {
                                                nodes = Array.setUp();
                                                
                                                travResp = this.traverseNode({
                                                    depth: depth,
                                                    origin: origin,
                                                    position: origin,
                                                    test: test,
                                                    destination: node,
                                                    nodes: nodes,
                                                    shortestPath: Infinity,
                                                    distance: 0,
                                                    found: false,
                                                    algorithm: this.algorithm,
                                                    blocked: false
                                                });
                                                
                                                travResp.distance -= this.progress;
                                                
                                                if (travResp.found) {
                                                    //TODO: should probably set this up apart from this containing function
                                                    if (this.followEntity) {
                                                        if (!this.followDistance) {
                                                            this.setPath(travResp);
                                                            moving = true;
                                                        } else if ((travResp.distance + (this.followEntity.progress || 0)) &gt; this.followDistance) {
                                                            this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;
                                                            this.setPath(travResp);
                                                            moving = true;
                                                        } else {
                                                            this.lag = 0;
                                                        }
                                                    } else {
                                                        this.setPath(travResp);
                                                        moving = true;
                                                    }
                                                } else if (travResp.blocked) {
                                                    this.blocked = true;
                                                }
                                                
                                                nodes.recycle();
                                            }
                                            
                                            return moving;
                                        };
                                    }()),
                                    
                                    isPassable: function (node) {
                                        return node &amp;&amp; (this.node !== node) &amp;&amp; (!this.friendlyNodes || (typeof this.friendlyNodes[node.type] !== &#x27;undefined&#x27;)) &amp;&amp; (!node.contains.length || isFriendly(node.contains, this.friendlyEntities));
                                    },
                                    traverseNode: function (record) {
                                        //TODO: may want to make this use A*. Currently node traversal order is arbitrary and essentially searches entire graph, but does clip out paths that are too long.
                                        
                                        var i         = 1,
                                            j         = &#x27;&#x27;,
                                            map       = record.position.map,
                                            neighbors = null,
                                            node      = null,
                                            nodeList  = null,
                                            resp      = null,
                                            algorithm = record.algorithm || distance,
                                            savedResp = {
                                                shortestPath: Infinity,
                                                found: false,
                                                blocked: false
                                            },
                                            blocked   = true,
                                            hasNeighbor = false;
                        
                                        if ((record.depth === 0) || (record.distance &gt; record.shortestPath)) {
                                            // if we&#x27;ve reached our search depth or are following a path longer than our recorded successful distance, bail
                                            return record;
                                        } else if (record.test(record.position, record.destination)) {
                                            // if we&#x27;ve reached our destination, set shortest path information and bail.
                                            record.found = true;
                                            record.shortestPath = record.distance;
                                            return record;
                                        } else {
                                            //Make sure we do not trace an infinite node loop.
                                            nodeList = record.nodes;
                                            for (i = 1; i &lt; nodeList.length - 1; i++) {
                                                if (nodeList[i] === record.position) {
                                                    return record;
                                                }
                                            }
                                                
                                            neighbors = record.position.neighbors;
                                            for (j in neighbors) {
                                                if (neighbors.hasOwnProperty(j)) {
                                                    node = map.getNode(neighbors[j]);
                                                    hasNeighbor = true;
                                                    if (this.isPassable(node)) {
                                                        nodeList = record.nodes.greenSlice();
                                                        nodeList.push(node);
                                                        resp = this.traverseNode({
                                                            depth: record.depth - 1,
                                                            origin: record.origin,
                                                            position: node,
                                                            destination: record.destination,
                                                            test: record.test,
                                                            algorithm: algorithm,
                                                            nodes: nodeList,
                                                            shortestPath: record.shortestPath,
                                                            distance: record.distance + algorithm(record.position, node),
                                                            gateway: record.gateway || j,
                                                            found: false,
                                                            blocked: false
                                                        });
                                                        nodeList.recycle();
                                                        if (resp.found &amp;&amp; (savedResp.shortestPath &gt; resp.shortestPath)) {
                                                            savedResp = resp;
                                                        }
                                                        blocked = false;
                                                    }
                                                }
                                            }
                                            savedResp.blocked = (hasNeighbor &amp;&amp; blocked);
                                            return savedResp;
                                        }
                                    },
                                    setPath: function (resp, steps) {
                                        if (resp.nodes[0] === this.node) {
                                            resp.nodes.greenSplice(0);
                                        }
                                        this.destinationNodes.recycle();
                                        this.destinationNodes = resp.nodes.greenSlice();
                                        if (steps) {
                                            this.destinationNodes.length = Math.min(steps, this.destinationNodes.length);
                                        }
                                    },
                                    setState: function (state) {
                                        if (state === &#x27;on-node&#x27;) {
                                            this.state.set(&#x27;on-node&#x27;, true);
                                        } else {
                                            this.state.set(&#x27;on-node&#x27;, false);
                                            if (this.currentState) {
                                                this.state.set(this.currentState, false);
                                            }
                                            this.currentState = state;
                                            this.state.set(state, true);
                                        }
                                    },
                                    onEdge: function (toNode) {
                                        this.distance = distance(this.node, toNode);
                                        if (this.updateOrientation) {
                                            this.owner.rotation = angle(this.node, toNode, this.distance, this.progress / this.distance);
                                        }
                                        this.node.addToEdge(this.owner);
                                        toNode.addToEdge(this.owner);
                                        this.owner.triggerEvent(&#x27;leave-node&#x27;);
                                    },
                                    destroy: function () {
                                        this.destinationNodes.recycle();
                                        this.state = null;
                                    }
                                }
                            });
                        }());
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
