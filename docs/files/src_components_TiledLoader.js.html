<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/css/yui-cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/x-icon" href="../assets/favicon.ico">
    <script src="../assets/js/yui-source.js"></script>
	<title>platypus v0.11.3 API Documentation : src\components\TiledLoader.js</title>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><a href="https://github.com/PBS-KIDS/Platypus"><img src="..\assets\platypus-title.png" title="platypus"></a></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Documentation for: 0.11.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/platypus.AABB.html">platypus.AABB</a></li>
                                <li><a href="../classes/platypus.ActionState.html">platypus.ActionState</a></li>
                                <li><a href="../classes/platypus.Async.html">platypus.Async</a></li>
                                <li><a href="../classes/platypus.CollisionData.html">platypus.CollisionData</a></li>
                                <li><a href="../classes/platypus.CollisionDataContainer.html">platypus.CollisionDataContainer</a></li>
                                <li><a href="../classes/platypus.CollisionShape.html">platypus.CollisionShape</a></li>
                                <li><a href="../classes/platypus.Component.html">platypus.Component</a></li>
                                <li><a href="../classes/platypus.components.AIChaser.html">platypus.components.AIChaser</a></li>
                                <li><a href="../classes/platypus.components.AIPacer.html">platypus.components.AIPacer</a></li>
                                <li><a href="../classes/platypus.components.AudioSFX.html">platypus.components.AudioSFX</a></li>
                                <li><a href="../classes/platypus.components.AudioVO.html">platypus.components.AudioVO</a></li>
                                <li><a href="../classes/platypus.components.Camera.html">platypus.components.Camera</a></li>
                                <li><a href="../classes/platypus.components.CameraFollowMe.html">platypus.components.CameraFollowMe</a></li>
                                <li><a href="../classes/platypus.components.CollisionBasic.html">platypus.components.CollisionBasic</a></li>
                                <li><a href="../classes/platypus.components.CollisionFilter.html">platypus.components.CollisionFilter</a></li>
                                <li><a href="../classes/platypus.components.CollisionGroup.html">platypus.components.CollisionGroup</a></li>
                                <li><a href="../classes/platypus.components.CollisionTiles.html">platypus.components.CollisionTiles</a></li>
                                <li><a href="../classes/platypus.components.ComponentSwitcher.html">platypus.components.ComponentSwitcher</a></li>
                                <li><a href="../classes/platypus.components.Counter.html">platypus.components.Counter</a></li>
                                <li><a href="../classes/platypus.components.EntityContainer.html">platypus.components.EntityContainer</a></li>
                                <li><a href="../classes/platypus.components.EntityController.html">platypus.components.EntityController</a></li>
                                <li><a href="../classes/platypus.components.EventRender.html">platypus.components.EventRender</a></li>
                                <li><a href="../classes/platypus.components.HandlerCollision.html">platypus.components.HandlerCollision</a></li>
                                <li><a href="../classes/platypus.components.HandlerController.html">platypus.components.HandlerController</a></li>
                                <li><a href="../classes/platypus.components.HandlerLogic.html">platypus.components.HandlerLogic</a></li>
                                <li><a href="../classes/platypus.components.HandlerRender.html">platypus.components.HandlerRender</a></li>
                                <li><a href="../classes/platypus.components.Interactive.html">platypus.components.Interactive</a></li>
                                <li><a href="../classes/platypus.components.LevelBuilder.html">platypus.components.LevelBuilder</a></li>
                                <li><a href="../classes/platypus.components.LogicAngularMovement.html">platypus.components.LogicAngularMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicAttachment.html">platypus.components.LogicAttachment</a></li>
                                <li><a href="../classes/platypus.components.LogicButton.html">platypus.components.LogicButton</a></li>
                                <li><a href="../classes/platypus.components.LogicCarrier.html">platypus.components.LogicCarrier</a></li>
                                <li><a href="../classes/platypus.components.LogicDestroyMe.html">platypus.components.LogicDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.LogicDirectionalMovement.html">platypus.components.LogicDirectionalMovement</a></li>
                                <li><a href="../classes/platypus.components.LogicPortable.html">platypus.components.LogicPortable</a></li>
                                <li><a href="../classes/platypus.components.LogicWindUpRacer.html">platypus.components.LogicWindUpRacer</a></li>
                                <li><a href="../classes/platypus.components.Motion.html">platypus.components.Motion</a></li>
                                <li><a href="../classes/platypus.components.Mover.html">platypus.components.Mover</a></li>
                                <li><a href="../classes/platypus.components.NodeMap.html">platypus.components.NodeMap</a></li>
                                <li><a href="../classes/platypus.components.NodeResident.html">platypus.components.NodeResident</a></li>
                                <li><a href="../classes/platypus.components.Orientation.html">platypus.components.Orientation</a></li>
                                <li><a href="../classes/platypus.components.RandomEvents.html">platypus.components.RandomEvents</a></li>
                                <li><a href="../classes/platypus.components.RelayFamily.html">platypus.components.RelayFamily</a></li>
                                <li><a href="../classes/platypus.components.RelayGame.html">platypus.components.RelayGame</a></li>
                                <li><a href="../classes/platypus.components.RelayLinker.html">platypus.components.RelayLinker</a></li>
                                <li><a href="../classes/platypus.components.RelayParent.html">platypus.components.RelayParent</a></li>
                                <li><a href="../classes/platypus.components.RelaySelf.html">platypus.components.RelaySelf</a></li>
                                <li><a href="../classes/platypus.components.RenderAnimation.html">platypus.components.RenderAnimation</a></li>
                                <li><a href="../classes/platypus.components.RenderContainer.html">platypus.components.RenderContainer</a></li>
                                <li><a href="../classes/platypus.components.RenderDebug.html">platypus.components.RenderDebug</a></li>
                                <li><a href="../classes/platypus.components.RenderDestroyMe.html">platypus.components.RenderDestroyMe</a></li>
                                <li><a href="../classes/platypus.components.RenderProgress.html">platypus.components.RenderProgress</a></li>
                                <li><a href="../classes/platypus.components.RenderSpine.html">platypus.components.RenderSpine</a></li>
                                <li><a href="../classes/platypus.components.RenderSprite.html">platypus.components.RenderSprite</a></li>
                                <li><a href="../classes/platypus.components.RenderTiles.html">platypus.components.RenderTiles</a></li>
                                <li><a href="../classes/platypus.components.SceneChanger.html">platypus.components.SceneChanger</a></li>
                                <li><a href="../classes/platypus.components.StateRender.html">platypus.components.StateRender</a></li>
                                <li><a href="../classes/platypus.components.TiledLoader.html">platypus.components.TiledLoader</a></li>
                                <li><a href="../classes/platypus.components.Timeline.html">platypus.components.Timeline</a></li>
                                <li><a href="../classes/platypus.components.Tutorial.html">platypus.components.Tutorial</a></li>
                                <li><a href="../classes/platypus.components.VoiceOver.html">platypus.components.VoiceOver</a></li>
                                <li><a href="../classes/platypus.components.XHR.html">platypus.components.XHR</a></li>
                                <li><a href="../classes/platypus.Data.html">platypus.Data</a></li>
                                <li><a href="../classes/platypus.DataMap.html">platypus.DataMap</a></li>
                                <li><a href="../classes/platypus.Entity.html">platypus.Entity</a></li>
                                <li><a href="../classes/platypus.Game.html">platypus.Game</a></li>
                                <li><a href="../classes/platypus.Messenger.html">platypus.Messenger</a></li>
                                <li><a href="../classes/platypus.PIXIAnimation.html">platypus.PIXIAnimation</a></li>
                                <li><a href="../classes/platypus.PlatypusPlugin.html">platypus.PlatypusPlugin</a></li>
                                <li><a href="../classes/platypus.Scene.html">platypus.Scene</a></li>
                                <li><a href="../classes/platypus.StateMap.html">platypus.StateMap</a></li>
                                <li><a href="../classes/platypus.Vector.html">platypus.Vector</a></li>
                                <li><a href="../classes/window.Array.html">window.Array</a></li>
                                <li><a href="../classes/window.Map.html">window.Map</a></li>
                                <li><a href="../classes/window.String.html">window.String</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/platypus.html">platypus</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
            <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <script>
                        	var name = src\components\TiledLoader.js      
                        </script>
                        <h1 class="file-heading">File:src\components\TiledLoader.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * This component is attached to a top-level entity (loaded by the [Scene](platypus.Scene.html)) and, once its peer components are loaded, ingests a JSON file exported from the [Tiled map editor](http://www.mapeditor.org/) and creates the tile maps and entities. Once it has finished loading the map, it removes itself from the list of components on the entity.
                         *
                         * This component requires an [EntityContainer](platypus.components.EntityContainer.html) since it calls &#x60;entity.addEntity()&#x60; on the entity, provided by &#x60;EntityContainer&#x60;.
                         *
                         * This component looks for the following entities, and if not found will load default versions:
                        
                                {
                                    &quot;render-layer&quot;: {
                                        &quot;id&quot;: &quot;render-layer&quot;,
                                        &quot;components&quot;:[{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;:    &quot;import&quot;,
                                            &quot;entityCache&quot;: true
                                        }]
                                    },
                                    &quot;collision-layer&quot;: {
                                        &quot;id&quot;: &quot;collision-layer&quot;,
                                        &quot;components&quot;:[{
                                            &quot;type&quot;: &quot;CollisionTiles&quot;,
                                            &quot;collisionMap&quot;: &quot;import&quot;
                                        }]
                                    },
                                    &quot;image-layer&quot;: {
                                        &quot;id&quot;: &quot;image-layer&quot;,
                                        &quot;components&quot;:[{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;:    &quot;import&quot;
                                        }]
                                    }
                                }
                        
                         * @namespace platypus.components
                         * @class TiledLoader
                         * @uses platypus.Component
                         */
                        /*global atob, include, pako, platypus */
                        (function () {
                            &#x27;use strict&#x27;;
                        
                            var AABB        = include(&#x27;platypus.AABB&#x27;),
                                Data        = include(&#x27;platypus.Data&#x27;),
                                Entity      = include(&#x27;platypus.Entity&#x27;),
                                maskId = 0x0fffffff,
                                maskJumpThrough = 0x10000000, // This is not passed in via Tiled - rather it&#x27;s additional information sent to CollisionTiles.
                                maskXFlip = 0x80000000,
                                maskYFlip = 0x40000000,
                                decodeBase64 = (function () {
                                    var decodeString = function (str, index) {
                                            return (((str.charCodeAt(index)) + (str.charCodeAt(index + 1) &lt;&lt; 8) + (str.charCodeAt(index + 2) &lt;&lt; 16) + (str.charCodeAt(index + 3) &lt;&lt; 24 )) &gt;&gt;&gt; 0);
                                        },
                                        decodeArray = function (arr, index) {
                                            return ((arr[index] + (arr[index + 1] &lt;&lt; 8) + (arr[index + 2] &lt;&lt; 16) + (arr[index + 3] &lt;&lt; 24 )) &gt;&gt;&gt; 0);
                                        };
                                    
                                    return function (data, compression) {
                                        var index = 4,
                                            arr   = [],
                                            step1 = atob(data.replace(/\\/g, &#x27;&#x27;));
                                            
                                        if (compression === &#x27;zlib&#x27;) {
                                            step1 = pako.inflate(step1);
                                            while (index &lt;= step1.length) {
                                                arr.push(decodeArray(step1, index - 4));
                                                index += 4;
                                            }
                                        } else {
                                            while (index &lt;= step1.length) {
                                                arr.push(decodeString(step1, index - 4));
                                                index += 4;
                                            }
                                        }
                                        
                                        return arr;
                                    };
                                }()),
                                finishedLoading = function (level, x, y, width, height, tileWidth, tileHeight, callback) {
                                    var message = Data.setUp(
                                            &quot;level&quot;, null,
                                            &quot;world&quot;, AABB.setUp(),
                                            &quot;tile&quot;, AABB.setUp(),
                                            &quot;camera&quot;, null
                                        );
                        
                                    /**
                                     * Once finished loading the map, this message is triggered on the entity to notify other components of completion.
                                     *
                                     * @event &#x27;world-loaded&#x27;
                                     * @param message {platypus.Data} World data.
                                     * @param message.level {Object} The Tiled level data used to load the level.
                                     * @param message.width {number} The width of the world in world units.
                                     * @param message.height {number} The height of the world in world units.
                                     * @param message.tile {platypus.AABB} Dimensions of the world tiles.
                                     * @param message.world {platypus.AABB} Dimensions of the world.
                                     * @param message.camera {platypus.Entity} If a camera property is found on one of the loaded entities, this property will point to the entity on load that a world camera should focus on.
                                     */
                                    message.level = level;
                                    message.camera = this.followEntity; // TODO: in 0.9.0 this should probably be removed, using something like &quot;child-entity-added&quot; instead. Currently this is particular to TiledLoader and Camera and should be generalized. - DDD 3/15/2016
                                    message.width = width;
                                    message.height = height;
                                    message.world.setBounds(x, y, x + width, y + height);
                                    message.tile.setBounds(0, 0, tileWidth, tileHeight);
                                    this.owner.triggerEvent(&#x27;world-loaded&#x27;, message);
                                    message.world.recycle();
                                    message.tile.recycle();
                                    message.recycle();
                                    
                                    this.owner.removeComponent(this);
                        
                                    if (callback) {
                                        callback();
                                    }
                                },
                                getPowerOfTen = function (amount) {
                                    var x = 1;
                        
                                    while (x &lt; amount) {
                                        x *= 10;
                                    }
                        
                                    return x;
                                },
                                transform = {
                                    x: 1,
                                    y: 1,
                                    id: -1
                                },
                                entityTransformCheck = function (v) {
                                    var resp = transform,
                                        b = !!(maskYFlip &amp; v),
                                        c = !!(maskXFlip &amp; v);
                        
                                    resp.id = maskId &amp; v;
                                    resp.x = 1;
                                    resp.y = 1;
                        
                                    if (b) {
                                        resp.y = -1;
                                    }
                                    if (c) {
                                        resp.x = -1;
                                    }
                                    return resp;
                                },
                                getEntityData = function (obj, tilesets) {
                                    var x = 0,
                                        gid = obj.gid || -1,
                                        properties = {},
                                        data = {
                                            gid: -1,
                                            transform: null,
                                            properties: properties,
                                            type: &#x27;&#x27;
                                        },
                                        props = null,
                                        tileset = null,
                                        entityTilesetIndex = 0;
                                    
                                    if (gid !== -1) {
                                        data.transform = entityTransformCheck(gid);
                                        gid = data.gid = transform.id;
                                    }
                                    
                                    for (x = 0; x &lt; tilesets.length; x++) {
                                        if (tilesets[x].firstgid &gt; gid) {
                                            break;
                                        } else {
                                            tileset = tilesets[x];
                                        }
                                    }
                                    
                                    if (tileset) {
                                        entityTilesetIndex = gid - tileset.firstgid;
                                        if (tileset.tileproperties &amp;&amp; tileset.tileproperties[entityTilesetIndex]) {
                                            props = tileset.tileproperties[entityTilesetIndex];
                                        }
                                        if (tileset.tiles &amp;&amp; tileset.tiles[entityTilesetIndex]) {
                                            data.type = tileset.tiles[entityTilesetIndex].type || &#x27;&#x27;;
                                        }
                                    }
                        
                                    // Check Tiled data to find this object&#x27;s type
                                    data.type = obj.type || data.type;
                                    // Deprecating the following methods in v0.11 due to better &quot;type&quot; property support in Tiled 1.0.0
                                    if (data.type === &#x27;&#x27;) {
                                        if (obj.name) {
                                            data.type = obj.name;
                                            platypus.debug.warn(&#x27;Component TiledLoader (loading &quot;&#x27; + data.type + &#x27;&quot;): Defining the entity type using the &quot;name&quot; property has been deprecated. Define the type using the object\&#x27;s &quot;type&quot; property in Tiled instead.&#x27;);
                                        } else if (props) {
                                            if (props.entity) {
                                                data.type = props.entity;
                                                platypus.debug.warn(&#x27;Component TiledLoader (loading &quot;&#x27; + data.type + &#x27;&quot;): Defining the entity type using the &quot;entity&quot; property in the object properties has been deprecated. Define the type using the object\&#x27;s &quot;type&quot; property in Tiled instead.&#x27;);
                                            } else if (props.type) {
                                                data.type = props.type;
                                                platypus.debug.warn(&#x27;Component TiledLoader (loading &quot;&#x27; + data.type + &#x27;&quot;): Defining the entity type in the object properties has been deprecated. Define the type using the object\&#x27;s &quot;type&quot; property in Tiled instead.&#x27;);
                                            }
                                        }
                                    }
                        
                                    if (!data.type) { // undefined entity
                                        return null;
                                    }
                                    
                                    //Copy properties from Tiled
                                    if (data.transform) {
                                        properties.scaleX = data.transform.x;
                                        properties.scaleY = data.transform.y;
                                    } else {
                                        properties.scaleX = 1;
                                        properties.scaleY = 1;
                                    }
                                    
                                    mergeAndFormatProperties(props, data.properties);
                                    mergeAndFormatProperties(obj.properties, data.properties);
                                    
                                    return data;
                                },
                                mergeAndFormatProperties = function (src, dest) {
                                    var key = &#x27;&#x27;;
                                    
                                    if (src &amp;&amp; dest) {
                                        for (key in src) {
                                            if (src.hasOwnProperty(key)) {
                                                dest[key] = formatProperty(src[key]);
                                            }
                                        }
                                    }
                                    
                                    return dest;
                                },
                                formatProperty = function (value) {
                                    var numberProperty = 0;
                                    
                                    if (typeof value === &#x27;string&#x27;) {
                                        //This is going to assume that if you pass in something that starts with a number, it is a number and converts it to one.
                                        numberProperty = parseFloat(value);
                                        if (numberProperty === 0 || (!!numberProperty)) {
                                            return numberProperty;
                                        } else if (value === &#x27;true&#x27;) {
                                            return true;
                                        } else if (value === &#x27;false&#x27;) {
                                            return false;
                                        } else if ((value.length &gt; 1) &amp;&amp; (((value[0] === &#x27;{&#x27;) &amp;&amp; (value[value.length - 1] === &#x27;}&#x27;)) || ((value[0] === &#x27;[&#x27;) &amp;&amp; (value[value.length - 1] === &#x27;]&#x27;)))) {
                                            try {
                                                return JSON.parse(value);
                                            } catch (e) {
                                            }
                                        }
                                    }
                        
                                    return value;
                                },
                                checkLevel = function (level, ss) {
                                    var i = 0,
                                        j = 0,
                                        tilesets = Array.setUp(),
                                        arr = null,
                                        assets = Array.setUp(),
                                        data = null,
                                        entity = null,
                                        entityAssets = null;
                        
                                    if (typeof level === &#x27;string&#x27;) {
                                        level = platypus.game.settings.levels[level];
                                    }
                        
                                    if (level) {
                                        level.tilesets = importTilesetData(level.tilesets);
                        
                                        if (level.assets) { // Property added by a previous parse (so that this algorithm isn&#x27;t run on the same level multiple times)
                                            assets.union(level.assets);
                                        } else {
                                            for (i = 0; i &lt; level.layers.length; i++) {
                                                if (level.layers[i].type === &#x27;objectgroup&#x27;) {
                                                    for (j = 0; j &lt; level.layers[i].objects.length; j++) {
                                                        entity = getEntityData(level.layers[i].objects[j], level.tilesets);
                                                        if (entity) {
                                                            entityAssets = Entity.getAssetList(entity);
                                                            assets.union(entityAssets);
                                                            entityAssets.recycle();
                                                        }
                                                    }
                                                } else if (level.layers[i].type === &#x27;imagelayer&#x27;) {
                                                    assets.union([level.layers[i].image]);
                                                } else if (level.layers[i].properties &amp;&amp; level.layers[i].properties.entity) {
                                                    data = Data.setUp(&#x27;type&#x27;, level.layers[i].properties.entity);
                                                    arr = Entity.getAssetList(data);
                                                    assets.union(arr);
                                                    arr.recycle();
                                                    data.recycle();
                                                }
                                            }
                                            if (!ss) { //We need to load the tileset images since there is not a separate spriteSheet describing them
                                                for (i = 0; i &lt; level.tilesets.length; i++) {
                                                    tilesets.push(level.tilesets[i].image);
                                                }
                                                assets.union(tilesets);
                                                tilesets.recycle();
                                            }
                                            level.assets = assets.greenSlice(); // Save for later in case this level is checked again.
                                        }
                                    }
                                    
                                    return assets;
                                },
                                // These are provided but can be overwritten by entities of the same name in the configuration.
                                standardEntityLayers = {
                                    &quot;render-layer&quot;: {
                                        &quot;id&quot;: &quot;render-layer&quot;,
                                        &quot;components&quot;: [{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;: &quot;import&quot;,
                                            &quot;entityCache&quot;: true
                                        }]
                                    },
                                    &quot;collision-layer&quot;: {
                                        &quot;id&quot;: &quot;collision-layer&quot;,
                                        &quot;components&quot;: [{
                                            &quot;type&quot;: &quot;CollisionTiles&quot;,
                                            &quot;collisionMap&quot;: &quot;import&quot;
                                        }]
                                    },
                                    &quot;image-layer&quot;: {
                                        &quot;id&quot;: &quot;image-layer&quot;,
                                        &quot;components&quot;: [{
                                            &quot;type&quot;: &quot;RenderTiles&quot;,
                                            &quot;spriteSheet&quot;: &quot;import&quot;,
                                            &quot;imageMap&quot;: &quot;import&quot;
                                        }]
                                    }
                                },
                                importTileset = function (tileset) {
                                    var key = &#x27;&#x27;,
                                        source = platypus.game.settings.levels[tileset.source.replace(&#x27;.json&#x27;, &#x27;&#x27;)];
                                    
                                    for (key in source) {
                                        if (source.hasOwnProperty(key)) {
                                            tileset[key] = source[key];
                                        }
                                    }
                                    
                                    delete tileset.source; // We remove this so we never have to rerun this import. Note that we can&#x27;t simply replace the tileset properties since the tileset&#x27;s firstgid property may change from level to level.
                                    
                                    return tileset;
                                },
                                importTilesetData = function (tilesets) {
                                    var i = 0;
                                    
                                    for (i = 0; i &lt; tilesets.length; i++) {
                                        if (tilesets[i].source) {
                                            tilesets[i] = importTileset(tilesets[i]);
                                        }
                                    }
                                    
                                    return tilesets;
                                };
                        
                            return platypus.createComponentClass({
                                id: &#x27;TiledLoader&#x27;,
                        
                                properties: {
                                    /**
                                     * This causes the entire map to be offset automatically by an order of magnitude higher than the height and width of the world so that the number of digits below zero is constant throughout the world space. This fixes potential floating point issues when, for example, 97 is added to 928.0000000000001 giving 1025 since a significant digit was lost when going into the thousands.
                                     *
                                     * @property offsetMap
                                     * @type Boolean
                                     * @default false
                                     * @since 0.7.5
                                     */
                                    offsetMap: false,
                                    
                                    /**
                                     * If set to &#x60;true&#x60; and if the game is running in debug mode, this causes the collision layer to appear.
                                     *
                                     * @property showCollisionTiles
                                     * @type Boolean
                                     * @default false
                                     */
                                    showCollisionTiles: false,
                        
                                    /**
                                     * If specified, the referenced images are used as the game sprite sheets instead of the images referenced in the Tiled map. This is useful for using different or better quality art from the art used in creating the Tiled map.
                                     *
                                     * @property images
                                     * @type Array
                                     * @default null
                                     */
                                    images: null,
                        
                                    /**
                                     * Adds a number to each additional Tiled layer&#x27;s z coordinate to maintain z-order. Defaults to 1000.
                                     *
                                     * @property layerIncrement
                                     * @type number
                                     * @default 1000
                                     */
                                    layerIncrement: 1000,
                        
                                    /**
                                     * Keeps the tile maps in separate render layers. Default is &#x27;false&#x27; to for better optimization.
                                     *
                                     * @property separateTiles
                                     * @type boolean
                                     * @default false
                                     */
                                    separateTiles: false,
                                    
                                    /**
                                     * If a particular sprite sheet should be used that&#x27;s not defined by the level images themselves. This is useful for making uniquely-themed variations of the same level. This is overridden by &#x60;&quot;spriteSheet&quot;: &quot;import&quot;&#x60; in the &quot;render-layer&quot; Entity definition, so be sure to remove that when setting this property.
                                     *
                                     * @property spriteSheet
                                     * @type String | Object
                                     * @default null
                                     * @since 0.6.6
                                     */
                                    spriteSheet: null
                                },
                        
                                publicProperties: {
                                    /**
                                     * Specifies the JSON level to load. Available on the entity as &#x60;entity.level&#x60;.
                                     *
                                     * @property level
                                     * @type String
                                     * @default null
                                     */
                                    level: null,
                        
                                    /**
                                     * Sets how many world units in width and height correspond to a single pixel in the Tiled map. Default is 1: One pixel is one world unit. Available on the entity as &#x60;entity.unitsPerPixel&#x60;.
                                     *
                                     * @property unitsPerPixel
                                     * @type number
                                     * @default 1
                                     */
                                    unitsPerPixel: 1,
                        
                                    /**
                                     * If images are provided, this property sets the scale of the art relative to world coordinates. Available on the entity as &#x60;entity.imagesScale&#x60;.
                                     *
                                     * @property imagesScale
                                     * @type number
                                     * @default 1
                                     */
                                    imagesScale: 1,
                        
                                    /**
                                     * Can be &quot;left&quot;, &quot;right&quot;, or &quot;center&quot;. Defines where entities registered X position should be when spawned. Available on the entity as &#x60;entity.entityPositionX&#x60;.
                                     *
                                     * @property entityPositionX
                                     * @type String
                                     * @default &quot;center&quot;
                                     */
                                    entityPositionX: &quot;center&quot;,
                        
                                    /**
                                     * Can be &quot;top&quot;, &quot;bottom&quot;, or &quot;center&quot;. Defines where entities registered Y position should be when spawned. Available on the entity as &#x60;entity.entityPositionY&#x60;.
                                     *
                                     * @property entityPositionY
                                     * @type String
                                     * @default &quot;bottom&quot;
                                     */
                                    entityPositionY: &quot;bottom&quot;,
                        
                                    /**
                                     * Whether to wait for a &quot;load-level&quot; event before before loading. Available on the entity as &#x60;entity.manuallyLoad&#x60;.
                                     *
                                     * @property manuallyLoad
                                     * @type boolean
                                     * @default false
                                     */
                                    manuallyLoad: false
                                },
                        
                                initialize: function () {
                                    this.assetCache = platypus.game.app.assetManager.cache;
                                    this.layerZ = 0;
                                    this.followEntity = false;
                                },
                        
                                events: {
                        
                                    /**
                                     * On receiving this message, the component commences loading the Tiled map JSON definition. Once finished, it removes itself from the entity&#x27;s list of components.
                                     *
                                     * @method &#x27;scene-loaded&#x27;
                                     * @param persistentData {Object} Data passed from the last scene into this one.
                                     * @param persistentData.level {Object} A level name or definition to load if the level is not already specified.
                                     * @param holds {platypus.Data} An object that handles any holds on before making the scene live.
                                     * @param holds.count {Number} The number of holds to wait for before triggering &quot;scene-live&quot;
                                     * @param holds.release {Function} The method to trigger to let the scene loader know that one hold has been released.
                                     */
                                    &quot;scene-loaded&quot;: function (persistentData, holds) {
                                        if (!this.manuallyLoad) {
                                            holds.count += 1;
                                            this.loadLevel({
                                                level: this.level || persistentData.level,
                                                persistentData: persistentData
                                            }, holds.release);
                                        }
                                    },
                        
                                    /**
                                     * If &#x60;manuallyLoad&#x60; is set, the component will wait for this message before loading the Tiled map JSON definition.
                                     *
                                     * @method &#x27;load-level&#x27;
                                     * @param levelData {Object}
                                     * @param levelData.level {String|Object} The level to load.
                                     * @param [levelData.persistentData] {Object} Information passed from the last scene.
                                     * @param callback {Function} The function to call once the level is loaded.
                                     */
                                    &quot;load-level&quot;: function (levelData, callback) {
                                        this.loadLevel(levelData, callback);
                                    }
                                },
                        
                                methods: {
                                    createLayer: function (entityKind, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress) {
                                        var props = null,
                                            width = layer.width,
                                            height = layer.height,
                                            tHeight = layer.tileheight || tileHeight,
                                            tWidth = layer.tilewidth || tileWidth,
                                            newWidth = 0,
                                            newHeight = 0,
                                            tileTypes = 0,
                                            tileDefinition = JSON.parse(JSON.stringify(platypus.game.settings.entities[entityKind] || standardEntityLayers[entityKind])), //TODO: a bit of a hack to copy an object instead of overwrite values
                                            importAnimation = null,
                                            importCollision = null,
                                            importRender = null,
                                            renderTiles = false,
                                            tileset = null,
                                            jumpthroughs = null,
                                            index = 0,
                                            x = 0,
                                            y = 0,
                                            prop = &quot;&quot;,
                                            data = null;
                                        
                                        this.decodeLayer(layer);
                                        data = layer.data;
                                        
                                        tileDefinition.properties = tileDefinition.properties || {};
                        
                                        //This builds in parallaxing support by allowing the addition of width and height properties into Tiled layers so they pan at a separate rate than other layers.
                                        if (layer.properties) {
                                            if (layer.properties.width) {
                                                newWidth  = parseInt(layer.properties.width,  10);
                                            }
                                            if (layer.properties.height) {
                                                newHeight = parseInt(layer.properties.height, 10);
                                            }
                                            if (newWidth || newHeight) {
                                                newWidth  = newWidth  || width;
                                                newHeight = newHeight || height;
                                                data      = [];
                                                for (x = 0; x &lt; newWidth; x++) {
                                                    for (y = 0; y &lt; newHeight; y++) {
                                                        if ((x &lt; width) &amp;&amp; (y &lt; height)) {
                                                            data[x + y * newWidth] = layer.data[x + y * width];
                                                        } else {
                                                            data[x + y * newWidth] = 0;
                                                        }
                                                    }
                                                }
                                                width  = newWidth;
                                                height = newHeight;
                                            }
                                            
                                            mergeAndFormatProperties(layer.properties, tileDefinition.properties);
                                        }
                        
                                        importAnimation = {};
                                        importCollision = [];
                                        importRender = [];
                        
                                        if (entityKind === &#x27;collision-layer&#x27;) {
                                            jumpthroughs = [];
                                            for (x = 0; x &lt; tilesets.length; x++) {
                                                tileset = tilesets[x];
                                                if (tileset.tileproperties) {
                                                    for (prop in tileset.tileproperties) {
                                                        if (tileset.tileproperties.hasOwnProperty(prop)) {
                                                            if (tileset.tileproperties[prop].jumpThrough) {
                                                                jumpthroughs.push(tileset.firstgid + parseInt(prop, 10));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        
                                        tileDefinition.properties.width = tWidth * width * this.unitsPerPixel;
                                        tileDefinition.properties.height = tHeight * height * this.unitsPerPixel;
                                        tileDefinition.properties.columns = width;
                                        tileDefinition.properties.rows = height;
                                        tileDefinition.properties.tileWidth = tWidth * this.unitsPerPixel;
                                        tileDefinition.properties.tileHeight = tHeight * this.unitsPerPixel;
                                        tileDefinition.properties.scaleX = this.imagesScale;
                                        tileDefinition.properties.scaleY = this.imagesScale;
                                        tileDefinition.properties.layerZ = this.layerZ;
                                        tileDefinition.properties.left = tileDefinition.properties.x || mapOffsetX;
                                        tileDefinition.properties.top = tileDefinition.properties.y || mapOffsetY;
                                        tileDefinition.properties.z = tileDefinition.properties.z || this.layerZ;
                        
                                        if (tilesets.length) {
                                            tileTypes = (tilesets[tilesets.length - 1].imagewidth / tWidth) * (tilesets[tilesets.length - 1].imageheight / tHeight) + tilesets[tilesets.length - 1].firstgid;
                                            for (x = -1; x &lt; tileTypes; x++) {
                                                importAnimation[&#x27;tile&#x27; + x] = x;
                                            }
                                        }
                                        for (x = 0; x &lt; width; x++) {
                                            importCollision[x] = [];
                                            importRender[x] = [];
                                            for (y = 0; y &lt; height; y++) {
                                                index = +data[x + y * width] - 1; // -1 from original src to make it zero-based.
                                                importRender[x][y] = &#x27;tile&#x27; + index;
                                                index += 1; // So collision map matches original src indexes. Render (above) should probably be changed at some point as well. DDD 3/30/2016
                                                if (jumpthroughs &amp;&amp; jumpthroughs.length &amp;&amp; (jumpthroughs[0] === (maskId &amp; index))) {
                                                    index = maskJumpThrough | index;
                                                }
                                                importCollision[x][y] = index;
                                            }
                                        }
                                        for (x = 0; x &lt; tileDefinition.components.length; x++) {
                                            if (tileDefinition.components[x].type === &#x27;RenderTiles&#x27;) {
                                                renderTiles = tileDefinition.components[x];
                                            }
                                            if (tileDefinition.components[x].spriteSheet === &#x27;import&#x27;) {
                                                tileDefinition.components[x].spriteSheet = {
                                                    images: (layer.image ? [layer.image] : images),
                                                    frames: {
                                                        width: tWidth * this.unitsPerPixel / this.imagesScale,
                                                        height: tHeight * this.unitsPerPixel / this.imagesScale,
                                                        regX: (tWidth * this.unitsPerPixel / this.imagesScale) / 2,
                                                        regY: (tHeight * this.unitsPerPixel / this.imagesScale) / 2
                                                    },
                                                    animations: importAnimation
                                                };
                                            } else if (tileDefinition.components[x].spriteSheet) {
                                                if (typeof tileDefinition.components[x].spriteSheet === &#x27;string&#x27; &amp;&amp; platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet]) {
                                                    tileDefinition.components[x].spriteSheet = platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet];
                                                }
                                                if (!tileDefinition.components[x].spriteSheet.animations) {
                                                    tileDefinition.components[x].spriteSheet.animations = importAnimation;
                                                }
                                            }
                                            if (tileDefinition.components[x].collisionMap === &#x27;import&#x27;) {
                                                tileDefinition.components[x].collisionMap = importCollision;
                                            }
                                            if (tileDefinition.components[x].imageMap === &#x27;import&#x27;) {
                                                tileDefinition.components[x].imageMap = importRender;
                                            }
                                        }
                                        this.layerZ += this.layerIncrement;
                        
                                        if ((entityKind === &#x27;render-layer&#x27;) &amp;&amp; (!this.separateTiles) &amp;&amp; combineRenderLayer &amp;&amp; (combineRenderLayer.tileHeight === tHeight) &amp;&amp; (combineRenderLayer.tileWidth === tWidth) &amp;&amp; (combineRenderLayer.columns === width) &amp;&amp; (combineRenderLayer.rows === height)) {
                                            combineRenderLayer.triggerEvent(&#x27;add-tiles&#x27;, renderTiles);
                                            this.updateLoadingProgress(progress);
                                            return combineRenderLayer;
                                        } else {
                                            props = {};
                                            if ((entityKind === &#x27;render-layer&#x27;) &amp;&amp; this.spriteSheet) {
                                                if (typeof this.spriteSheet === &#x27;string&#x27;) {
                                                    props.spriteSheet = platypus.game.settings.spriteSheets[this.spriteSheet];
                                                } else {
                                                    props.spriteSheet = this.spriteSheet;
                                                }
                                                if (!props.spriteSheet.animations) {
                                                    props.spriteSheet.animations = importAnimation;
                                                }
                                            }
                                            return this.owner.addEntity(new Entity(tileDefinition, {
                                                properties: props
                                            }, this.updateLoadingProgress.bind(this, progress)));
                                        }
                                    },
                                    
                                    convertImageLayer: function (imageLayer, tileHeight, tileWidth) {
                                        var i = 0,
                                            dataCells = 0,
                                            props = imageLayer.properties || {},
                                            tileLayer = {
                                                data: [],
                                                image: &#x27;&#x27;,
                                                height: 1,
                                                name: imageLayer.name,
                                                type: &#x27;tilelayer&#x27;,
                                                width: 1,
                                                tileheight: tileHeight,
                                                tilewidth: tileWidth,
                                                x: imageLayer.x,
                                                y: imageLayer.y,
                                                properties: props
                                            };
                        
                                        if (props.repeat) {
                                            tileLayer.width = +props.repeat;
                                            tileLayer.height = +props.repeat;
                                        }
                                        if (props[&#x27;repeat-x&#x27;]) {
                                            tileLayer.width = +props[&#x27;repeat-x&#x27;];
                                        }
                                        if (props[&#x27;repeat-y&#x27;]) {
                                            tileLayer.height = +props[&#x27;repeat-y&#x27;];
                                        }
                                        dataCells = tileLayer.width * tileLayer.height;
                                        for (i = 0; i &lt; dataCells; i++) {
                                            tileLayer.data.push(1);
                                        }
                        
                                        // Prefer to have name in tiled match image id in game
                                        if (this.assetCache.read(imageLayer.name)) {
                                            tileLayer.image = imageLayer.name;
                                            tileLayer.tileheight = this.assetCache.read(imageLayer.name).height;
                                            tileLayer.tilewidth = this.assetCache.read(imageLayer.name).width;
                                        } else {
                                            platypus.debug.warn(&#x27;Component TiledLoader: Cannot find the &quot;&#x27; + imageLayer.name + &#x27;&quot; sprite sheet. Add it to the list of assets in config.json and give it the id &quot;&#x27; + imageLayer.name + &#x27;&quot;.&#x27;);
                                            tileLayer.image = imageLayer.image;
                                        }
                        
                                        return tileLayer;
                                    },
                                    
                                    loadLevel: function (levelData, callback) {
                                        var actionLayerCollides = true,
                                            layers = null,
                                            level = null,
                                            height = 0,
                                            i = 0,
                                            images = null,
                                            layer = null,
                                            layerDefinition = null,
                                            tilesets = null,
                                            tileWidth = 0,
                                            tileHeight = 0,
                                            progress = Data.setUp(&#x27;count&#x27;, 0, &#x27;progress&#x27;, 0, &#x27;total&#x27;, 0),
                                            width = 0,
                                            x = 0,
                                            y = 0;
                                        
                                        //format level appropriately
                                        if (typeof levelData.level === &#x27;string&#x27;) {
                                            level = platypus.game.settings.levels[levelData.level];
                                        } else {
                                            level = levelData.level;
                                        }
                                        layers = level.layers;
                                        tilesets = importTilesetData(level.tilesets);
                                        tileWidth = level.tilewidth;
                                        tileHeight = level.tileheight;
                        
                                        if (level.properties) {
                                            mergeAndFormatProperties(level.properties, this.owner);
                                        }
                                        
                                        if (this.images) {
                                            images = this.images.greenSlice();
                                        } else {
                                            images = Array.setUp();
                                        }
                                        if (images.length === 0) {
                                            for (i = 0; i &lt; tilesets.length; i++) {
                                                if (this.assetCache.read(tilesets[i].name)) { // Prefer to have name in tiled match image id in game
                                                    images.push(tilesets[i].name);
                                                } else {
                                                    platypus.debug.warn(&#x27;Component TiledLoader: Cannot find the &quot;&#x27; + tilesets[x].name + &#x27;&quot; sprite sheet. Add it to the list of assets in config.json and give it the id &quot;&#x27; + tilesets[x].name + &#x27;&quot;.&#x27;);
                                                    images.push(tilesets[i].image);
                                                }
                                            }
                                        }
                                        
                                        width = level.width * tileWidth * this.unitsPerPixel;
                                        height = level.height * tileHeight * this.unitsPerPixel;
                        
                                        if (this.offsetMap) {
                                            x = getPowerOfTen(width);
                                            y = getPowerOfTen(height);
                                        }
                        
                                        progress.total = i = layers.length;
                                        while (i--) { // Prepatory pass through layers.
                                            if (layers[i].type === &#x27;objectgroup&#x27;) {
                                                progress.total += layers[i].objects.length;
                                            } else if (actionLayerCollides &amp;&amp; ((layers[i].name === &#x27;collision&#x27;) || (layers[i].properties &amp;&amp; layers[i].properties.entity === &#x27;collision-layer&#x27;))) {
                                                actionLayerCollides = false;
                                            }
                                        }
                        
                                        this.finishedLoading = finishedLoading.bind(this, level, x, y, width, height, tileWidth, tileHeight, callback);
                        
                                        for (i = 0; i &lt; layers.length; i++) {
                                            layerDefinition = layers[i];
                                            switch (layerDefinition.type) {
                                            case &#x27;imagelayer&#x27;:
                                                layer = this.createLayer(&#x27;image-layer&#x27;, this.convertImageLayer(layerDefinition, tileHeight, tileWidth), x, y, tileWidth, tileHeight, tilesets, images, layer, progress);
                                                break;
                                            case &#x27;objectgroup&#x27;:
                                                this.setUpEntities(layerDefinition, x, y, tileWidth, tileHeight, tilesets, progress);
                                                layer = null;
                                                this.updateLoadingProgress(progress);
                                                break;
                                            case &#x27;tilelayer&#x27;:
                                                layer = this.setupLayer(layerDefinition, actionLayerCollides, layer, x, y, tileWidth, tileHeight, tilesets, images, progress);
                                                break;
                                            default:
                                                platypus.debug.warn(&#x27;Component TiledLoader: Platypus does not support Tiled layers of type &quot;&#x27; + layerDefinition.type + &#x27;&quot;. This layer will not be loaded.&#x27;);
                                                this.updateLoadingProgress(progress);
                                            }
                                        }
                                    },
                                    
                                    setUpEntities: function (layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, progress) {
                                        var clamp = 1000,
                                            widthOffset = 0,
                                            heightOffset = 0,
                                            x = 0,
                                            p = 0,
                                            w = 0,
                                            h = 0,
                                            a = 0,
                                            v = null,
                                            obj = 0,
                                            entity = null,
                                            entityDefinition = null,
                                            entityDefProps = null,
                                            entityPositionX = &quot;&quot;,
                                            entityPositionY = &quot;&quot;,
                                            entityType = &#x27;&#x27;,
                                            gid = -1,
                                            smallestX = Infinity,
                                            largestX = -Infinity,
                                            smallestY = Infinity,
                                            largestY = -Infinity,
                                            entityData = null,
                                            properties = null,
                                            polyPoints = null,
                                            fallbackWidth = 0,
                                            fallbackHeight = 0;
                        
                                        entityPositionX = this.entityPositionX;
                                        entityPositionY = this.entityPositionY;
                        
                                        if (layer.properties) {
                                            if (layer.properties.entityPositionX) {
                                                entityPositionX = layer.properties.entityPositionX;
                                            }
                                            if (layer.properties.entityPositionY) {
                                                entityPositionY = layer.properties.entityPositionY;
                                            }
                                        }
                        
                                        for (obj = 0; obj &lt; layer.objects.length; obj++) {
                                            entity     = layer.objects[obj];
                                            entityData = getEntityData(entity, tilesets);
                                            if (entityData) {
                                                gid = entityData.gid;
                                                entityType = entityData.type;
                                                entityDefinition = platypus.game.settings.entities[entityType];
                                                if (entityDefinition) {
                                                    entityDefProps = entityDefinition.properties || null;
                                                } else {
                                                    entityDefProps = null;
                                                }
                                                properties = entityData.properties;
                        
                                                if (entity.polygon || entity.polyline) {
                                                    //Figuring out the width of the polygon and shifting the origin so it&#x27;s in the top-left.
                                                    smallestX = Infinity;
                                                    largestX = -Infinity;
                                                    smallestY = Infinity;
                                                    largestY = -Infinity;
                        
                                                    polyPoints = null;
                                                    if (entity.polygon) {
                                                        polyPoints = entity.polygon;
                                                    } else if (entity.polyline) {
                                                        polyPoints = entity.polyline;
                                                    }
                        
                                                    for (x = 0; x &lt; polyPoints.length; x++) {
                                                        if (polyPoints[x].x &gt; largestX) {
                                                            largestX = polyPoints[x].x;
                                                        }
                                                        if (polyPoints[x].x &lt; smallestX) {
                                                            smallestX = polyPoints[x].x;
                                                        }
                                                        if (polyPoints[x].y &gt; largestY) {
                                                            largestY = polyPoints[x].y;
                                                        }
                                                        if (polyPoints[x].y &lt; smallestY) {
                                                            smallestY = polyPoints[x].y;
                                                        }
                                                    }
                                                    properties.width = largestX - smallestX;
                                                    properties.height = largestY - smallestY;
                                                    properties.x = entity.x + smallestX;
                                                    properties.y = entity.y + smallestY;
                        
                                                    widthOffset = 0;
                                                    heightOffset = 0;
                                                    properties.width = properties.width * this.unitsPerPixel;
                                                    properties.height = properties.height * this.unitsPerPixel;
                        
                                                    properties.x = properties.x * this.unitsPerPixel + mapOffsetX;
                                                    properties.y = properties.y * this.unitsPerPixel + mapOffsetY;
                        
                                                    if (entity.polygon) {
                                                        properties.shape = {};
                                                        properties.shape.type = &#x27;polygon&#x27;;
                                                        properties.shape.points = [];
                                                        for (p = 0; p &lt; polyPoints.length; p++) {
                                                            properties.shape.points.push({
                                                                &quot;x&quot;: ((polyPoints[p].x - smallestX) * this.unitsPerPixel + mapOffsetX),
                                                                &quot;y&quot;: ((polyPoints[p].y - smallestY) * this.unitsPerPixel + mapOffsetY)
                                                            });
                                                        }
                                                    } else if (entity.polyline) {
                                                        properties.shape = {};
                                                        properties.shape.type = &#x27;polyline&#x27;;
                                                        properties.shape.points = [];
                                                        for (p = 0; p &lt; polyPoints.length; p++) {
                                                            properties.shape.points.push({
                                                                &quot;x&quot;: ((polyPoints[p].x - smallestX) * this.unitsPerPixel + mapOffsetX),
                                                                &quot;y&quot;: ((polyPoints[p].y - smallestY) * this.unitsPerPixel + mapOffsetY)
                                                            });
                                                        }
                                                    }
                                                } else {
                                                    fallbackWidth = tileWidth * this.unitsPerPixel;
                                                    fallbackHeight = tileHeight * this.unitsPerPixel;
                                                    widthOffset = 0;
                                                    heightOffset = 0;
                                                    properties.width = (entity.width || 0) * this.unitsPerPixel;
                                                    properties.height = (entity.height || 0) * this.unitsPerPixel;
                        
                                                    if (entityDefProps) {
                                                        if (typeof entityDefProps.width === &#x27;number&#x27;) {
                                                            properties.width = entityDefProps.width;
                                                            widthOffset = fallbackWidth;
                                                        }
                                                        if (typeof entityDefProps.height === &#x27;number&#x27;) {
                                                            properties.height = entityDefProps.height;
                                                            heightOffset = fallbackHeight;
                                                        }
                                                    }
                        
                                                    if (!properties.width) {
                                                        properties.width = fallbackWidth;
                                                    }
                                                    if (!properties.height) {
                                                        properties.height = fallbackHeight;
                                                    }
                                                    widthOffset = widthOffset || properties.width;
                                                    heightOffset = heightOffset || properties.height;
                        
                                                    properties.x = entity.x * this.unitsPerPixel;
                                                    properties.y = entity.y * this.unitsPerPixel;
                        
                                                    if (entity.rotation) {
                                                        w = (entity.width || fallbackWidth) / 2;
                                                        h = (entity.height || fallbackHeight) / 2;
                                                        a = ((entity.rotation / 180) % 2) * Math.PI;
                                                        v = platypus.Vector.setUp(w, -h).rotate(a);
                                                        properties.rotation = entity.rotation;
                                                        properties.x = Math.round((properties.x + v.x - w) * clamp) / clamp;
                                                        properties.y = Math.round((properties.y + v.y + h) * clamp) / clamp;
                                                        v.recycle();
                                                    }
                        
                                                    if (entityPositionX === &#x27;left&#x27;) {
                                                        properties.regX = 0;
                                                    } else if (entityPositionX === &#x27;center&#x27;) {
                                                        properties.regX = properties.width / 2;
                                                        properties.x += widthOffset / 2;
                                                    } else if (entityPositionX === &#x27;right&#x27;) {
                                                        properties.regX = properties.width;
                                                        properties.x += widthOffset;
                                                    }
                                                    properties.x += mapOffsetX;
                        
                                                    if (gid === -1) {
                                                        properties.y += properties.height;
                                                    }
                                                    if (entityPositionY === &#x27;bottom&#x27;) {
                                                        properties.regY = properties.height;
                                                    } else if (entityPositionY === &#x27;center&#x27;) {
                                                        properties.regY = properties.height / 2;
                                                        properties.y -= heightOffset / 2;
                                                    } else if (entityPositionY === &#x27;top&#x27;) {
                                                        properties.regY = 0;
                                                        properties.y -= heightOffset;
                                                    }
                                                    properties.y += mapOffsetY;
                        
                                                    if (entity.ellipse) {
                                                        properties.shape = {};
                                                        properties.shape.type = &#x27;ellipse&#x27;;
                                                        properties.shape.width = properties.width * this.unitsPerPixel;
                                                        properties.shape.height = properties.height * this.unitsPerPixel;
                                                    } else if (entity.width &amp;&amp; entity.height) {
                                                        properties.shape = {};
                                                        properties.shape.type = &#x27;rectangle&#x27;;
                                                        properties.shape.width = properties.width * this.unitsPerPixel;
                                                        properties.shape.height = properties.height * this.unitsPerPixel;
                                                    }
                                                }
                        
                                                if (entityDefProps) {
                                                    properties.scaleX *= this.imagesScale * (entityDefProps.scaleX || 1); //this.unitsPerPixel;
                                                    properties.scaleY *= this.imagesScale * (entityDefProps.scaleY || 1); //this.unitsPerPixel;
                                                } else {
                                                    properties.scaleX *= this.imagesScale;
                                                    properties.scaleY *= this.imagesScale;
                                                }
                                                properties.layerZ = this.layerZ;
                        
                                                //Setting the z value. All values are getting added to the layerZ value.
                                                if (properties.z) {
                                                    properties.z += this.layerZ;
                                                } else if (entityDefProps &amp;&amp; (typeof entityDefProps.z === &#x27;number&#x27;)) {
                                                    properties.z = this.layerZ + entityDefProps.z;
                                                } else {
                                                    properties.z = this.layerZ;
                                                }
                        
                                                properties.parent = this.owner;
                                                entity = this.owner.addEntity(new Entity(entityDefinition, {
                                                    properties: properties
                                                }, this.updateLoadingProgress.bind(this, progress)));
                                                if (entity) {
                                                    if (entity.camera) {
                                                        this.followEntity = {
                                                            entity: entity,
                                                            mode: entity.camera
                                                        }; //used by camera
                                                    }
                                                    this.owner.triggerEvent(&#x27;entity-created&#x27;, entity);
                                                }
                                            } else {
                                                this.updateLoadingProgress(progress);
                                            }
                                        }
                                        this.layerZ += this.layerIncrement;
                                    },
                        
                                    setupLayer: function (layer, layerCollides, combineRenderLayer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, progress) {
                                        var entity = &#x27;render-layer&#x27;; // default
                                        
                                        // First determine which type of entity this layer should behave as:
                                        if (layer.properties &amp;&amp; layer.properties.entity) {
                                            entity = layer.properties.entity;
                                        } else if (layer.name === &quot;collision&quot;) {
                                            entity = &#x27;collision-layer&#x27;;
                                        } else if (layer.name === &quot;action&quot;) {
                                            if (layerCollides) {
                                                entity = &#x27;tile-layer&#x27;;
                                            } else {
                                                entity = &#x27;render-layer&#x27;;
                                            }
                                        }
                        
                                        if (entity === &#x27;tile-layer&#x27; || (this.showCollisionTiles &amp;&amp; platypus.game.settings.debug)) {
                                            progress.count += 1; // to compensate for creating 2 layers. The &quot;tile-layer&quot; option should probably be deprecated as soon as support for Tiled&#x27;s tile collision is added.
                                            this.createLayer(&#x27;collision-layer&#x27;, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);
                                            return this.createLayer(&#x27;render-layer&#x27;, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);
                                        } else if (entity === &#x27;collision-layer&#x27;) {
                                            this.createLayer(&#x27;collision-layer&#x27;, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);
                                            return null;
                                        } else {
                                            return this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer, progress);
                                        }
                                    },
                                    
                                    updateLoadingProgress: function (progress) {
                                        progress.count += 1;
                                        progress.progress = progress.count / progress.total;
                        
                                        /**
                                         * As a level is loaded, this event is triggered to show progress.
                                         *
                                         * @event &#x27;level-loading-progress&#x27;
                                         * @param message {platypus.Data} Contains progress data.
                                         * @param message.count {Number} The number of loaded entities.
                                         * @param message.progress {Number} A fraction of count / total.
                                         * @param message.total {Number} The total number of entities being loaded by this component.
                                         * @since 0.8.3
                                         */
                                        this.owner.triggerEvent(&#x27;level-loading-progress&#x27;, progress);
                        
                                        if (progress.count === progress.total) {
                                            progress.recycle();
                                            this.finishedLoading();
                                        }
                                    },
                        
                                    destroy: function () {
                                    }
                                },
                                
                                publicMethods: {
                                    /**
                                     * This method decodes a Tiled layer and sets its data to CSV format.
                                     *
                                     * @method decodeLayer
                                     * @param layer {Object} An object describing a Tiled JSON-exported layer.
                                     * @return {Object} The same object provided, but with the data field updated.
                                     * @chainable
                                     * @since 0.7.1
                                     */
                                    decodeLayer: function (layer) {
                                        if (layer.encoding === &#x27;base64&#x27;) {
                                            layer.data = decodeBase64(layer.data, layer.compression);
                                            layer.encoding = &#x27;csv&#x27;; // So we won&#x27;t have to decode again.
                                        }
                                        return layer;
                                    }
                                },
                                
                                getAssetList: function (def, props, defaultProps) {
                                    var ps = props || {},
                                        dps = defaultProps || {},
                                        ss     = def.spriteSheet || ps.spriteSheet || dps.spriteSheet,
                                        images = def.images || ps.images || dps.images,
                                        assets = checkLevel(def.level || ps.level || dps.level, ss);
                                    
                                    if (ss) {
                                        if (typeof ss === &#x27;string&#x27;) {
                                            assets.union(platypus.game.settings.spriteSheets[ss].images);
                                        } else {
                                            assets.union(ss.images);
                                        }
                                    }
                                    
                                    if (images) {
                                        assets.union(images);
                                    }
                                    
                                    return assets;
                                },
                                
                                getLateAssetList: function (def, props, defaultProps, data) {
                                    var ps  = props || {},
                                        dps = defaultProps || {},
                                        ss  = def.spriteSheet || ps.spriteSheet || dps.spriteSheet;
                        
                                    if (data &amp;&amp; data.level) {
                                        return checkLevel(data.level, ss);
                                    } else {
                                        return Array.setUp();
                                    }
                                }
                            });
                        }());
                        
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
