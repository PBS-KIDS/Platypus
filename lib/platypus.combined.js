/*!
* platypus
* 
*/


//##############################################################################
// pako_inflate.js
//##############################################################################

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],2:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safary
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // use fallback for big arrays to avoid stack overflow
  if (len < 65537) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Fuckup - very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means vuffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":1}],3:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],4:[function(require,module,exports){
'use strict';


module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],5:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],6:[function(require,module,exports){
'use strict';


function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],7:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],8:[function(require,module,exports){
'use strict';


var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":1,"./adler32":3,"./crc32":5,"./inffast":7,"./inftrees":9}],9:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i = 0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":1}],10:[function(require,module,exports){
'use strict';

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],11:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],"/lib/inflate.js":[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overriden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      // Convert data if needed
      if (typeof dictionary === 'string') {
        dict = strings.string2buf(dictionary);
      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(dictionary);
      } else {
        dict = dictionary;
      }

      status = zlib_inflate.inflateSetDictionary(this.strm, dict);

    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 alligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":1,"./utils/strings":2,"./zlib/constants":4,"./zlib/gzheader":6,"./zlib/inflate":8,"./zlib/messages":10,"./zlib/zstream":11}]},{},[])("/lib/inflate.js")
});

//##############################################################################
// recycle.js
//##############################################################################

(function (window, Object, Array) {
    'use strict';
    
    var properties = {
            setUp: {
                value: null
            },
            recycle: {
                value: null
            }
        },
        recycleProd = function (cache, instance) {
            cache.push(instance);
        },
        recycleDebug = function (cache, instance) {
            if (instance.recycled) {
                console.warn('WHOA! I have already been recycled!', instance);
            } else {
                instance.recycled = true;
                cache.push(instance);
            }
        },
        recycleProp = {
            value: false,
            writable: true
        },
        setUpProd = function (cache) {
            var newObject = null;
            
            if (cache.length) {
                newObject = cache.pop();
            } else {
                newObject = Object.create(this.prototype);
            }

            this.apply(newObject, arguments);

            return newObject;
        },
        setUpArrayProd = function (cache) {
            var i = 0,
                arr = null;
            
            if (cache.length) {
                arr = cache.pop();
            } else {
                arr = [];
            }
            
            for (i = 0; i < arguments.length; i++) {
                arr.push(arguments[i]);
            }

            return arr;
        },
        setUpDebug = function (cache) {
            var newObject = null;
            
            if (cache.length) {
                newObject = cache.pop();
                newObject.recycled = false;
            } else {
                newObject = Object.create(this.prototype);
                Object.defineProperty(newObject, 'recycled', recycleProp);
            }

            this.apply(newObject, arguments);

            return newObject;
        },
        setUpArrayDebug = function (cache) {
            var i = 0,
                arr = null;
            
            if (cache.length) {
                arr = cache.pop();
                arr.recycled = false;
            } else {
                arr = [];
                Object.defineProperty(arr, 'recycled', recycleProp);
            }
            
            for (i = 1; i < arguments.length; i++) {
                arr.push(arguments[i]);
            }

            return arr;
        },
        caches = {},
        cacheIndex = 0;
    
    window.recycle = {
        add: function (ClassObject, debug, name, recycle) {
            var isArray = (ClassObject === Array),
                cache = [];
            
            if (name && caches[name]) {
                console.warn('Recycle cache for "' + name + '" already exists.');
            }

            caches[name || ('cache-' + (cacheIndex++))] = cache;
            
            if (debug) {
                properties.setUp.value = (isArray ? setUpArrayDebug : setUpDebug).bind(ClassObject, cache);
                properties.recycle.value = recycleDebug.bind(ClassObject, cache);
            } else {
                properties.setUp.value = (isArray ? setUpArrayProd : setUpProd).bind(ClassObject, cache);
                properties.recycle.value = recycleProd.bind(ClassObject, cache);
            }

            Object.defineProperties(ClassObject, properties);
            Object.defineProperty(ClassObject.prototype, 'recycle', {
                value: recycle || (isArray ? function (depth) {
                    var i = 0;
                    
                    if (depth > 1) {
                        i = this.length;
                        depth -= 1;
                        while (i--) {
                            this[i].recycle(depth);
                        }
                    }
                    this.length = 0;
                    ClassObject.recycle(this);
                } : function () {
                    ClassObject.recycle(this);
                })
            });
            
            return cache;
        },
        cache: caches
    };
}(window, Object, Array));

//##############################################################################
// platypus.js
//##############################################################################

/* global springroll, navigator, window */
this.platypus = this.platypus || {};

(function (platypus) {
    'use strict';

    var doNothing = function () {},
        uagent    = navigator.userAgent.toLowerCase(),
        isEdge    = (uagent.search('edge')    > -1),
        isIPod    = (uagent.search('ipod')    > -1),
        isIPhone  = (uagent.search('iphone')  > -1),
        isIPad    = (uagent.search('ipad')    > -1),
        isAndroid = (uagent.search('android') > -1),
        isSilk    = (uagent.search('silk')    > -1),
        isIOS     = isIPod || isIPhone  || isIPad,
        isMobile  = isIOS  || isAndroid || isSilk;
    
    /**
     * This is an object of boolean key/value pairs describing the current browser's properties.
     * @property supports
     * @type Object
     **/
    platypus.supports = {
        touch: (window.ontouchstart !== 'undefined'),
        edge: isEdge,
        iPod: isIPod,
        iPhone: isIPhone,
        iPad: isIPad,
        safari: (uagent.search('safari')  > -1) && !isEdge,
        ie: (uagent.search('msie')    > -1) || (uagent.search('trident') > -1),
        firefox: (uagent.search('firefox') > -1),
        android: isAndroid,
        chrome: (uagent.search('chrome')  > -1) && !isEdge,
        silk: isSilk,
        iOS: isIOS,
        mobile: isMobile,
        desktop: !isMobile
    };
    
    /**
     * This method defines platypus.debug and uses springroll.Debug if available. If springroll.Debug is not loaded, platypus.debug provides inactive stubs for console methods.
     *
     * @property debug
     * @type Object
     */
    platypus.debug = springroll.Debug || {
        error: doNothing,
        log: doNothing,
        olive: doNothing, // Platypus favors olive output to distinguish its output from other console logs.
        warn: doNothing
    };

    /**
     * The version string for this release.
     * @property version
     * @type String
     * @static
     **/
    platypus.version = /*=version*/"NEXT"; // injected by build process

    /**
     * The build date for this release in UTC format.
     * @property buildDate
     * @type String
     * @static
     **/
    platypus.buildDate = /*=date*/"Tue, 26 Jul 2016 00:24:32 GMT"; // injected by build process

}(this.platypus));

//##############################################################################
// Array.js
//##############################################################################

/**
 * @namespace window
 */
/*global recycle, springroll */
(function (Array, Object) {
    'use strict';
    
    /**
     * Add methods to Array
     * @class Array
     */
    var prototype = Array.prototype;

    /**
     * Merges a given array into the current array without duplicating items.
     *
     * @method union
     * @return {Array}
     * @chainable
     */
    if (!prototype.union) {
        Object.defineProperty(prototype, 'union', {
            value: function (array) {
                var i = 0,
                    bL = array.length;
                    
                for (i = 0; i < bL; i++) {
                    if (this.indexOf(array[i]) === -1) {
                        this.push(array[i]);
                    }
                }
                
                return this;
            }
        });
    }
    
    /**
     * Slices, but uses a recycled array. Note that this slice does not accept parameters and makes a shallow copy of the original array.
     *
     * @method greenSlice
     * @return Array
     */
    if (!prototype.greenSlice) {
        Object.defineProperty(prototype, 'greenSlice', {
            value: function () {
                var arr = Array.setUp(),
                    i = 0,
                    length = this.length;
                    
                for (i = 0; i < length; i++) {
                    arr[i] = this[i];
                }
                
                return arr;
            }
        });
    }
    
    /**
     * Splices, but only removes a single item and returns the item itself, not an array.
     *
     * @method greenSplice
     * @return Array
     */
    if (!prototype.greenSplice) {
        Object.defineProperty(prototype, 'greenSplice', {
            value: function (index) {
                var i = 0,
                    item = this[index],
                    length = this.length;
                    
                if ((index < 0) || (index >= length)) {
                    return null;
                }
                
                for (i = index + 1; i < length; i++) {
                    this[i - 1] = this[i];
                }
                
                if (length) {
                    this.length -= 1;
                }
                
                return item;
            }
        });
    }
    
    /**
     * Save instance for reuse.
     *
     * @method Array.recycle
     * @param instance {Array} The instance to recycle.
     * @since 0.7.1
     */
    /**
     * Save instance for reuse.
     *
     * @method recycle
     * @param [depth] {Number} The dimensions of the array.
     * @since 0.7.1
     */
    /**
     * Create a new instance or reuse an old instance if available.
     *
     * @method Array.setUp
     * @param [item] {Object|String|Number|Boolean} One or more arguments to prepopulate items in the array.
     * @return Array
     * @since 0.7.1
     */
    recycle.add(Array, !!springroll.Debug, 'Array');

}(Array, Object));

//##############################################################################
// PIXI.Graphics.js
//##############################################################################

/**
 * This adds support for a tiny API to PIXI.Graphics similar to the CreateJS Graphics API. This is used for backwards support for RenderSprite masks.
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var Graphics = include('PIXI.Graphics'),
        debug = function (param) {
            platypus.debug.olive('"' + param + '" is not an available PIXI.Graphics method.');
            return this;
        },
        gfx = Graphics.prototype;
    
    gfx.a  = gfx.arc;
    gfx.at = gfx.arcTo;
    gfx.bt = gfx.bezierCurveTo;
    gfx.c  = gfx.clear;
    gfx.dc = gfx.drawCircle;
    gfx.de = gfx.drawEllipse;
    gfx.dr = gfx.drawRect;
    gfx.ef = gfx.endFill;
    gfx.f  = gfx.beginFill;
    gfx.lt = gfx.lineTo;
    gfx.mt = gfx.moveTo;
    gfx.qt = gfx.quadraticCurveTo;
    gfx.r  = gfx.drawRect;
    gfx.rr = gfx.drawRoundedRect;
    
    gfx.cp = debug.bind("cp");
    gfx.lf = debug.bind("lf");
    gfx.rf = debug.bind("rf");
    gfx.bf = debug.bind("bf");
    gfx.ss = debug.bind("ss");
    gfx.sd = debug.bind("sd");
    gfx.s  = debug.bind("s");
    gfx.ls = debug.bind("ls");
    gfx.rs = debug.bind("rs");
    gfx.bs = debug.bind("bs");
    gfx.es = debug.bind("es");
    gfx.rc = debug.bind("rc");
    gfx.dp = debug.bind("dp");
    gfx.p  = debug.bind("p");
    
} ());

//##############################################################################
// PIXI.Container.js
//##############################################################################

(function () {
    'use strict';
    
    var prototype = PIXI.Container.prototype;
    
    prototype.updateTransform = function () {
        var i = 0,
            j = 0;
        
        if (!this.visible) {
            return;
        }
    
        if (this.transformMatrix) {
            // Just copy the current matrix instead of working with properties.
            this.transformMatrix.copy(this.worldTransform).prepend(this.parent.worldTransform);
            
            // multiply the alphas..
            this.worldAlpha = this.alpha * this.parent.worldAlpha;
        
            // reset the bounds each time this is called!
            this._currentBounds = null;
        } else {
            this.displayObjectUpdateTransform();
        }
    
        for (i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].updateTransform();
        }
    };
    
    prototype.containerUpdateTransform = prototype.updateTransform;
}());

//##############################################################################
// String.js
//##############################################################################

/**
 * @namespace window
 */
(function (String, Object) {
    'use strict';
    /**
     * Add methods to String
     * @class String
     */
    
    var prototype = String.prototype;

    /**
     * Splits, but uses a recycled array.
     *
     * @method greenSplit
     * @return Array
     */
    if (!prototype.greenSplit) {
        Object.defineProperty(prototype, 'greenSplit', {
            value: function (splitter) {
                var str = this.toString(),
                    d = 0,
                    i = 0,
                    arr = Array.setUp();
                
                if (splitter) {
                    i = str.indexOf(splitter);
                    d = splitter.length;

                    while (i >= 0) {
                        arr.push(str.substr(0, i));
                        str = str.substr(i + d);
                        i = str.indexOf(splitter);
                    }
                    
                    arr.push(str);
                } else {
                    i = this.length;
                    d = i - 1;

                    while (i--) {
                        arr.push(this[d - i]);
                    }
                }
                
                return arr;
            }
        });
    }
}(String, Object));

//##############################################################################
// Map.js
//##############################################################################

/**
 * @namespace window
 */
/**
 * This class defines a limited polyfill for Map. If the browser supports Map, this class is not used.
 *
 * @class Map
 * @since 0.8.0
 */
/* global window */
(function (Object) {
    'use strict';
    
    var mapDefinition = null,
        Map = null,
        proto = null;
    
    if (!window.Map) {
        mapDefinition = {
            value: null
        };
        Map = function () {
            /**
             * This is an object containing a list of key/value pairs. This property should not be used directly.
             *
             * @property map
             * @type Object
             * @private
             * @default {}
             */
            mapDefinition.value = {};
            Object.defineProperty(this, 'map', mapDefinition);
        };
        proto = Map.prototype;

        Object.defineProperties(proto, {

            /**
             * Returns the value of the provided key.
             *
             * @method get
             * @param key {String} The key to lookup.
             * @return value {any} The value of the provded key.
             */
            get: {
                value: function (key) {
                    return this.map[key];
                }
            },

            /**
             * Determines whether the provided key is available in this Map.
             *
             * @method has
             * @param key {String} The key to lookup.
             * @return value {Boolean} Whether the key is listed in this Map.
             */
            has: {
                value: function (key) {
                    return this.map.hasOwnProperty(key);
                }
            },

            /**
             * Sets a value to a key in the Map.
             *
             * @method set
             * @param key {String} The key to associate with the provided value.
             * @param value {any} The value to be stored by the Map.
             * @chainable
             */
            set: {
                value: function (key, value) {
                    this.map[key] = value;
                    return this;
                }
            },
            
            /**
             * Deletes a key (and value) from the Map.
             *
             * @method delete
             * @param key {String} The key to delete from the Map.
             * @return value {any} The value of the key is returned.
             */
            delete: {
                value: function (key) {
                    var value = this.map[key];
                    
                    delete this.map[key];
                    return value;
                }
            }
        });
        
        window.Map = Map;
    }
}(Object));

//##############################################################################
// Data.js
//##############################################################################

/**
 * This class defines a generic data object to use for messaging. It includes recycle methods to encourage reuse.
 *
 * @namespace platypus
 * @class Data
 * @constructor
 * @return {Data} Returns the new Data object.
 * @since 0.7.1
 */
/*global platypus, recycle, springroll */
platypus.Data = (function () {
    'use strict';
    
    var
        Data = function (first) {
            var i = arguments.length,
                key = '';
            
            if (first) {
                if (typeof first === 'string') {
                    if (i % 2) {
                        this[i] = null;
                        i -= 1;
                    }
                    while (i) {
                        this[arguments[i - 2]] = arguments[i - 1];
                        i -= 2;
                    }
                } else {
                    for (key in first) {
                        if (first.hasOwnProperty(key)) {
                            this[key] = first[key];
                        }
                    }
                }
            }
        };
    
    /**
     * Returns Data from cache or creates a new one if none are available.
     *
     * @method Data.setUp
     * @return {platypus.Data} The instantiated Data.
     * @since 0.7.1
     */
    /**
     * Returns Data back to the cache. Prefer the Data's recycle method since it recycles property objects as well.
     *
     * @method Data.recycle
     * @param {platypus.Data} The Data to be recycled.
     * @since 0.7.1
     */
    /**
     * Relinquishes Data properties and recycles it.
     *
     * @method recycle
     * @since 0.7.1
     */
    recycle.add(Data, !!springroll.Debug, 'Data', function () {
        var key = '';
        
        for (key in this) {
            if (this.hasOwnProperty(key)) {
                delete this[key];
            }
        }
        Data.recycle(this);
    });
    
    return Data;
}());

//##############################################################################
// DataMap.js
//##############################################################################

/**
 * This class defines a generic iterable data object. It behaves similarly to Map but maintains a list of keys as an Array. It includes recycle methods to encourage reuse.
 *
 * @namespace platypus
 * @class DataMap
 * @constructor
 * @return dataMap {platypus.DataMap} Returns the new DataMap object.
 * @uses Map
 * @since 0.8.0
 */
/* global include, platypus, recycle, springroll */
platypus.DataMap = (function () {
    'use strict';
    
    var Map = include('window.Map'),
        mapSet = function (keys, key, value) {
            if (this.get(key) !== value) {
                if (!this.has(key)) {
                    keys.push(key);
                }
                this.set(key, value);
            }
            return value;
        },
        mapDelete = function (keys, key) {
            var i = keys.indexOf(key),
                value = this.get(key);
            
            if (i >= 0) {
                keys.greenSplice(i);
                this.delete(key);
            }
            
            return value;
        },
        mapClear = function (keys) {
            var i = keys.length;
            
            while (i--) {
                this.delete(keys[i]);
            }
            keys.length = 0;
        },
        mapMethods = {
            get: {
                value: null
            },
            has: {
                value: null
            },
            keys: {
                value: null
            },
            set: {
                value: null
            },
            delete: {
                value: null
            },
            clear: {
                value: null
            }
        },
        DataMap = function (first) {
            var i = arguments.length,
                key = '',
                keys = null,
                map = null,
                mm = null;
            
            if (!this.map) {
                mm = mapMethods;
                map = this.map = new Map;
                
                /**
                 * Tracks keys on this object to make iteration faster.
                 *
                 * @property keys
                 * @type Array
                 * @default []
                 */
                keys = mm.keys.value = Array.setUp();
                
                /**
                 * Returns the value of the provided key.
                 *
                 * @method get
                 * @param key {String} The key to lookup.
                 * @return value {any} The value of the provded key.
                 */
                mm.get.value = map.get.bind(map);
                
                /**
                 * Determines whether the provided key is available on this DataMap.
                 *
                 * @method has
                 * @param key {String} The key to lookup.
                 * @return value {Boolean} Whether the key is listed in this DataMap.
                 */
                mm.has.value = map.has.bind(map);
                
                /**
                 * Sets a value to a key in the DataMap.
                 *
                 * @method set
                 * @param key {String} The key to associate with the provided value.
                 * @param value {any} The value to be stored by the DataMap.
                 * @return value {any} The value passed in is returned for chaining.
                 */
                mm.set.value = mapSet.bind(map, keys);
                
                /**
                 * Deletes a key (and value) from the DataMap.
                 *
                 * @method delete
                 * @param key {String} The key to delete from the DataMap.
                 * @return value {any} The value of the key is returned.
                 */
                mm.delete.value = mapDelete.bind(map, keys);
                
                /**
                 * Clears out of keys (and values) from the DataMap.
                 *
                 * @method clear
                 */
                mm.clear.value = mapClear.bind(map, keys);
                
                Object.defineProperties(this, mm);
            }
            
            if (first) {
                keys = first.keys;

                if (typeof first === 'string') {
                    if (i % 2) {
                        i -= 1;
                        this.set(arguments[i], null);
                    }
                    while (i) {
                        i -= 2;
                        this.set(arguments[i], arguments[i + 1]);
                    }
                } else if (keys) {
                    i = keys.length;
                    while (i--) {
                        this.set(keys[i], first.get(keys[i]));
                    }
                } else {
                    for (key in first) {
                        if (first.hasOwnProperty(key)) {
                            this.set(key, first[key]);
                        }
                    }
                }
            }
        };
    
    /**
     * Returns DataMap from cache or creates a new one if none are available.
     *
     * @method DataMap.setUp
     * @return dataMap {platypus.DataMap} The instantiated DataMap.
     */
    /**
     * Returns DataMap back to the cache. Prefer the DataMap's recycle method since it recycles property objects as well.
     *
     * @method DataMap.recycle
     * @param dataMap {platypus.DataMap} The DataMap to be recycled.
     */
    /**
     * Relinquishes DataMap properties and recycles it.
     *
     * @method recycle
     */
    recycle.add(DataMap, !!springroll.Debug, 'DataMap', function () {
        this.clear();
        DataMap.recycle(this);
    });
    
    return DataMap;
}());

//##############################################################################
// PIXIAnimation.js
//##############################################################################

/**
 * This class plays animation sequences of frames and mimics the syntax required for creating CreateJS Sprites, allowing CreateJS Sprite Sheet definitions to be used with pixiJS.
 *
 * @class PIXIAnimation
 * @extends PIXI.Sprite
 */
//TODO: Document!
/*global include, PIXI, platypus */
(function () {
    'use strict';
    
    var Application = include('springroll.Application'), // Import SpringRoll classes
        BaseTexture = include('PIXI.BaseTexture'),
        Data = include('platypus.Data'),
        Point = include('PIXI.Point'),
        Rectangle = include('PIXI.Rectangle'),
        Sprite = include('PIXI.Sprite'),
        Texture = include('PIXI.Texture'),
        animationCache = {},
        baseTextureCache = {},
        emptyFrame = {
            texture: Texture.EMPTY,
            anchor: new Point(0, 0)
        },
        regex = /[\[\]{},-]/g,
        getBaseTextures = function (images) {
            var i = 0,
                bts = Array.setUp(),
                asset = null,
                assetCache = Application.instance.assetManager.cache,
                btCache = baseTextureCache,
                path = null;
            
            for (i = 0; i < images.length; i++) {
                path = images[i];
                if (typeof path === 'string') {
                    if (!btCache[path]) {
                        asset = assetCache.read(path);
                        if (!asset) {
                            platypus.debug.warn('"' + path + '" is not a loaded asset.');
                            break;
                        }
                        btCache[path] = new BaseTexture(asset);
                    }
                    bts.push(btCache[path]);
                } else {
                    bts.push(new BaseTexture(path));
                }
            }
            
            return bts;
        },
        getTexturesCacheId = function (spriteSheet) {
            var i = 0;
            
            if (spriteSheet.id) {
                return spriteSheet.id;
            }
            
            for (i = 0; i < spriteSheet.images.length; i++) {
                if (typeof spriteSheet.images[i] !== 'string') {
                    return '';
                }
            }
            
            spriteSheet.id = JSON.stringify(spriteSheet).replace(regex, '');

            return spriteSheet.id;
        },
        getDefaultAnimation = function (length, textures) {
            var frames = Array.setUp(),
                i = 0;
            
            for (i = 0; i < length; i++) {
                frames.push(textures[i] || emptyFrame);
            }
            return Data.setUp(
                "id", "default",
                "frames", frames,
                "next", "default",
                "speed", 1
            );
        },
        standardizeAnimations = function (def, textures) {
            var animation = '',
                anims = Data.setUp(),
                i = 0,
                frames = null,
                key = '';
            
            for (key in def) {
                if (def.hasOwnProperty(key)) {
                    animation = def[key];
                    frames = animation.frames.greenSlice();
                    i = frames.length;
                    while (i--) {
                        frames[i] = textures[frames[i]] || emptyFrame;
                    }
                    anims[key] = Data.setUp(
                        "id", key,
                        "frames", frames,
                        "next", animation.next,
                        "speed", animation.speed
                    );
                }
            }
            
            return anims;
        },
        getAnimations = function (spriteSheet) {
            var i = 0,
                anims    = null,
                frame    = null,
                frames   = spriteSheet.frames,
                images   = spriteSheet.images,
                texture  = null,
                textures = Array.setUp(),
                bases    = getBaseTextures(images);

            // Set up texture for each frame
            for (i = 0; i < frames.length; i++) {
                frame = frames[i];
                texture = new Texture(bases[frame[4]], new Rectangle(frame[0], frame[1], frame[2], frame[3]));
                textures.push({
                    texture: texture,
                    anchor: new Point((frame[5] || 0) / texture.width, (frame[6] || 0) / texture.height)
                });
            }

            // Set up animations
            anims = standardizeAnimations(spriteSheet.animations, textures);

            // Set up a default animation that plays through all frames
            if (!anims.default) {
                anims.default = getDefaultAnimation(textures.length, textures);
            }
            
            bases.recycle();
            
            return Data.setUp(
                "textures", textures,
                "animations", anims
            );
        },
        cacheAnimations = function (spriteSheet, cacheId) {
            var i = 0,
                anims    = null,
                frame    = null,
                frames   = spriteSheet.frames,
                images   = spriteSheet.images,
                texture  = null,
                textures = Array.setUp(),
                bases    = getBaseTextures(images);

            // Set up texture for each frame
            for (i = 0; i < frames.length; i++) {
                frame = frames[i];
                texture = new Texture(bases[frame[4]], new Rectangle(frame[0], frame[1], frame[2], frame[3]));
                textures.push({
                    texture: texture,
                    anchor: new Point((frame[5] || 0) / texture.width, (frame[6] || 0) / texture.height)
                });
            }

            // Set up animations
            anims = standardizeAnimations(spriteSheet.animations, textures);

            // Set up a default animation that plays through all frames
            if (!anims.default) {
                anims.default = getDefaultAnimation(textures.length, textures);
            }
            
            bases.recycle();
            
            return Data.setUp(
                "textures", textures,
                "animations", anims,
                "viable", 1,
                "cacheId", cacheId
            );
        },
        PIXIAnimation = function (spriteSheet, animation) {
            var FR = 60,
                cacheId = getTexturesCacheId(spriteSheet),
                cache = (cacheId ? animationCache[cacheId] : null),
                speed = (spriteSheet.framerate || FR) / FR;
            
            if (!cacheId) {
                cache = getAnimations(spriteSheet);
            } else if (!cache) {
                cache = animationCache[cacheId] = cacheAnimations(spriteSheet, cacheId);
                this.cacheId = cacheId;
            } else {
                cache.viable += 1;
                this.cacheId = cacheId;
            }
            
            Sprite.call(this, cache.textures[0].texture);
        
            /**
            * @private
            */
            this._animations = cache.animations;
            
            this._animation = null;
        
            /**
            * The speed that the PIXIAnimation will play at. Higher is faster, lower is slower
            *
            * @member {number}
            * @default 1
            */
            this.animationSpeed = speed;
        
            /**
            * Elapsed time since animation has been started, used internally to display current texture
            *
            * @member {number}
            * @private
            */
            this._currentTime = 0;
        
            /**
            * Indicates if the PIXIAnimation is currently playing
            *
            * @member {boolean}
            * @readonly
            */
            this.playing = false;
            
            this._visible = true;
            
            this._updating = false;

            // Set up initial playthrough.
            if (cache.textures.length < 2) {
                this.gotoAndStop(animation);
            } else {
                this.gotoAndPlay(animation);
            }
        },
        prototype = PIXIAnimation.prototype = Object.create(Sprite.prototype);
    
    PIXIAnimation.prototype.constructor = PIXIAnimation;
    platypus.PIXIAnimation = PIXIAnimation;
    
    Object.defineProperties(prototype, {
        /**
        * The visibility of the sprite.
        *
        * @property visible
        * @memberof PIXI.DisplayObject#
        */
        visible: {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                this._visible = value;
                this._syncUpdate();
            }
        },
        
       /**
        * The PIXIAnimations current frame index
        *
        * @member {number}
        * @memberof platypus.PIXIAnimation#
        * @readonly
        */
        currentFrame: {
            get: function () {
                var frames = this._animation.frames;
                return frames[Math.floor(this._currentTime) % frames.length];
            }
        },
        
        /**
        * The PIXIAnimations paused state. If paused, the animation doesn't update.
        *
        * @property paused
        */
        paused: {
            get: function () {
                return !this.playing;
            },
            set: function (value) {
                if ((value && this.playing) || (!value && !this.playing)) {
                    this.playing = !value;
                    this._syncUpdate();
                }
            }
        }
    
    });
    
    /**
    * Stops the PIXIAnimation
    *
    */
    prototype.stop = function () {
        this.paused = true;
        /*
        if (!this.playing) {
            return;
        }
    
        this.playing = false;
        this._syncUpdate();
        */
    };
    
    /**
    * Plays the PIXIAnimation
    *
    */
    prototype.play = function () {
        this.paused = false;
        /*
        if (this.playing) {
            return;
        }
    
        this.playing = true;
        this._syncUpdate();
        */
    };
    
    prototype._syncUpdate = function () {
        var update = this.playing && this._visible;
        
        if (update !== this._updating) {
            this._updating = update;
            
            if (update) {
                PIXI.ticker.shared.add(this.update, this);
            } else {
                PIXI.ticker.shared.remove(this.update, this);
            }
        }
    };
    
    /**
    * Stops the PIXIAnimation and goes to a specific frame
    *
    * @param frameNumber {number} frame index to stop at
    */
    prototype.gotoAndStop = function (animation) {
        this.stop();
    
        this._currentTime = 0;
        this._animation = this._animations[animation];
        if (!this._animation) {
            this._animation = this._animations.default;
        }
        this._texture = this._animation.frames[0].texture;
        this.anchor =  this._animation.frames[0].anchor;
    };
    
    /**
    * Goes to a specific frame and begins playing the PIXIAnimation
    *
    * @method gotoAndPlay
    * @param animation {string} The animation to begin playing.
    */
    prototype.gotoAndPlay = function (animation) {
        this._currentTime = 0;
        this._animation = this._animations[animation];
        if (!this._animation) {
            this._animation = this._animations.default;
        }
        this._texture = this._animation.frames[0].texture;
        this.anchor = this._animation.frames[0].anchor;
        
        this.play();
    };
    
    /**
    * Returns whether a particular animation is available.
    *
    * @method has
    * @param animation {string} The animation to check.
    * @since 0.9.0
    */
    prototype.has = function (animation) {
        return !!this._animations[animation];
    };
    
    /*
    * Updates the object transform for rendering
    * @private
    */
    prototype.update = function (deltaTime) {
        var data = null,
            name = "",
            floor = 0;
        
        this._currentTime += this.animationSpeed * this._animation.speed * deltaTime;
        
        floor = Math.floor(this._currentTime);
    
        if (floor < 0) {
            floor = 0;
        }
        
        if (floor < this._animation.frames.length) {
            data = this._animation.frames[floor % this._animation.frames.length];
            this._texture = data.texture;
            this.anchor = data.anchor;
        } else if (floor >= this._animation.frames.length) {
            name = this._animation.id;
            this.gotoAndPlay(this._animation.next);
            this.emit('complete', name);
        }
    };
    
    /**
     * Stops the PIXIAnimation and destroys it
     *
     * @method destroy
     */
    prototype.destroy = function () {
        var key = '';
        
        this.stop();
        Sprite.prototype.destroy.call(this);
        if (this.cacheId) {
            animationCache[this.cacheId].viable -= 1;
            if (animationCache[this.cacheId].viable <= 0) {
                animationCache[this.cacheId].textures.recycle();
                for (key in animationCache[this.cacheId].animations) {
                    if (animationCache[this.cacheId].animations.hasOwnProperty(key)) {
                        animationCache[this.cacheId].animations[key].frames.recycle();
                    }
                }
                delete animationCache[this.cacheId];
            }
        }
    };
    
    /**
     * This method makes sure that all the base textures are in the gpu to prevent framerate lurches later due to loading base textures as their textures appear.
     *
     * @method PIXIAnimation.preloadBaseTextures
     * @param renderer {PIXI.WebGLRenderer}
     */
    PIXIAnimation.preloadBaseTextures = function (renderer) {
        var btCache = baseTextureCache,
            key = '';
        
        if (renderer.updateTexture) {
            for (key in btCache) {
                if (btCache.hasOwnProperty(key)) {
                    renderer.updateTexture(btCache[key]);
                }
            }
        }
    };
    
    PIXIAnimation.destroyBaseTextures = function () {
        var btCache = baseTextureCache,
            key = '';
        
        for (key in btCache) {
            if (btCache.hasOwnProperty(key)) {
                btCache[key].destroy();
                delete btCache[key];
            }
        }
    };
    
    PIXIAnimation.EmptySpriteSheet = {
        framerate: 60,
        frames: [],
        images: [],
        animations: {},
        recycleSpriteSheet: function () {
            // We don't recycle this sprite sheet.
        }
    };
    
    /**
     * This method formats a provided value into a valid PIXIAnimation Sprite Sheet. This includes accepting the EaselJS spec, strings mapping to Platypus sprite sheets, or arrays of either.
     *
     * @method formatSpriteSheet
     * @param spriteSheet {String|Array|Object} The value to cast to a valid Sprite Sheet.
     * @return {Object}
     * @since 0.8.4
     */
    PIXIAnimation.formatSpriteSheet = (function () {
        var imageParts = /([\w-]+)\.(\w+)$/,
            addAnimations = function (source, destination, speedRatio, firstFrameIndex, id) {
                var key = '';
                
                for (key in source) {
                    if (source.hasOwnProperty(key)) {
                        if (destination[key]) {
                            destination[key].frames.recycle();
                            destination[key].recycle();
                            platypus.debug.olive('PIXIAnimation "' + id + '": Overwriting duplicate animation for "' + key + '".');
                        }
                        destination[key] = formatAnimation(key, source[key], speedRatio, firstFrameIndex);
                    }
                }
            },
            addFrameObject = function (source, destination, firstImageIndex, bases) {
                var i = 0,
                    fw = source.width,
                    fh = source.height,
                    rx = source.regX || 0,
                    ry = source.regY || 0,
                    w = 0,
                    h = 0,
                    x = 0,
                    y = 0;
                
                for (i = 0; i < bases.length; i++) {
                    
                    // Subtract the size of a frame so that margin slivers aren't returned as frames.
                    w = bases[i].realWidth - fw;
                    h = bases[i].realHeight - fh;
                    
                    for (y = 0; y <= h; y += fh) {
                        for (x = 0; x <= w; x += fw) {
                            destination.push([x, y, fw, fh, i + firstImageIndex, rx, ry]);
                        }
                    }
                }
            },
            addFrameArray = function (source, destination, firstImageIndex) {
                var frame = null,
                    i = 0;
                
                for (i = 0; i < source.length; i++) {
                    frame = source[i];
                    destination.push(Array.setUp(
                        frame[0],
                        frame[1],
                        frame[2],
                        frame[3],
                        frame[4] + firstImageIndex,
                        frame[5],
                        frame[6]
                    ));
                }
            },
            format = function (source, destination) {
                var bases = null,
                    dAnims = destination.animations,
                    dImages = destination.images,
                    dFR = destination.framerate || 60,
                    dFrames = destination.frames,
                    i = 0,
                    images = Array.setUp(),
                    firstImageIndex = dImages.length,
                    firstFrameIndex = dFrames.length,
                    sAnims = source.animations,
                    sImages = source.images,
                    sFR = source.framerate || 60,
                    sFrames = source.frames;
                
                // Set up id
                if (destination.id) {
                    destination.id += ';' + (source.id || source.images.join(','));
                } else {
                    destination.id = source.id || source.images.join(',');
                }
                
                // Set up images array
                for (i = 0; i < sImages.length; i++) {
                    images.push(formatImages(sImages[i]));
                    dImages.push(images[i]);
                }

                // Set up frames array
                if (Array.isArray(sFrames)) {
                    addFrameArray(sFrames, dFrames, firstImageIndex);
                } else {
                    bases = getBaseTextures(images);
                    addFrameObject(sFrames, dFrames, firstImageIndex, bases);
                    bases.recycle();
                }
                
                // Set up animations object
                addAnimations(sAnims, dAnims, sFR / dFR, firstFrameIndex, destination.id);
                
                images.recycle();
                
                return destination;
            },
            formatAnimation = function (key, animation, speedRatio, firstFrameIndex) {
                var i = 0,
                    first = 0,
                    frames = Array.setUp(),
                    last = 0;
                
                if (typeof animation === 'number') {
                    frames.push(animation + firstFrameIndex);
                    return Data.setUp(
                        "frames", frames,
                        "next", key,
                        "speed", speedRatio
                    );
                } else if (Array.isArray(animation)) {
                    first = animation[0] || 0;
                    last = (animation[1] || first) + 1 + firstFrameIndex;
                    first += firstFrameIndex;
                    for (i = first; i < last; i++) {
                        frames.push(i);
                    }
                    return Data.setUp(
                        "frames", frames,
                        "next", animation[2] || key,
                        "speed", (animation[3] || 1) * speedRatio
                    );
                } else {
                    for (i = 0; i < animation.frames.length; i++) {
                        frames.push(animation.frames[i] + firstFrameIndex);
                    }
                    return Data.setUp(
                        "frames", frames,
                        "next", animation.next || key,
                        "speed", (animation.speed || 1) * speedRatio
                    );
                }
            },
            formatImages = function (name) {
                var match = false;
                
                if (typeof name === 'string') {
                    match = name.match(imageParts);

                    if (match) {
                        return match[1];
                    }
                }

                return name;
            },
            recycle = function () {
                var animations = this.animations,
                    key = '';
                
                for (key in animations) {
                    if (animations.hasOwnProperty(key)) {
                        animations[key].frames.recycle();
                    }
                    animations[key].recycle();
                }
                
                this.frames.recycle(2);
                this.images.recycle();
                this.recycle();
            },
            merge = function (spriteSheets, destination) {
                var i = spriteSheets.length,
                    ss = null;
                
                while (i--) {
                    ss = spriteSheets[i];
                    if (typeof ss === 'string') {
                        ss = platypus.game.settings.spriteSheets[ss];
                    }
                    if (ss) {
                        format(ss, destination);
                    }
                }
                
                return destination;
            };
        
        return function (spriteSheet) {
            var response = PIXIAnimation.EmptySpriteSheet,
                ss = spriteSheet;
            
            if (typeof ss === 'string') {
                ss = platypus.game.settings.spriteSheets[spriteSheet];
            }
            
            if (ss) {
                response = Data.setUp(
                    "animations", Data.setUp(),
                    "framerate", 60,
                    "frames", Array.setUp(),
                    "id", '',
                    "images", Array.setUp(),
                    "recycleSpriteSheet", recycle
                );
                    
                if (Array.isArray(ss)) {
                    return merge(ss, response);
                } else if (ss) {
                    return format(ss, response);
                }
            }

            return response;
        };
    }());
}());

//##############################################################################
// StateMap.js
//##############################################################################

/**
 * This class defines a state object to use for entity states with helper methods. It includes recycle methods to encourage reuse.
 *
 * @namespace platypus
 * @class StateMap
 * @constructor
 * @return stateMap {platypus.StateMap} Returns the new StateMap object.
 * @extends platypus.DataMap
 * @since 0.8.0
 */
/* global extend, include, platypus, recycle, springroll */
platypus.StateMap = (function () {
    'use strict';
    
    var DataMap = include('platypus.DataMap'),
        StateMap = function (first) {
            var l = arguments.length;
            
            if (l) {
                if ((l === 1) && (typeof first === 'string')) {
                    DataMap.call(this);
                    this.updateFromString(first);
                } else {
                    DataMap.apply(this, arguments);
                }
            } else {
                DataMap.call(this);
            }
        },
        proto = extend(StateMap, DataMap);
        
    /**
     * Sets the state using the provided string value which is a comma-delimited list such that `"blue,red,!green"` sets the following state values:
     *
     *      {
     *          red: true,
     *          blue: true,
     *          green: false
     *      }
     *
     * @method updateFromString
     * @param states {String} A comma-delimited list of true/false state values.
     * @chainable
     */
    Object.defineProperty(proto, 'updateFromString', {
        value: function (states) {
            var arr = states.greenSplit(','),
                i = arr.length,
                str = '';
            
            while (i--) {
                str = arr[i];
                if (str) {
                    if (str.substr(0, 1) === '!') {
                        this.set(str.substr(1), false);
                    } else {
                        this.set(str, true);
                    }
                }
            }
            
            arr.recycle();
            
            return this;
        }
    });
    
    /**
     * Checks whether the provided state matches this state and updates this state to match.
     *
     * @method update
     * @param state {platypus.StateMap} The state that this state should match.
     * @return {Boolean} Whether this state already matches the provided state.
     */
    Object.defineProperty(proto, 'update', {
        value: function (newState) {
            var keys = newState.keys,
                i = keys.length,
                state   = '',
                changed = false,
                value = false;
            
            while (i--) {
                state = keys[i];
                value = newState.get(state);
                if (this.get(state) !== value) {
                    this.set(state, value);
                    changed = true;
                }
            }
            
            return changed;
        }
    });
    
    /**
     * Checks whether the provided state matches all equivalent keys on this state.
     *
     * @method includes
     * @param state {platypus.StateMap} The state that this state should match.
     * @return {Boolean} Whether this state matches the provided state.
     */
    Object.defineProperty(proto, 'includes', {
        value: function (otherState) {
            var keys = otherState.keys,
                i = keys.length,
                state = '';
            
            while (i--) {
                state = keys[i];
                if (this.get(state) !== otherState.get(state)) {
                    return false;
                }
            }
            
            return true;
        }
    });
    
    /**
     * Checks whether the provided state matches any equivalent keys on this state.
     *
     * @method intersects
     * @param state {platypus.StateMap} The state that this state should intersect.
     * @return {Boolean} Whether this state intersects the provided state.
     */
    Object.defineProperty(proto, 'intersects', {
        value: function (otherState) {
            var keys = otherState.keys,
                i = keys.length,
                state = '';
            
            while (i--) {
                state = keys[i];
                if (this.get(state) === otherState.get(state)) {
                    return true;
                }
            }
            
            return false;
        }
    });
    
    /**
     * Returns StateMap from cache or creates a new one if none are available.
     *
     * @method StateMap.setUp
     * @return stateMap {platypus.StateMap} The instantiated StateMap.
     */
    /**
     * Returns StateMap back to the cache. Prefer the StateMap's recycle method since it recycles property objects as well.
     *
     * @method StateMap.recycle
     * @param stateMap {platypus.StateMap} The StateMap to be recycled.
     */
    /**
     * Relinquishes StateMap properties and recycles it.
     *
     * @method recycle
     */
    recycle.add(StateMap, !!springroll.Debug, 'StateMap', function () {
        this.clear();
        StateMap.recycle(this);
    });
    
    return StateMap;
}());

//##############################################################################
// Component.js
//##############################################################################

/**
 * This is the extendable Component class. Typically specific component classes should be created using `platypus.createComponentClass()`. This method accepts component definitions and creates component classes that can be used to create components by entities.  It adds properties and methods that are common to all components so that component definitions can focus on unique properties and methods.
 *
 * To create an extended component class, use the following syntax:
 *
 *      platypus.createComponentClass(componentDefinition, prototype);
 *
 *  * `componentDefinition` is list of key/value pairs that describe the component's behavior.
 *  * `prototype` is an optional prototype that this component extends.
 * See [component-template.js]("component-template"%20Component.html) for an example componentDefinition that can be sent into this component class factory.
 *
 * @namespace platypus
 * @class Component
 * @static
 */
/*global include, platypus */
platypus.Component = (function () {
    'use strict';
    
    var Data = include('platypus.Data'),
        getAssetList = function () {
            return Array.setUp();
        },
        Component = function (type, owner) {
            this.type = type;
            this.owner = owner;
            this.publicMethods = Data.setUp();
            this.listener = Data.setUp(
                "events", Array.setUp(),
                "messages", Array.setUp()
            );
        },
        proto = Component.prototype;
    
    /**
     * Returns a string describing the component.
     *
     * @method toString
     * @return {String} Returns the component type as a string of the form "[Component ComponentType]".
     **/
    proto.toString = function () {
        return "[Component " + this.type + "]";
    };

    /**
     * This method cleans up listeners and methods that this component added to the entity. It should never be called by the component itself. Call this.owner.removeComponent(this) instead.
     *
     * @method destroy
     * @private
     */
    proto.destroy = function () {
        var func = '';
        
        if (this.listener) {
            // Handle component's destroy method before removing messaging and methods.
            if (this._destroy) {
                this._destroy();
            }
            
            // Now remove event listeners and methods.
            for (func in this.publicMethods) {
                if (this.publicMethods.hasOwnProperty(func)) {
                    this.removeMethod(func);
                }
            }
            this.publicMethods.recycle();
            
            this.removeEventListeners();
            this.listener.events.recycle();
            this.listener.messages.recycle();
            this.listener.recycle();
            this.listener = null;
        }
    };
    
    /**
     * This method removes multiple event listeners from the entity.
     *
     * @method removeEventListeners
     * @param [listeners] {Array} The list of listeners to remove. If not supplied, all event listeners are removed.
     * @private
     */
    proto.removeEventListeners = function (listeners) {
        var i = 0,
            events   = null,
            messages = null;
        
        if (!listeners) {
            events   = this.listener.events;
            messages = this.listener.messages;
            for (i = 0; i < events.length; i++) {
                this.owner.off(events[i], messages[i]);
            }
            events.length = 0;
            messages.length = 0;
        } else {
            for (i = 0; i < listeners.length; i++) {
                this.removeEventListener(listeners[i]);
            }
        }
    };
    
    /**
     * This method adds an event listener to the entity.
     *
     * @method addEventListener
     * @param event {String} The event that this component should listen for.
     * @param callback {Function} The handler for the event.
     * @private
     */
    proto.addEventListener = function (event, callback, priority) {
        var handler = callback.bind(this);
        
        this.listener.events.push(event);
        this.listener.messages.push(handler);
        this.owner.on(event, handler, priority);
    };
    
    /**
     * This method adds a method to the entity.
     *
     * @method addMethod
     * @param name {String} The name of the method. For example, if name is "turnYellow", the method is accessible on the entity as `entity.turnYellow()`.
     * @param func {Function} The function describing the method.
     * @private
     */
    proto.addMethod = function (name, func) {
        if (this.owner[name]) {
            platypus.debug.warn(this.owner.type + ': Entity already has a method called "' + name + '". Method not added.');
        } else {
            this.owner[name] = function () {
                return func.apply(this, arguments);
            }.bind(this);
            this.publicMethods[name] = func;
        }
    };

    /**
     * This method removes an event listener from the entity.
     *
     * @method removeEventListener
     * @param event {String} The event for which to remove a listener.
     * @param callback {Function} The listener to remove. If not supplied, all event listeners for the provided event are removed.
     * @private
     */
    proto.removeEventListener = function (event, callback) {
        var i = 0,
            events   = this.listener.events,
            messages = this.listener.messages;
        
        for (i = events.length - 1; i >= 0; i--) {
            if ((events[i] === event) && (!callback || (messages[i] === callback))) {
                this.owner.off(event, messages[i]);
                this.listener.events.greenSplice(i);
                this.listener.messages.greenSplice(i);
            }
        }
    };
    
    /**
     * This method removes a method from the entity.
     *
     * @method removeMethod
     * @param name {String} The name of the method to be removed.
     * @private
     */
    proto.removeMethod = function (name) {
        if (!this.owner[name]) {
            platypus.debug.warn(this.owner.type + ': Entity does not have a method called "' + name + '".');
        } else {
            delete this.owner[name];
        }
        delete this.publicMethods[name];
    };

    /**
     * This method can be overwritten to provide the list of assets this component requires. This method is invoked when the list of game scenes is created to determine assets for each scene.
     *
     * @method getAssetList
     * @param definition {Object} The definition for the component.
     * @param properties {Object} The properties of the Entity.
     * @param defaultProperties {Object} The default properties of the Entity.
     * @return {Array} A list of the necessary assets to load.
     */
    Component.getAssetList = getAssetList;

    /**
     * This method can be overwritten to provide the list of assets this component requires. This method is invoked when the list of game scenes is created to determine assets for each scene.
     *
     * @method getLateAssetList
     * @param data {Object} Scene data that affects the list of assets.
     * @return {Array} A list of the necessary assets to load.
     */
    Component.getLateAssetList = getAssetList;
    
    return Component;
}());

//##############################################################################
// Messenger.js
//##############################################################################

/**
 * The Messenger object facilitates communication between components and other game objects. Messenger is currently used by [Entity](platypus.Entity.html) and [EntityContainer](platypus.components.EntityContainer).
 *
 * @namespace platypus
 * @class Messenger
 * @extends springroll.EventDispatcher
 */
/* global extend, include, platypus, springroll, window */
platypus.Messenger = (function () {
    'use strict';

    var EventDispatcher = include('springroll.EventDispatcher'),
        Messenger = function () {
            EventDispatcher.call(this);
            
            this.loopCheck = Array.setUp();
        },
        debug = !!springroll.Debug,
        perfTools = debug && window.performance && window.performance.mark && window.performance.measure && window.performance, // End with this to set perfTools to window.performance
        proto = extend(Messenger, EventDispatcher);
    
    /**
     * Returns a string describing the Messenger as "[Messenger object]".
     *
     * @method toString
     * @return String
     */
    proto.toString = function () {
        return "[Messenger Object]";
    };

    /**
     * This method is used by both internal components and external entities to trigger messages. When triggered, Messenger checks through bound handlers to run as appropriate. This handles multiple event structures: "", [], and {}
     *
     * @method trigger
     * @param event {String|Array|Object} This is the message(s) to process. This can be a string, an object containing an "event" property (and optionally a "message" property, overriding the value below), or an array of the same.
     * @param value {*} This is a message object or other value to pass along to event handler.
     * @param debug {boolean} This flags whether to output message contents and subscriber information to the console during game development. A "value" object parameter (above) will also set this flag if value.debug is set to true.
     * @return {number} The number of handlers for the triggered message.
     */
    proto._trigger = proto.trigger;
    proto.trigger = function (events, message, debug) {
        var args = null,
            i = 0,
            count = 0;
        
        if (typeof events === 'string') {
            return this.triggerEvent.apply(this, arguments);
        } else if (Array.isArray(events)) {
            args = Array.prototype.greenSlice.call(arguments);
            for (i = 0; i < events.length; i++) {
                args[0] = events[i];
                count += this.trigger.apply(this, args);
            }
            args.recycle();
            return count;
        } else if (events.event) {
            return this.triggerEvent(events.event, events.message || message, events.debug || debug);
        } else {
            platypus.debug.warn('Event incorrectly formatted: must be string, array, or object containing an "event" property.', events);
            return 0;
        }
    };
    
    /**
     * This method is used by both internal components and external entities to trigger messages on this entity. When triggered, entity checks through bound handlers to run as appropriate. This method is identical to Spring Roll's [EventDispatcher.trigger](http://springroll.io/SpringRoll/docs/classes/springroll.EventDispatcher.html#method_trigger), but uses alternative Array methods to alleviate excessive GC.
     *
     * @method triggerEvent
     * @param event {String} This is the message to process.
     * @param [value] {*} This is a message object or other value to pass along to event handler.
     * @param [value.debug] {boolean} This flags whether to output message contents and subscriber information to the console during game development.
     * @return {number} The number of handlers for the triggered message.
     */
    proto.triggerEvent = function (type) {
        var count = 0,
            i = 0,
            listener = null,
            listeners = this._listeners,
            args = null;
        
        if (!this._destroyed && listeners.hasOwnProperty(type) && (listeners[type])) {
            // copy the listeners array; reusing `listeners` variable
            listeners = listeners[type].greenSlice();

            if (arguments.length > 1) {
                args = Array.prototype.greenSlice.call(arguments);
                args.greenSplice(0);
            }

            count = i = listeners.length;
            while (i--) {
                listener = listeners[i];
                if (listener._eventDispatcherOnce) {
                    delete listener._eventDispatcherOnce;
                    this.off(type, listener);
                }
                listener.apply(this, args);
            }
            
            if (args) {
                args.recycle();
            }
            listeners.recycle();
        }
        
        return count;
    };
    if (debug) {
        proto._triggerEvent = proto.triggerEvent;
        proto.triggerEvent = function (event, value) {
            var i = 0,
                debugLimit = 5,
                debugLogging = value && value.debug,
                debugCount = 0,
                count = 0;
            
            // Debug logging.
            if (debugLogging || this.debug) {
                for (i = 0; i < this.loopCheck.length; i++) {
                    if (this.loopCheck[i] === event) {
                        debugCount += 1;
                        if (debugCount > debugLimit) {
                            throw "Endless loop detected for '" + event + "'.";
                        } else {
                            platypus.debug.warn("Event '" + event + "' is nested inside another '" + event + "' event.");
                        }
                    }
                }

                this.loopCheck.push(event);
                if (perfTools) {
                    perfTools.mark("a");
                }
                count = this._triggerEvent.apply(this, arguments);
                if (perfTools) {
                    perfTools.mark("b");
                    perfTools.measure(this.type + ":" + event, 'a', 'b');
                }
                this.loopCheck.length = this.loopCheck.length - 1;
                if (debugLogging) {
                    if (count) {
                        platypus.debug.olive('Entity "' + this.type + '": Event "' + event + '" has ' + count + ' subscriber' + ((count > 1) ? 's' : '') + '.', value);
                    } else {
                        platypus.debug.warn('Entity "' + this.type + '": Event "' + event + '" has no subscribers.', value);
                    }
                }
                return count;
            } else {
                return this._triggerEvent.apply(this, arguments);
            }
        };

    }
    
    /**
     * This method returns all the messages that this entity is concerned about.
     *
     * @method getMessageIds
     * @return {Array} An array of strings listing all the messages for which this Messenger has handlers.
     */
    proto.getMessageIds = function () {
        return Object.keys(this._listeners);
    };
    
    /**
     * This method relinguishes Messenger properties
     *
     * @method destroy
     * @since 0.7.1
     */
    proto.eventDispatcherDestroy = proto.destroy;
    proto.destroy = function () {
        this.loopCheck.recycle();
        this.eventDispatcherDestroy();
    };
    
    return Messenger;
}());

//##############################################################################
// Entity.js
//##############################################################################

/**
 * The Entity object acts as a container for components, facilitates communication between components and other game objects, and includes properties set by components to maintain a current state. The entity object serves as the foundation for most of the game objects in the platypus engine.
 *
 * ## JSON Definition Example
     {
         "id": "entity-id",
         // "entity-id" becomes `entity.type` once the entity is created.
      
         "components": [
         // This array lists one or more component definition objects
      
             {"type": "example-component"}
            // The component objects must include a "type" property corresponding to a component to load, but may also include additional properties to customize the component in a particular way for this entity.
         ],
      
         "properties": [
         // This array lists properties that will be attached directly to this entity.
      
             "x": 240
             // For example, `x` becomes `entity.x` on the new entity.
         ],
      
         "filters": {
         // Filters are only used by top level entities loaded by the scene and are not used by the entity directly. They determine whether an entity should be loaded on a particular browser according to browser settings.
      
             "includes": ["touch"],
             // Optional. This filter specifies that this entity should be loaded on browsers/devices that support a touch interface. More than one setting can be added to the array.

             "excludes": ["mobile"]
             // Optional. This filter specifies that this entity should not be loaded on mobile browsers/devices that. More than one setting can be added to the array.
         }
     }
 *
 * @namespace platypus
 * @class Entity
 * @constructor
 * @extends Messenger
 * @param {Object} [definition] Base definition for the entity.
 * @param {Object} [definition.id] This declares the type of entity and will be stored on the Entity as `entity.type` after instantiation.
 * @param {Object} [definition.components] This lists the components that should be attached to this entity.
 * @param {Object} [definition.properties] This is a list of key/value pairs that are added directly to the Entity as `entity.key = value`.
 * @param {Object} [instanceDefinition] Specific instance definition including properties that override the base definition properties.
 * @return {Entity} Returns the new entity made up of the provided components.
**/

/*global include, platypus */
platypus.Entity = (function () {
    'use strict';
    
    var Data = include('platypus.Data'),
        StateMap = include('platypus.StateMap'),
        entityIds = {},
        entity = function (definition, instanceDefinition) {
            var i                    = 0,
                componentDefinition  = null,
                def                  = Data.setUp(definition),
                componentDefinitions = def.components,
                defaultProperties    = Data.setUp(def.properties),
                instance             = Data.setUp(instanceDefinition),
                instanceProperties   = Data.setUp(instance.properties),
                savedEvents          = Array.setUp(),
                savedMessages        = Array.setUp();

            // Set properties of messenger on this entity.
            platypus.Messenger.call(this);

            this.components  = Array.setUp();
            this.type = def.id || 'none';

            this.id = instance.id || instanceProperties.id;
            if (!this.id) {
                if (!entityIds[this.type]) {
                    entityIds[this.type] = 0;
                }
                this.id = this.type + '-' + entityIds[this.type];
                entityIds[this.type] += 1;
            }

            this.setProperty(defaultProperties); // This takes the list of properties in the JSON definition and appends them directly to the object.
            this.setProperty(instanceProperties); // This takes the list of options for this particular instance and appends them directly to the object.
            this.on('set-property', function (keyValuePairs) {
                this.setProperty(keyValuePairs);
            }.bind(this));

            this.state = StateMap.setUp(this.state); //starts with no state information. This expands with boolean value properties entered by various logic components.
            this.lastState = StateMap.setUp(); //This is used to determine if the state of the entity has changed.
            
            this.trigger = this.triggerEvent = function (event, message) {
                savedEvents.push(event);
                savedMessages.push(message);
            };
            
            if (componentDefinitions) {
                for (i = 0; i < componentDefinitions.length; i++) {
                    componentDefinition = componentDefinitions[i];
                    if (componentDefinition) {
                        if (platypus.components[componentDefinition.type]) {
                            this.addComponent(new platypus.components[componentDefinition.type](this, componentDefinition));
                        } else {
                            platypus.debug.warn('Entity "' + this.type + '": Component "' + componentDefinition.type + '" is not defined.', componentDefinition);
                        }
                    }
                }
            }
            
            // Trigger saved events that were being fired during component addition.
            delete this.trigger;
            delete this.triggerEvent;
            for (i = 0; i < savedEvents.length; i++) {
                this.trigger(savedEvents[i], savedMessages[i]);
            }
            savedEvents.recycle();
            savedMessages.recycle();

            /**
             * The entity triggers `load` on itself once all the properties and components have been attached, notifying the components that all their peer components are ready for messages.
             *
             * @event load
             */
            this.triggerEvent('load');

            def.recycle();
            defaultProperties.recycle();
            instance.recycle();
            instanceProperties.recycle();
        },
        proto = entity.prototype = new platypus.Messenger();
    
    /**
    * Returns a string describing the entity.
    *
    * @method toString
    * @return {String} Returns the entity type as a string of the form "[entity entity-type]".
    **/
    proto.toString = function () {
        return "[entity " + this.type + "]";
    };
    
    /**
    * Attaches the provided component to the entity.
    *
    * @method addComponent
    * @param {platypus.Component} component Must be an object that functions as a Component.
    * @return {platypus.Component} Returns the same object that was submitted.
    **/
    proto.addComponent = function (component) {
        this.components.push(component);

        /**
         * The entity triggers `component-added` on itself once a component has been attached, notifying other components of their peer component.
         *
         * @event component-added
         * @param {platypus.Component} component The added component.
         * @param {String} component.type The type of component.
         **/
        this.triggerEvent('component-added', component);
        return component;
    };
    
    /**
    * Removes the mentioned component from the entity.
    *
    * @method removeComponent
    * @param {Component} component Must be a [[Component]] attached to the entity.
    * @return {Component} Returns the same object that was submitted if removal was successful; otherwise returns false (the component was not found attached to the entity).
    **/
    proto.removeComponent = function (component) {
        var i = 0;
        
        /**
         * The entity triggers `component-removed` on itself once a component has been removed, notifying other components of their peer component's removal.
         *
         * @event component-removed
         * @param {Component} component The removed component.
         * @param {String} component.type The type of component.
         **/
        if (typeof component === 'string') {
            for (i = 0; i < this.components.length; i++) {
                if (this.components[i].type === component) {
                    component = this.components[i];
                    this.components.greenSplice(i);
                    this.triggerEvent('component-removed', component);
                    component.destroy();
                    return component;
                }
            }
        } else {
            for (i = 0; i < this.components.length; i++) {
                if (this.components[i] === component) {
                    this.components.greenSplice(i);
                    this.triggerEvent('component-removed', component);
                    component.destroy();
                    return component;
                }
            }
        }
        
        return false;
    };
    
    /**
    * This method sets one or more properties on the entity.
    *
    * @param {Object} properties A list of key/value pairs to set as properties on the entity.
    * @method setProperty
    **/
    proto.setProperty = function (properties) {
        var index = '';
        
        for (index in properties) { // This takes a list of properties and appends them directly to the object.
            if (properties.hasOwnProperty(index)) {
                this[index] = properties[index];
            }
        }
    };
    
    /**
    * This method removes all components from the entity.
    *
    * @method destroy
    **/
    proto.messengerDestroy = proto.destroy;
    proto.destroy = function () {
        var components = this.components,
            i = components.length;
        
        if (!this._destroyed) {
            while (i--) {
                components[i].destroy();
            }
            components.recycle();
            
            this.state.recycle();
            this.state = null;
            
            this.lastState.recycle();
            this.lastState = null;
            
            this.messengerDestroy();
        }
    };
    
    /**
     * Returns all of the assets required for this Entity. This method calls the corresponding method on all components to determine the list of assets.
     *
     * @method getAssetList
     * @param definition {Object} The definition for the Entity.
     * @param properties {Object} Properties for this instance of the Entity.
     * @return {Array} A list of the necessary assets to load.
     */
    entity.getAssetList = function (def, props) {
        var i = 0,
            component = null,
            arr = null,
            assets = null,
            definition = null;
        
        if (def.type) {
            definition = platypus.game.settings.entities[def.type];
            if (!definition) {
                platypus.debug.warn('Entity "' + def.type + '": This entity is not defined.', def);
                return assets;
            }
            return entity.getAssetList(definition, def.properties);
        }
        
        assets = Array.setUp();

        for (i = 0; i < def.components.length; i++) {
            component = def.components[i] && def.components[i].type && platypus.components[def.components[i].type];
            if (component) {
                arr = component.getAssetList(def.components[i], def.properties, props);
                assets.union(arr);
                arr.recycle();
            }
        }
        
        return assets;
    };
    
    /**
     * Returns all of the assets required for this Entity. This method calls the corresponding method on all components to determine the list of assets.
     *
     * @method getLateAssetList
     * @param definition {Object} The definition for the Entity.
     * @param data {Object} Scene data that affects asset list.
     * @return {Array} A list of the necessary assets to load.
     */
    entity.getLateAssetList = function (def, props, data) {
        var i = 0,
            component = null,
            arr = null,
            assets = null;
        
        if (def.type) {
            return entity.getLateAssetList(platypus.game.settings.entities[def.type], props, data);
        }
        
        assets = Array.setUp();

        for (i = 0; i < def.components.length; i++) {
            component = def.components[i] && def.components[i].type && platypus.components[def.components[i].type];
            if (component) {
                arr = component.getLateAssetList(def.components[i], def.properties, props, data);
                assets.union(arr);
                arr.recycle();
            }
        }
        
        return assets;
    };
    
    return entity;
}());

//##############################################################################
// Scene.js
//##############################################################################

/**
 * This class is instantiated by [Game](platypus.Game.html) and contains one or more entities as layers. Each layer [Entity](platypus.Entity.html) handles a unique aspect of the scene. For example, one layer might contain the game world, while another layer contains the game interface. Generally there is only a single scene loaded at any given moment.
 * ## JSON Definition
 *     {
 *         "layers":[
 *         // Required array listing the entities that should be loaded as scene layers. These can be actual entity JSON definitions as shown in Entity or references to entities by using the following specification.
 *
 *             {
 *                 "type": "entity-id",
 *                 // This value maps to an entity definition with a matching "id" value as shown in Entity and will load that definition.
 *
 *                 "properties": {"x": 400}
 *                 // Optional. If properties are passed in this reference, they override the entity definition's properties of the same name.
 *             }
 *         ],
 *
 *         "assets": []
 *         // Optional list of assets this scene requires.
 *     }
 * @namespace platypus
 * @class Scene
 * @constructor
 * @extends springroll.State
 * @param Stage {PIXI.Container} Object where the scene displays layers.
 * @param {Object} [definition] Base definition for the scene, including one or more layers with both properties, filters, and components as shown above under "JSON Definition Example".
 * @param {String} [definition.id] This declares the id of the scene.
 * @param {Array} [definition.layers] This lists the layers that comprise the scene.
 * @param {Array} [definition.assets] This lists the assets that this scene requires.
 * @return {Scene} Returns the new scene made up of the provided layers.
 */
/* global extend, include, platypus */
platypus.Scene = (function () {
    'use strict';
    
    var Application = include('springroll.Application'),
        Data = include('platypus.Data'),
        Entity = include('platypus.Entity'),
        PIXIAnimation = include('platypus.PIXIAnimation'),
        State  = include('springroll.State'),
        fn = /^(?:\w+:\/{2}\w+(?:\.\w+)*\/?)?(?:[\/.]*?(?:[^?]+)?\/)?(?:([^\/?]+)\.(\w+))(?:\?\S*)?$/,
        filterAssets = (function () {
            var isDuplicate = function (id, preload) {
                var j = preload.length;

                while (j--) {
                    if (preload[j].id === id) {
                        return true;
                    }
                }

                return false;
            };

            return function (assets, preload) {
                var asset = null,
                    cache = Application.instance.assetManager.cache._cache,
                    filteredAssets = Array.setUp(),
                    i = assets.length;

                while (i--) {
                    asset = formatAsset(assets[i]);
                    if (cache[asset.id] || isDuplicate(asset.id, preload)) {
                        asset.recycle();
                    } else {
                        filteredAssets.push(asset);
                    }
                }

                return filteredAssets;
            };
        }()),
        formatAsset = function (asset) {
            var match = asset.match(fn),
                a = Data.setUp(
                    'id', asset,
                    'src', asset
                );
            
            //TODO: Make this behavior less opaque.
            if (match) {
                a.id = match[1];
            } else {
                platypus.debug.warn('Scene: A listed asset should provide the entire file path since version 0.9.0.');
            }
            
            return a;
        },
        unloadAssets = function (lateAssets) {
            this.app.unload(lateAssets);
            lateAssets.recycle();
        },
        loadScene = function () {
            var i = 0,
                key = '',
                layers = this.layerDefinitions,
                supportedLayer = true,
                layerDefinition = false,
                properties = null,
                messages = null;

            this.storeMessages = true;
            this.storedMessages = Array.setUp();
            this.layers = Array.setUp();
            for (i = 0; i < layers.length; i++) {
                layerDefinition = layers[i];
                properties = {stage: this.stage, parent: this};
                if (layerDefinition.properties) {
                    for (key in layerDefinition.properties) {
                        if (layerDefinition.properties.hasOwnProperty(key)) {
                            properties[key] = layerDefinition.properties[key];
                        }
                    }
                }

                if (layerDefinition.type) { // this layer should be loaded from an entity definition rather than this instance
                    layerDefinition = platypus.game.settings.entities[layerDefinition.type];
                }

                supportedLayer = true;
                if (layerDefinition.filter) {
                    if (layerDefinition.filter.includes) {
                        supportedLayer = false;
                        for (key in layerDefinition.filter.includes) {
                            if (layerDefinition.filter.includes.hasOwnProperty(key) && platypus.supports[layerDefinition.filter.includes[key]]) {
                                supportedLayer = true;
                            }
                        }
                    }
                    if (layerDefinition.filter.excludes) {
                        for (key in layerDefinition.filter.excludes) {
                            if (layerDefinition.filter.excludes.hasOwnProperty(key) && platypus.supports[layerDefinition.filter.excludes[key]]) {
                                supportedLayer = false;
                            }
                        }
                    }
                }
                if (supportedLayer) {
                    this.layers.push(new platypus.Entity(layerDefinition, {
                        properties: properties
                    }));
                }
            }
            // This allows the layer to gather messages that are triggered as it is loading and deliver them to all the layers once all the layers are in place.
            messages = this.storedMessages;
            this.storeMessages = false;
            for (i = 0; i < messages.length; i++) {
                this.triggerOnChildren(messages[i].message, messages[i].value);
            }
            messages.recycle();
            this.storedMessages = null;

            platypus.debug.olive('Scene loaded: ' + this.id);
            
            /**
             * This event is triggered on the layers once the Scene is finished loading.
             *
             * @event 'scene-loaded'
             * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.
             */
            this.triggerOnChildren('scene-loaded', this.data);
            
            // Go ahead and load base textures to the GPU to prevent intermittent lag later. - DDD 3/18/2016
            PIXIAnimation.preloadBaseTextures(this.app.display.renderer);
        },
        loading = function (definition, assets) {
            var lateAssets = this.getLateAssetList(definition);
            
            if (lateAssets.length) {
                assets.union(lateAssets);
                this.once('exit', unloadAssets.bind(this, lateAssets));
            } else {
                lateAssets.recycle();
            }
        },
        Scene  = function (panel, definition) {
            var assets = null;
            
            State.call(this, panel, definition.options);
            
            assets = this.getAssetList(definition);

            this.id = definition.id;
            this.preload.union(assets);
            this.layerDefinitions = definition.layers;
            this.storeMessages = false;
            this.storedMessages = null;
            this.stage = panel;
            this.layers = null;
            this.assets = definition.assets || null;
            
            // If the scene has dynamically added assets such as level data
            this.on('loading', loading.bind(this, definition));

            // Load scene
            this.on('loaded', loadScene);
            
            assets.recycle();
        },
        proto = extend(Scene, State);
        
    /**
     * Triggers "scene-live" on the Scene layers once the Scene is finished loading and the transition into the Scene has finished.
     *
     * @method enterDone
     */
    proto.enterDone = function () {
        platypus.game.currentScene = this;
        platypus.debug.olive('Scene live: ' + this.id);
        
        /**
         * This event is triggered on the layers once the Scene is finished loading and the transition into the Scene has finished.
         *
         * @event 'scene-live'
         * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.
         */
        this.triggerOnChildren('scene-live', this.data);
    };
    
    /**
     * Triggers 'scene-ended' on the layer.
     *
     * @method exitStart
     */
    proto.exitStart = function () {
        platypus.debug.olive('Scene ending: ' + this.id);
        
        /**
         * This event is triggered on the layers once the Scene is over.
         *
         * @event 'scene-ended'
         * @param data {Object} A list of key-value pairs of data sent into this Scene from the previous Scene.
         * @since 0.7.1
         */
        this.triggerOnChildren('scene-ended', this.data);
    };
    
/**
 * This method is used by external objects to trigger messages on the layers as well as internal entities broadcasting messages across the scope of the scene.
 *
 * @method triggerOnChildren
 * @param {String} eventId This is the message to process.
 * @param {*} event This is a message object or other value to pass along to component functions.
 **/
    proto.triggerOnChildren = function (eventId, event) {
        var i = 0;
        
        if (this.storeMessages) {
            this.storedMessages.push({
                message: eventId,
                value: event
            });
        } else {
            for (i = 0; i < this.layers.length; i++) {
                this.layers[i].trigger(eventId, event);
            }
        }
    };
    
/**
 * This method will return the first entity it finds with a matching id.
 *
 * @method getEntityById
 * @param {string} id The entity id to find.
 * @return {Entity} Returns the entity that matches the specified entity id.
 **/
    proto.getEntityById = function (id) {
        var i = 0,
            selection = null;
        
        for (i = 0; i < this.layers.length; i++) {
            if (this.layers[i].id === id) {
                return this.layers[i];
            }
            if (this.layers[i].getEntityById) {
                selection = this.layers[i].getEntityById(id);
                if (selection) {
                    return selection;
                }
            }
        }
        return null;
    };

/**
 * This method will return all game entities that match the provided type.
 *
 * @method getEntitiesByType
 * @param {String} type The entity type to find.
 * @return entities {Array} Returns the entities that match the specified entity type.
 **/
    proto.getEntitiesByType = function (type) {
        var i = 0,
            selection = null,
            entities  = Array.setUp();
        
        for (i = 0; i < this.layers.length; i++) {
            if (this.layers[i].type === type) {
                entities.push(this.layers[i]);
            }
            if (this.layers[i].getEntitiesByType) {
                selection = this.layers[i].getEntitiesByType(type);
                entities.union(selection);
                selection.recycle();
            }
        }
        return entities;
    };

/**
 * This method destroys all the layers in the scene.
 *
 * @method exit
 **/
    proto.exit = function () {
        var i = 0;
        
        for (i = 0; i < this.layers.length; i++) {
            this.layers[i].destroy();
        }
        this.layers.recycle();
        this.layers = null;
        
        PIXIAnimation.destroyBaseTextures();
        
        platypus.game.currentScene = null;
    };
    
    /**
     * Returns all of the assets required for the Scene. This method calls the corresponding method on all entities to determine the list of assets. It ignores assets that have already been preloaded.
     *
     * @method getAssetList
     * @param definition {Object} The definition for the Scene.
     * @return {Array} A list of the necessary assets to load.
     */
    proto.getAssetList = function (def) {
        var i = 0,
            arr = null,
            assets = Array.setUp();
        
        if (def.assets) {
            assets.union(def.assets);
        }
        
        for (i = 0; i < def.layers.length; i++) {
            arr = Entity.getAssetList(def.layers[i]);
            assets.union(arr);
            arr.recycle();
        }
        
        arr = filterAssets(assets, this.preload);
        assets.recycle();
        
        return arr;
    };
    
    /**
     * Returns all of the dynamic assets required for the Scene.
     *
     * @method getLateAssetList
     * @return {Array} A list of the necessary assets to load.
     */
    proto.getLateAssetList = function (def) {
        var i = 0,
            arr = null,
            assets = Array.setUp();
        
        for (i = 0; i < def.layers.length; i++) {
            arr = Entity.getLateAssetList(def.layers[i], null, this.data);
            assets.union(arr);
            arr.recycle();
        }
        
        arr = filterAssets(assets, this.preload);
        assets.recycle();
        
        return arr;
    };

    return Scene;
}());

//##############################################################################
// Game.js
//##############################################################################

/**
 * This class is used to create the `platypus.game` object and loads the Platypus game as described by the game configuration files.
 *
 * @namespace platypus
 * @class Game
 * @constructor
 * @param definition {Object} Collection of configuration settings, typically from config.json.
 * @param applicationInstance {springroll.Application} The Spring Roll application that the Platypus game is in.
 * @param [onFinishedLoading] {Function} An optional function to run once the game has begun.
 * @return {platypus.Game} Returns the instantiated game.
 */
/* global include, platypus, window */
platypus.Game = (function () {
    'use strict';
    
    var Container      = include('PIXI.Container'),
        Scene          = include('platypus.Scene'),
        XMLHttpRequest = include ('window.XMLHttpRequest'),
        getJSON = function (path, callback) {
            var xhr = new XMLHttpRequest();
            
            xhr.open('GET', path, true);
            xhr.responseType = 'text';
            xhr.onload = function () {
                var obj = null;
                
                if (xhr.status === 200) {
                    try {
                        obj = JSON.parse(xhr.responseText);
                    } catch (e) {
                        platypus.debug.warn('Error parsing "' + path + '": ' + e.message);
                    }
                } else {
                    platypus.debug.warn('Error opening "' + path + '": ' + xhr.description);
                }
                
                callback(obj);
            };
            xhr.send();
        },
        loadJSONLinks = function (obj, callback) {
            var i = 0,
                key = '',
                callbacks = 0,
                resolve = function () {
                    callbacks -= 1;
                    if (!callbacks) {
                        callback(obj);
                    }
                },
                assign = function (obj, i, callback) {
                    loadJSONLinks(obj[i], function (result) {
                        obj[i] = result;
                        callback(result);
                    });
                };
            
            if (obj) {
                if (Array.isArray(obj)) {
                    callbacks = obj.length;
                    if (callbacks) {
                        for (i = 0; i < obj.length; i++) {
                            assign(obj, i, resolve);
                        }
                    } else {
                        callback(obj);
                    }
                    return;
                } else if (typeof obj === 'object') {
                    if (obj.src && (obj.src.length > 5) && (obj.src.substring(obj.src.length - 5).toLowerCase() === '.json')) {
                        loadJSONLinks(obj.src, function (result) {
                            if (obj.src !== result) {
                                obj = result;
                            }
                            callback(obj);
                        });
                    } else {
                        for (key in obj) {
                            if (obj.hasOwnProperty(key)) {
                                callbacks += 1;
                            }
                        }
                        if (callbacks) {
                            for (key in obj) {
                                if (obj.hasOwnProperty(key)) {
                                    assign(obj, key, resolve);
                                }
                            }
                        } else {
                            callback(obj);
                        }
                    }
                    return;
                } else if ((typeof obj === 'string') && (obj.length > 5) && (obj.substring(obj.length - 5).toLowerCase() === '.json')) {
                    getJSON(obj, function (result) {
                        if (typeof result === 'object') {
                            loadJSONLinks(result, callback);
                        } else {
                            callback(result);
                        }
                    });
                    return;
                }
            }
            
            callback(obj);
        },
        game = function (definition, applicationInstance, onFinishedLoading) {
            var
                load = function (settings) {
                    var id = '',
                        scene  = '',
                        states = this.app.states || {};
                    
                    platypus.game = this; //Make this instance the only Game instance.

                    this.currentScene = null;
                    this.settings = settings;
                    this.stage = this.app.display.stage;
                    
                    // Create Game Scenes.
                    for (scene in settings.scenes) {
                        if (settings.scenes.hasOwnProperty(scene)) {
                            id = settings.scenes[scene].id = settings.scenes[scene].id || scene;
                            states[id] = new Scene(new Container(), settings.scenes[scene]);
                        }
                    }
                    
                    if (!this.app.states) {
                        this.app.states = states;
                    }
                    
                    if (onFinishedLoading) {
                        onFinishedLoading(this);
                    }
                    
                    //Add Debug tools
                    window.getEntityById = function (id) {
                        return this.getEntityById(id);
                    }.bind(this);
    
                    window.getEntitiesByType = function (type) {
                        return this.getEntitiesByType(type);
                    }.bind(this);
                    
                    window.getVisibleSprites = function (c, a) {
                        var i = 0;
                        
                        a = a || Array.setUp();
                        c = c || this.stage;
                        
                        if (!c.texture && c.visible) {
                            for (i = 0; i < c.children.length; i++) {
                                window.getVisibleSprites(c.children[i], a);
                            }
                            return a;
                        } else if (c.visible) {
                            a.push(c);
                            return a;
                        }
                        return a;
                    }.bind(this);
                }.bind(this);
            
            if (!definition) {
                platypus.debug.warn('No game definition is supplied. Game not created.');
                return;
            }

            this.app = applicationInstance;
            
            if (typeof definition === 'string') {
                loadJSONLinks(definition, load);
            } else {
                load(definition);
            }
        },
        proto = game.prototype;
        
    /**
    * This method causes the game to tick once. It's called by the SpringRoll Application.
    *
    * @method tick
    * @param tickEvent {Object} Key/value pairs passed on to the current scene.
    * @param tickEvent.delta {number} The time elapsed since the last tick.
    **/
    proto.tick = function (tickEvent) {
        if (this.currentScene) {
            this.currentScene.triggerOnChildren('tick', tickEvent);
        }
    };
    
    /**
    * Loads a scene.
    *
    * @method loadScene
    * @param sceneId {String} The scene to load.
    * @param transition="instant" {String} What type of transition to make. Currently there are: 'fade-to-black', 'crossfade', and 'instant'.
    * @param data {Object} A list of key/value pairs describing options or settings for the loading scene.
    * @param preloading=false {boolean} Whether the scene should appear immediately or just be loaded and not shown.
    **/
    proto.loadScene = (function () {
        var load = function (scene, data) {
            var id = '',
                sceneInstance = null;
            
            if (typeof scene === 'string') {
                this.app.states[scene].data = data; //sets data to send to next scene.
                this.app.manager.state = scene;
            } else {
                id = scene.id = scene.id || "new-scene";
                sceneInstance = new Scene(new Container(), scene);
                sceneInstance.data = data;
                this.app.manager.addState(id, sceneInstance);
                this.stage.addChild(sceneInstance.panel);
                this.app.trigger('stateAdded', id, sceneInstance);
                this.app.manager.state = id;
            }
        };
        
        return function (scene, data) {
            // Delay load so it doesn't end a scene mid-tick.
            window.setTimeout(load.bind(this, scene, data), 1);
        };
    }());
    
    /**
    * This method will return the first entity it finds with a matching id.
    *
    * @method getEntityById
    * @param {string} id The entity id to find.
    * @return {platypus.Entity} Returns the entity that matches the specified entity id.
    **/
    proto.getEntityById = function (id) {
        if (this.currentScene) {
            return this.currentScene.getEntityById(id);
        } else {
            return null;
        }
    };

    /**
    * This method will return all game entities that match the provided type.
    *
    * @method getEntitiesByType
    * @param {String} type The entity type to find.
    * @return entities {Array} Returns the entities that match the specified entity type.
    **/
    proto.getEntitiesByType = function (type) {
        if (this.currentScene) {
            return this.currentScene.getEntitiesByType(type);
        } else {
            return Array.setUp();
        }
    };
    
    /**
    * This method destroys the game.
    *
    * @method destroy
    **/
    proto.destroy = function () {
    };
    
    return game;
}());

//##############################################################################
// Vector.js
//##############################################################################

/**
 * This class defines a multi-dimensional vector object and a variety of methods for manipulating the vector.
 *
 * @namespace platypus
 * @class Vector
 * @constructor
 * @param x {number|Array|Vector} The x coordinate or an array or Vector describing the whole vector.
 * @param [y] {number} The y coordinate.
 * @param [z] {number} The z coordinate.
 */
/*global platypus, recycle, springroll */
platypus.Vector = (function () {
    'use strict';
    
    var Vector = function (x, y, z) {
            if (this.matrix) { // Recycled vectors will already have a matrix array. Resetting x, y, z to 0's to properly handle a set-up array of less than 3 dimensions.
                this.matrix[0] = 0;
                this.matrix[1] = 0;
                this.matrix[2] = 0;
            } else {
                this.matrix = Array.setUp(0, 0, 0);
            }
            this.set(x, y, z);
        },
        proto = Vector.prototype;
    
    /**
     * The x component of the vector.
     *
     * @property x
     * @type number
     * @default 0
     */
    Object.defineProperty(proto, 'x', {
        get: function () {
            return this.matrix[0];
        },
        set: function (value) {
            this.matrix[0] = value;
        }
    });
    
    /**
     * The y component of the vector.
     *
     * @property y
     * @type number
     * @default 0
     */
    Object.defineProperty(proto, 'y', {
        get: function () {
            return this.matrix[1];
        },
        set: function (value) {
            this.matrix[1] = value;
        }
    });
    
    /**
     * The z component of the vector.
     *
     * @property z
     * @type number
     * @default 0
     */
    Object.defineProperty(proto, 'z', {
        get: function () {
            return this.matrix[2];
        },
        set: function (value) {
            this.matrix[2] = value;
        }
    });
    
    /**
     * Returns a string describing the vector in the format of "[x, y, z]".
     *
     * @method toString
     * @return {String}
     */
    proto.toString = function () {
        return '[' + this.matrix.join(',') + ']';
    };
    
    /**
     * Sets the coordinates of the vector.
     *
     * @method set
     * @param x {number|Array|Vector} The x coordinate or an array or Vector describing the whole vector.
     * @param [y] {number} The y coordinate, or if x is an array/Vector this is the number of elements to copy from the array/Vector.
     * @param [z] {number} The z coordinate.
     * @chainable
     */
    proto.set = function (x, y, z) {
        if (x && x.matrix) {                // Passing in a vector.
            return this.setVector(x, y);
        } else if (x && Array.isArray(x)) { // Passing in an array.
            return this.setArray(x, y);
        } else {                            // Passing in coordinates.
            return this.setXYZ(x, y, z);
        }
    };

    /**
     * Sets the coordinates of the vector.
     *
     * @method setXYZ
     * @param x {number} The x coordinate.
     * @param [y] {number} The y coordinate.
     * @param [z] {number} The z coordinate.
     * @chainable
     * @since 0.7.4
     */
    proto.setXYZ = function (x, y, z) {
        var matrix = this.matrix;
        
        matrix[0] = x || 0;
        matrix[1] = y || 0;
        matrix[2] = z || 0;
        
        return this;
    };

    /**
     * Sets the coordinates of the vector.
     *
     * @method setVector
     * @param vector {Vector} The Vector to copy.
     * @param [dimensions] {number} The number of elements to copy from the Vector.
     * @chainable
     * @since 0.7.4
     */
    proto.setVector = function (vector, dimensions) {
        return this.setArray(vector.matrix, dimensions);
    };

    /**
     * Sets the coordinates of the vector.
     *
     * @method setArray
     * @param arr {Array} The array to copy.
     * @param [dimensions] {number} The number of elements to copy from the Array.
     * @chainable
     * @since 0.7.4
     */
    proto.setArray = function (arr, dimensions) {
        var q = dimensions || arr.length,
            matrix = this.matrix;
        
        while (q--) {
            matrix[q] = arr[q];
        }

        return this;
    };

    /**
     * Determines whether two vectors are equal.
     *
     * @method equals
     * @param x {number|Array|Vector} The x coordinate or an array or Vector to check against.
     * @param [y] {number} The y coordinate, or if x is an array/Vector this is the number of dimensions to check from the array/Vector.
     * @param [z] {number} The z coordinate.
     * @return {Boolean} Whether the vectors are equal.
     * @since 0.7.3
     */
    proto.equals = function (x, y, z) {
        var m = null,
            q = 0,
            matrix = this.matrix;
        
        if (x && Array.isArray(x)) {   // Passing in an array.
            q = y || x.length;
            while (q--) {
                if (matrix[q] !== x[q]) {
                    return false;
                }
            }
            return true;
        } else if (x && x.matrix) {   // Passing in a vector.
            m = x.matrix;
            q = y || m.length;
            while (q--) {
                if (matrix[q] !== m[q]) {
                    return false;
                }
            }
            return true;
        } else {                     // Passing in coordinates.
            return ((typeof x === 'number') && (matrix[0] === x)) && ((typeof y !== 'number') || (matrix[1] === y)) && ((typeof z !== 'number') || (matrix[2] === z));
        }
    };
    
    /**
     * Returns the magnitude of the vector.
     *
     * @method magnitude
     * @param [dimensions] {number} The dimensions to include. Defaults to all dimensions.
     * @return {number} The magnitude of the vector.
     */
    proto.magnitude = function (dimensions) {
        var squares = 0,
            x = 0;

        dimensions = dimensions || this.matrix.length;

        for (x = 0; x < dimensions; x++) {
            squares += Math.pow(this.matrix[x], 2);
        }

        return Math.sqrt(squares);
    };
    
    /**
     * Returns the direction of the vector from the z-axis
     *
     * @return {number} The direction of the vector in radians.
     */
    proto.getAngle = function () {
        var mag   = this.magnitude(2),
            angle = 0;

        if (mag !== 0) {
            angle = Math.acos(this.x / mag);
            if (this.y < 0) {
                angle = (Math.PI * 2) - angle;
            }
        }
        return angle;
    };
    
    /**
     * Returns a normalized copy of the vector.
     *
     * @method getUnit
     * @return {platypus.Vector} A normalized vector in the same direction as this vector.
     */
    proto.getUnit = function () {
        return platypus.Vector.setUp(this).normalize();
    };
    
    /**
     * Returns a copy of the Vector inverted.
     *
     * @method getInverse
     * @return {platypus.Vector}
     */
    proto.getInverse = function () {
        return platypus.Vector.setUp(this).multiply(-1);
    };
    
    /**
     * Normalizes the vector.
     *
     * @method normalize
     * @chainable
     */
    proto.normalize = function () {
        var mag = this.magnitude();
        
        if (mag === 0) {
            // Ignores attempt to normalize a vector of zero magnitude.
            return this;
        } else {
            return this.multiply(1 / mag);
        }
    };
    
    /**
     * Crosses this vector with the parameter vector.
     *
     * @method cross
     * @param vector {platypus.Vector} The vector to cross this vector with.
     * @chainable
     */
    proto.cross = (function () {
        var det = function (a, b, c, d) {
            return a * d - b * c;
        };
        
        return function (v) {
            var tempX = det(this.y, this.z, v.y, v.z),
                tempY = -det(this.x, this.z, v.x, v.z),
                tempZ = det(this.x, this.y, v.x, v.y);
            
            this.x = tempX;
            this.y = tempY;
            this.z = tempZ;
            
            return this;
        };
    }());
    
    /**
     * Crosses this vector with the parameter vector and returns the cross product.
     *
     * @method getCrossProduct
     * @param vector {platypus.Vector} The vector to cross this vector with.
     * @return {platypus.Vector} The cross product.
     */
    proto.getCrossProduct = function (v) {
        return platypus.Vector.setUp(this).cross(v);
    };
    
    /**
     * Rotates the vector by the given amount.
     *
     * @method rotate
     * @param angle {number} The amount to rotate the vector in radians.
     * @param [axis="z"] {String|Vector} A vector describing the axis around which the rotation should occur or 'x', 'y', or 'z'.
     * @chainable
     */
    proto.rotate = function (angle, axis) {
        var a    = axis,
            arr  = null,
            cos  = Math.cos(angle),
            sin  = Math.sin(angle),
            icos = 1 - cos,
            x    = 0,
            y    = 0,
            z    = 0,
            temp = platypus.Vector.setUp();
        
        if (a) {
            if (a === 'x') {
                a = temp.setXYZ(1, 0, 0);
            } else if (a === 'y') {
                a = temp.setXYZ(0, 1, 0);
            } else if (a === 'z') {
                a = temp.setXYZ(0, 0, 1);
            }
        } else {
            a = temp.setXYZ(0, 0, 1);
        }
        
        x     = a.x;
        y     = a.y;
        z     = a.z;
        
        arr = Array.setUp(
            Array.setUp(    cos + x * x * icos, x * y * icos - z * sin, x * z * icos + y * sin),
            Array.setUp(y * x * icos + z * sin,     cos + y * y * icos, y * z * icos - x * sin),
            Array.setUp(z * x * icos - y * sin, z * y * icos + x * sin,     cos + z * z * icos)
        );
        
        this.multiply(arr);
        
        temp.recycle();
        arr.recycle(2);
        
        return this;
    };
    
    /**
     * Scales the vector by the given factor or performs a transform if a matrix is provided.
     *
     * @method multiply
     * @param multiplier {number|Array} The factor to scale by or a 2D array describing a multiplication matrix.
     * @param limit {number} For scaling, determines which coordinates are affected.
     * @chainable
     */
    proto.multiply = function (multiplier, limit) {
        var i = 0,
            j = 0,
            arr = null,
            l = 0;
        
        if (Array.isArray(multiplier)) {
            arr = this.matrix.greenSlice();
            l = limit || multiplier.length;
            for (i = 0; i < l; i++) {
                this.matrix[i] = 0;
                for (j = 0; j < l; j++) {
                    this.matrix[i] += arr[j] * multiplier[i][j];
                }
            }
            arr.recycle();
        } else {
            l = limit || this.matrix.length;
            for (i = 0; i < l; i++) {
                this.matrix[i] *= multiplier;
            }
        }
        
        return this;
    };
    
    /**
     * Adds the given components to this vector.
     *
     * @method add
     * @param x {number|Array|Vector} The x component to add, or an array or vector describing the whole addition.
     * @param [y] {number} The y component to add or the limit if the first parameter is a vector or array.
     * @param [z] {number} The z component to add.
     * @chainable
     */
    proto.add = function (x, y, z) {
        var addMatrix = x,
            limit = 0,
            q = 0;

        if (!Array.isArray(addMatrix)) {
            if (addMatrix instanceof Vector) {
                addMatrix = addMatrix.matrix;
                limit = y || this.matrix.length;
            } else {
                addMatrix = [x || 0, y || 0, z || 0];
                limit = this.matrix.length;
            }
        } else {
            limit = y || this.matrix.length;
        }
        
        for (q = 0; q < limit; q++) {
            this.matrix[q] += addMatrix[q];
        }
        
        return this;
    };
    
    /**
     * Adds the given vector to this vector.
     *
     * @method addVector
     * @param otherVector {platypus.Vector} The vector to add.
     * @chainable
     */
    proto.addVector = function (otherVector, dimensions) {
        return this.add(otherVector, dimensions);
    };
    
    /**
     * Subtracts the given vector from this vector.
     *
     * @method subtractVector
     * @param otherVector {platypus.Vector} The vector to subtract.
     * @chainable
     */
    proto.subtractVector = function (otherVector, dimensions) {
        return this.add(otherVector.getInverse(), dimensions);
    };
    
    /**
     * Scales the vector by the given factor.
     *
     * @method multiply
     * @param factor {number} The factor to scale by.
     * @param limit {number} Determines which coordinates are affected. Defaults to all coordinates.
     * @chainable
     */
    proto.scale = function (factor, limit) {
        return this.multiply(factor, limit);
    };
    
    /**
     * Finds the dot product of the two vectors.
     *
     * @method dot
     * @param otherVector {platypus.Vector} The other vector.
     * @param limit {number} The number of vector indexes to include in the dot product.
     * @return {number} The dot product.
     */
    proto.dot = function (otherVector, limit) {
        var sum = 0,
            q = 0,
            m = this.matrix,
            oM = otherVector.matrix;
            
        q = limit || m.length;
        
        while (q--) {
            sum += m[q] * (oM[q] || 0);
        }
        
        return sum;
    };
    
    /**
     * Finds the shortest angle between the two vectors.
     *
     * @method angleTo
     * @param otherVector {platypus.Vector} The other vector.
     * @return {number} The angle between this vector and the received vector.
     */
    proto.angleTo = function (otherVector) {
        var v1 = this.getUnit(),
            v2 = otherVector.getUnit(),
            ang = 0;
            
        if (v1.magnitude() && v2.magnitude()) { // Probably want a less expensive check here for zero-length vectors.
            ang = Math.acos(v1.dot(v2));
        } else {
            platypus.debug.warn('Vector: Attempted to find the angle of a zero-length vector.');
            ang = NaN;
        }
            
        v1.recycle();
        v2.recycle();
        
        return ang;
    };
    
    /**
     * Finds the shortest signed angle between the two vectors.
     *
     * @method signedAngleTo
     * @param otherVector {platypus.Vector} The other vector.
     * @param normal {platypus.Vector} A normal vector determining the resultant sign of the angle between two vectors.
     * @return {number} The angle between this vector and the received vector.
     */
    proto.signedAngleTo = function (otherVector, normal) {
        var v1 = this.getUnit(),
            v2 = otherVector.getUnit(),
            v3 = v1.getCrossProduct(v2),
            ang = 0;
        
        if (v3.dot(normal) < 0) {
            ang = -Math.acos(v1.dot(v2));
        } else {
            ang =  Math.acos(v1.dot(v2));
        }
        
        v1.recycle();
        v2.recycle();
        v3.recycle();
        
        return ang;
    };
    
    /**
     * Find the scalar value of projecting this vector onto the parameter vector or onto a vector at the specified angle away.
     *
     * @method scalerProjection
     * @param vectorOrAngle {Vector|number} The other vector or the angle between the vectors.
     * @return {number} The magnitude of the projection.
     */
    proto.scalarProjection = function (vectorOrAngle) {
        var v = null,
            d = 0;
        
        if (typeof vectorOrAngle === "number") {
            return this.magnitude(2) * Math.cos(vectorOrAngle);
        } else {
            v = Vector.setUp(vectorOrAngle).normalize();
            d = this.dot(v);
            v.recycle();
            return d;
        }
    };
    
    /**
     * Returns a copy of this vector.
     *
     * @method copy
     * @return {platypus.Vector} A copy of this vector.
     */
    proto.copy = function () {
        return platypus.Vector.setUp(this);
    };
    
    /**
     * Adds properties to an object that describe the coordinates of a vector.
     *
     * @method Vector.assign
     * @param object {Object} Object on which the coordinates and vector will be added.
     * @param propertyName {String} A string describing the property name where the vector is accessable.
     * @param [coordinateName*] {String} One or more parameters describing coordinate values on the object.
     */
    Vector.assign = (function () {
        var createProperty = function (property, obj, vector, index) {
            var temp = null,
                propertyInUse = false;
            
            if (typeof property === 'string') {
                if (typeof obj[property] !== 'undefined') {
                    temp = obj[property];
                    delete obj[property];
                    propertyInUse = true;
                }
            }
            
            Object.defineProperty(obj, property, {
                get: function () {
                    return vector.matrix[index];
                },
                set: function (value) {
                    vector.matrix[index] = value;
                },
                enumerable: true
            });
            
            if (propertyInUse) {
                obj[property] = temp;
            }
        };
        
        return function (obj, prop) {
            var i = 0;

            if (obj && prop) {
                if (!obj[prop]) {
                    obj[prop] = platypus.Vector.setUp();
                    
                    for (i = 2; i < arguments.length; i++) {
                        if (arguments[i] !== prop) {
                            createProperty(arguments[i], obj, obj[prop], i - 2);
                        }
                    }
                    
                    return null;
                }
                return obj[prop];
            } else {
                return null;
            }
        };
    }());

    /**
     * Returns a Vector from cache or creates a new one if none are available.
     *
     * @method Vector.setUp
     * @return {platypus.Vector} The instantiated Vector.
     * @since 0.7.1
     */
    /**
     * Returns a Vector back to the cache. Prefer the Vector's recycle method since it recycles property objects as well.
     *
     * @method Vector.recycle
     * @param {platypus.Vector} The Vector to be recycled.
     * @since 0.7.1
     */
    /**
     * Relinquishes properties of the vector and recycles it.
     *
     * @method recycle
     * @since 0.7.1
     */
    recycle.add(Vector, !!springroll.Debug, 'Vector', function () {
        this.matrix.length = 0;
        Vector.recycle(this);
    });
    
    return Vector;
}());

//##############################################################################
// AABB.js
//##############################################################################

/**
 * This class defines an axis-aligned bounding box (AABB) which is used during the collision process to determine if two objects are colliding. This is used in a few places including [CollisionBasic](platypus.components.CollisionBasic.html) and [[Collision-Shape]].
 *
 * @namespace platypus
 * @class AABB
 * @constructor
 * @param x {number} The x position of the AABB. The x is always located in the center of the object.
 * @param y {number} The y position of the AABB. The y is always located in the center of the object.
 * @param width {number} The width of the AABB.
 * @param height {number} The height of the AABB.
 * @return {platypus.AABB} Returns the new aabb object.
 */
/*global platypus, recycle, springroll */
platypus.AABB = (function () {
    'use strict';
    
    var AABB = function (x, y, width, height) {
            if (x instanceof AABB) {
                this.set(x);
            } else {
                this.empty = true;
                this.setAll(x, y, width, height);
            }
        },
        proto = AABB.prototype;
    
    /**
     * Sets all of the properties of the AABB.
     *
     * @method setAll
     * @param x {number} The x position of the AABB. The x is always located in the center of the object.
     * @param y {number} The y position of the AABB. The y is always located in the center of the object.
     * @param width {number} The width of the AABB.
     * @param height {number} The height of the AABB.
     * @chainable
     */
    proto.setAll = function (x, y, width, height) {
        this.empty = false;
        this.x = x;
        this.y = y;
        this.resize(width, height);
        return this;
    };
    
    /**
     * Sets bounds of the AABB.
     *
     * @method setBounds
     * @param left {number} The left side of the AABB.
     * @param top {number} The top side of the AABB.
     * @param right {number} The right side of the AABB.
     * @param bottom {number} The bottom side of the AABB.
     * @chainable
     */
    proto.setBounds = function (left, top, right, bottom) {
        this.empty = false;
        this.x = (right + left) / 2;
        this.y = (top + bottom) / 2;
        this.resize(right - left, bottom - top);
        return this;
    };
    
    proto.set = function (aabb) {
        /**
         * Whether the AABB encloses a valid space.
         *
         * @property empty
         * @type boolean
         */
        this.empty = aabb.empty;
        
        /**
         * The x position of the AABB. The x is always located in the center of the object.
         *
         * @property x
         * @type number
         */
        this.x = aabb.x;
        
        /**
         * The y position of the AABB. The y is always located in the center of the object.
         *
         * @property y
         * @type number
         */
        this.y = aabb.y;
        
        /**
         * The width of the AABB.
         *
         * @property width
         * @type number
         */
        this.width  = aabb.width;
        
        /**
         * The height of the AABB.
         *
         * @property height
         * @type number
         */
        this.height = aabb.height;
        
        /**
         * Half the width of the AABB.
         *
         * @property halfWidth
         * @type number
         */
        this.halfWidth = aabb.halfWidth;
        
        /**
         * Half the height of the AABB.
         *
         * @property halfHeight
         * @type number
         */
        this.halfHeight = aabb.halfHeight;
        
        /**
         * The x-position of the left edge of the AABB.
         *
         * @property left
         * @type number
         */
        this.left = aabb.left;
        
        /**
         * The x-position of the right edge of the AABB.
         *
         * @property right
         * @type number
         */
        this.right = aabb.right;
        
        /**
         * The y-position of the top edge of the AABB.
         *
         * @property top
         * @type number
         */
        this.top = aabb.top;
        
        /**
         * The y-position of the bottom edge of the AABB.
         *
         * @property bottom
         * @type number
         */
        this.bottom = aabb.bottom;
        
        return this;
    };
    
    /**
     * Resets all the values in the AABB so that the AABB can be reused.
     *
     * @method reset
     * @chainable
     */
    proto.reset = function () {
        this.empty = true;
        return this;
    };
    
    /**
     * Resizes the AABB.
     *
     * @method reset
     * @param width {number} The new width of the AABB
     * @param height {number} The new height of the AABB
     * @chainable
     */
    proto.resize = function (width, height) {
        var w = width || 0,
            h = height || 0,
            hw = w / 2,
            hh = h / 2;
        
        this.width  = w;
        this.height = h;
        this.halfWidth = hw;
        this.halfHeight = hh;
        if (typeof this.x === 'number') {
            this.left = -hw + this.x;
            this.right = hw + this.x;
        } else {
            this.empty = true;
        }
        if (typeof this.y === 'number') {
            this.top = -hh + this.y;
            this.bottom = hh + this.y;
        } else {
            this.empty = true;
        }
        return this;
    };
    
    /**
     * Changes the size and position of the bounding box so that it contains the current area and the area described in the incoming AABB.
     *
     * @method include
     * @param aabb {platypus.AABB} The AABB whose area will be included in the area of the current AABB.
     * @chainable
     */
    proto.include = function (aabb) {
        if (this.empty) {
            this.set(aabb);
        } else {
            if (this.left > aabb.left) {
                this.left = aabb.left;
            }
            if (this.right < aabb.right) {
                this.right = aabb.right;
            }
            if (this.top > aabb.top) {
                this.top = aabb.top;
            }
            if (this.bottom < aabb.bottom) {
                this.bottom = aabb.bottom;
            }
            
            this.width      = this.right  - this.left;
            this.height     = this.bottom - this.top;
            this.halfWidth  = this.width / 2;
            this.halfHeight = this.height / 2;
            this.x          = this.left + this.halfWidth;
            this.y          = this.top  + this.halfHeight;
        }
        
        return this;
    };
    
    /**
     * Moves the AABB to the specified location.
     *
     * @method move
     * @param x {number} The new x position of the AABB.
     * @param y {number} The new y position of the AABB.
     * @chainable
     */
    proto.move = function (x, y) {
        this.moveX(x);
        this.moveY(y);
        return this;
    };

    /**
     * Moves the AABB to the specified location.
     *
     * @method moveX
     * @param x {number} The new x position of the AABB.
     * @chainable
     */
    proto.moveX = function (x) {
        this.x = x;
        this.left   = -this.halfWidth + x;
        this.right  = this.halfWidth + x;
        return this;
    };

    /**
     * Moves the AABB to the specified location.
     *
     * @method moveY
     * @param y {number} The new y position of the AABB.
     * @chainable
     */
    proto.moveY = function (y) {
        this.y = y;
        this.top    = -this.halfHeight + y;
        this.bottom = this.halfHeight + y;
        return this;
    };
    
    /**
     * Moves the AABB to the specified location.
     *
     * @method moveXBy
     * @param deltaX {number} The change in x position of the AABB.
     * @chainable
     */
    proto.moveXBy = function (deltaX) {
        return this.moveX(this.x + deltaX);
    };

    /**
     * Moves the AABB to the specified location.
     *
     * @method moveYBy
     * @param deltaY {number} The change in y position of the AABB.
     * @chainable
     */
    proto.moveYBy = function (deltaY) {
        return this.moveY(this.y + deltaY);
    };

    /**
     * Expresses whether this AABB matches the provided AABB.
     *
     * @method equals
     * @param aabb {platypus.AABB} The AABB to check against.
     * @return {Boolean} Returns `true` if the AABB's match.
     * @since 0.7.5
     */
    proto.equals = function (aabb) {
        return !this.empty && !aabb.empty && (this.left === aabb.left) && (this.top === aabb.top) && (this.right === aabb.right) && (this.bottom === aabb.bottom);
    };

    /**
     * Expresses whether this AABB contains the given AABB.
     *
     * @method contains
     * @param aabb {platypus.AABB} The AABB to check against
     * @return {boolean} Returns `true` if this AABB contains the other AABB.
     */
    proto.contains = function (aabb) {
        return (aabb.top >= this.top) && (aabb.bottom <= this.bottom) && (aabb.left >= this.left) && (aabb.right <= this.right);
    };
    
    /**
     * Expresses whether this AABB contains the given point.
     *
     * @method containsVector
     * @param vector {platypus.Vector} The vector to check.
     * @return {boolean} Returns `true` if this AABB contains the vector.
     */
    proto.containsVector = function (vector) {
        return this.containsPoint(vector.x, vector.y);
    };
    
    /**
     * Expresses whether this AABB contains the given point.
     *
     * @method containsVector
     * @param vector {platypus.Vector} The vector to check.
     * @return {boolean} Returns `true` if this AABB contains the vector.
     * @since 0.7.5
     */
    proto.containsPoint = function (x, y) {
        return (y >= this.top) && (y <= this.bottom) && (x >= this.left) && (x <= this.right);
    };
    
    /**
     * Expresses whether this AABB collides with the given AABB. This is similar to `intersects` but returns true for overlapping or touching edges.
     *
     * @method collides
     * @param aabb {platypus.AABB} The AABB to check against
     * @return {boolean} Returns `true` if this AABB collides with the other AABB.
     * @since 0.7.4
     */
    proto.collides = function (aabb) {
        return (aabb.bottom > this.top) && (aabb.top < this.bottom) && (aabb.right > this.left) && (aabb.left < this.right);
    };

    /**
     * Expresses whether this AABB intersects the given AABB. This is similar to `collides` but returns true for overlapping only, not touching edges.
     *
     * @method intersects
     * @param aabb {platypus.AABB} The AABB to check against
     * @return {boolean} Returns `true` if this AABB intersects the other AABB.
     */
    proto.intersects = function (aabb) {
        return (aabb.bottom >= this.top) && (aabb.top <= this.bottom) && (aabb.right >= this.left) && (aabb.left <= this.right);
    };

    /**
     * Returns the area of the intersection. If the AABB's do not intersect, `0` is returned.
     *
     * @method getIntersectionArea
     * @param aabb {AABB} The AABB this AABB intersects with.
     * @return {Number} Returns the area of the intersected AABB's.
     */
    proto.getIntersectionArea = function (aabb) {
        var max    = Math.max,
            min    = Math.min;
        
        if (this.intersects(aabb)) {
            return (min(this.bottom, aabb.bottom) - max(this.top,  aabb.top)) * (min(this.right,  aabb.right) - max(this.left, aabb.left));
        } else {
            return 0;
        }
    };
    
    /**
     * Returns an AABB from cache or creates a new one if none are available.
     *
     * @method AABB.setUp
     * @return {platypus.AABB} The instantiated AABB.
     * @since 0.7.3
     */
    /**
     * Returns a AABB back to the cache.
     *
     * @method AABB.recycle
     * @param aabb {platypus.AABB} The AABB to be recycled.
     * @since 0.7.3
     */
    /**
     * Relinquishes properties of the AABB and recycles it.
     *
     * @method recycle
     * @since 0.7.3
     */
    recycle.add(AABB, !!springroll.Debug, 'AABB');
    
    return AABB;
}());

//##############################################################################
// ActionState.js
//##############################################################################

/**
 * This class defines an action state based on one or more inputs. This is used by [EntityController](platypus.components.EntityController.html) to produce event messages listing whether a particular action is "triggered", "pressed", and/or "released".
 *
 * @namespace platypus
 * @class ActionState
 * @constructor
 * @param event {String} The name of the event to trigger on the Entity.
 * @param states {Object} A list of key/value pairs describing what states should be `true` or `false` on the Entity for this action to be triggered.
 * @param trigger {Function} The function to be called if one or more inputs are active and the current state of the Entity is valid.
 * @return {ActionState} Returns the new ActionState object.
 * @since 0.6.8
 */
/*global include, platypus, recycle, springroll */
platypus.ActionState = (function () {
    'use strict';
    
    var Data = include('platypus.Data'),
        StateMap = include('platypus.StateMap'),
        ActionState = function (event, states, trigger) {
            /**
             * The name of the event to trigger on the Entity.
             *
             * @property event
             * @type String
             */
            this.event     = event;

            /**
             * The function to call if the ActionState is active.
             *
             * @property trigger
             * @type Function
             */
            this.trigger   = trigger;
            
            /**
             * Whether any of the ActionState's inputs are active.
             *
             * @property active
             * @type Boolean
             */
            this.active    = false;

            /**
             * Whether any of the ActionState's inputs were active last update.
             *
             * @property wasActive
             * @type Boolean
             */
            this.wasActive = false;

            /**
             * Whether the Entity's state is valid for this ActionState.
             *
             * @property valid
             * @type Boolean
             */
            this.valid     = true;

            /**
             * Whether the Entity's state was valid for this ActionState last update.
             *
             * @property wasValid
             * @type Boolean
             */
            this.wasValid  = true;

            /**
             * The state of the Entity that is valid for this ActionState.
             *
             * @property states
             * @type platypus.StateMap
             */
            this.states = StateMap.setUp(states);

            /**
             * The list of input toggles to track control input.
             *
             * @property inputs
             * @type Array
             */
            this.inputs = Array.setUp();

            /**
             * The message that is passed to the Entity if the ActionState is active.
             *
             * @property stateSummary
             * @type platypus.Data
             */
            this.stateSummary = Data.setUp(
                "pressed",   false,
                "released",  false,
                "triggered", false
            );
        },
        orArray = function (element) {
            return element;
        },
        proto = ActionState.prototype;

    /**
     * Updates the state of the action by checking the state of the Entity and whether any inputs are active.
     *
     * @method update
     * @param state {Object} The Entity's `state` property to compare against the ActionState's valid state.
     * @return {Boolean} Whether the ActionState is triggered, pressed, or released.
     */
    proto.update = function (state) {
        var ss = this.stateSummary;
        
        this.valid     = state.includes(this.states);
        this.active    = this.inputs.some(orArray);
        
        ss.pressed     = this.valid && this.active;
        ss.released    = this.wasActive && ((!this.valid && this.wasValid) || (this.valid && !this.active));
        ss.triggered   = this.valid && this.active && !this.wasActive;
        
        this.wasValid  = this.valid;
        this.wasActive = this.active;
        
        return ss.pressed || ss.released || ss.triggered;
    };
    
    /**
     * Triggers events on the Entity related to the ActionState's state. This is necessarily separate from the `update` method since triggered events could affect entity state. The messages have the following form and are only triggered if one of the values is `true`:
     *
     *     {
     *         "triggered": true,
     *         "pressed": true,
     *         "released": false
     *     }
     *
     * Here is a mapping of the various event messages depending on the ActionState's state.
     *
     *     ActionState State:
     *          wasValid:  0 0 0 0  0 0 0 0  1 1 1 1  1 1 1 1
     *             valid:  0 0 0 0  1 1 1 1  0 0 0 0  1 1 1 1
     *         wasActive:  0 0 1 1  0 0 1 1  0 0 1 1  0 0 1 1
     *            active:  0 1 0 1  0 1 0 1  0 1 0 1  0 1 0 1
     *     Events:
     *         triggered:  0 0 0 0  0 1 0 0  0 0 0 0  0 1 0 0
     *           pressed:  0 0 0 0  0 1 0 1  0 0 0 0  0 1 0 1
     *          released:  0 0 0 0  0 0 1 0  0 0 1 1  0 0 1 0
     *
     * @method resolve
     */
    proto.resolve = function () {
        this.trigger(this.event, this.stateSummary);
    };
    
    /**
     * Returns an ActionState from cache or creates a new one if none are available.
     *
     * @method ActionState.setUp
     * @return {platypus.ActionState} The instantiated ActionState.
     * @since 0.7.1
     */
    /**
     * Returns an ActionState back to the cache. Prefer the ActionState's recycle method since it recycles property objects as well.
     *
     * @method ActionState.recycle
     * @param {platypus.ActionState} The ActionState to be recycled.
     * @since 0.7.1
     */
    /**
     * Relinquishes properties of the ActionState and recycles it.
     *
     * @method recycle
     * @since 0.7.1
     */
    recycle.add(ActionState, !!springroll.Debug, 'ActionState', function () {
        this.states.recycle();
        this.stateSummary.recycle();
        this.inputs.recycle();
        ActionState.recycle(this);
    });

    return ActionState;
}());

//##############################################################################
// CollisionData.js
//##############################################################################

/**
 * CollisionData holds collision data passed to entities during collisions with other entities. This class is primarily used by the ["HandlerCollision"]("HandlerCollision"%20Component.html) Component to trigger messages on child entities as collision occur.
 *
 * @namespace platypus
 * @class CollisionData
 * @constructor
 * @param occurredOrData {Boolean|CollisionData} Whether this represents an actual collision between two shapes. If a CollisionData instance is provided, the instance's full set of values are copied.
 * @param direction {Number} 1 or -1 to define the direction of the collision.
 * @param position {Number} A positive number describing position along the line of collision direction.
 * @param deltaMovement {Number} A positive number describing the magnitude of overlap.
 * @param aABB {platypus.AABB} An AABB of the colliding shape.
 * @param thisShape {platypus.Shape} The moving shape.
 * @param thatShape {platypus.Shape} The stationary shape being collided with.
 * @param vector {platypus.Vector} The vector describing the contact point.
 * @param stuck {Number} The amount of unwarranted overlap if shapes start in a collided position before moving.
 * @return {platypus.CollisionData} Returns the new CollisionData object.
 */
/*global include, platypus, recycle, springroll */
platypus.CollisionData = (function () {
    'use strict';
    
    var Vector = include('platypus.Vector'),
        CollisionData = function (occurredOrData) {
            if (!this.vector) {
                this.vector = Vector.setUp();
            }
            if (occurredOrData instanceof CollisionData) {
                this.copy(occurredOrData);
            } else {
                this.set.apply(this, arguments);
            }
        },
        proto = CollisionData.prototype;
    
    /**
     * Sets all of the properties of the CollisionData.
     *
     * @method set
     * @param occurred {Boolean} Whether this represents an actual collision between two shapes.
     * @param direction {Number} 1 or -1 to define the direction of the collision.
     * @param position {Number} A positive number describing position along the line of collision direction.
     * @param deltaMovement {Number} A positive number describing the magnitude of overlap.
     * @param aABB {platypus.AABB} An AABB of the colliding shape.
     * @param thisShape {platypus.Shape} The moving shape.
     * @param thatShape {platypus.Shape} The stationary shape being collided with.
     * @param vector {platypus.Vector} The vector describing the contact point.
     * @param stuck {Number} The amount of unwarranted overlap if shapes start in a collided position before moving.
     * @since 0.8.7
     */
    proto.set = function (occurred, direction, position, deltaMovement, aABB, thisShape, thatShape, vector, stuck) {
        this.occurred = occurred || false;
        this.direction = direction || null;
        this.position = position || null;
        this.deltaMovement = deltaMovement || null;
        this.aABB = aABB || null;
        this.thisShape = thisShape || null;
        this.thatShape = thatShape || null;
        this.vector.set(vector);
        this.stuck  = stuck || 0;
    };

    /**
     * Sets all of the properties of the CollisionData to match those of the provided CollisionData object.
     *
     * @method copy
     * @param dataToCopy {CollisionData} The object values to copy.
     */
    proto.copy = function (dataToCopy) {
        this.occurred         = dataToCopy.occurred;
        this.direction         = dataToCopy.direction;
        this.position         = dataToCopy.position;
        this.deltaMovement     = dataToCopy.deltaMovement;
        this.aABB             = dataToCopy.aABB;
        this.thisShape      = dataToCopy.thisShape;
        this.thatShape      = dataToCopy.thatShape;
        this.vector.setVector(dataToCopy.vector);
        this.stuck          = dataToCopy.stuck;
    };

    /**
     * Returns an collisionData from cache or creates a new one if none are available.
     *
     * @method CollisionData.setUp
     * @return {platypus.CollisionData} The instantiated CollisionData.
     * @since 0.8.7
     */
    /**
     * Returns a collisionData back to the cache.
     *
     * @method CollisionData.recycle
     * @param collisionData {platypus.CollisionData} The collisionData to be recycled.
     * @since 0.8.7
     */
    /**
     * Relinquishes properties of the collisionData and recycles it.
     *
     * @method recycle
     * @since 0.8.7
     */
    recycle.add(CollisionData, !!springroll.Debug, 'CollisionData');
    
    return CollisionData;
}());

//##############################################################################
// CollisionDataContainer.js
//##############################################################################

/**
 * CollisionDataContainer holds lists of CollisionData passed to entities during collisions with other entities. This class is primarily used by the ["HandlerCollision"]("HandlerCollision"%20Component.html) Component to trigger messages on child entities as collisions occur.
 *
 * @namespace platypus
 * @class CollisionDataContainer
 * @constructor
 * @return {platypus.CollisionDataContainer} Returns the new aabb object.
 */
/* global platypus, recycle, springroll */
platypus.CollisionDataContainer = (function () {
    'use strict';
    
    var CollisionDataContainer = function () {
            if (!this.xData && !this.yData) {
                this.xData = Array.setUp();
                this.yData = Array.setUp();
                this.xDeltaMovement = Infinity;
                this.yDeltaMovement = Infinity;
            } else {
                this.reset();
            }
        },
        proto = CollisionDataContainer.prototype;
    
    // deprecated since 0.8.7
    proto.getXEntry = function (index) {
        return this.xData[index];
    };
    
    // deprecated since 0.8.7
    proto.getYEntry = function (index) {
        return this.yData[index];
    };
    
    /**
     * Adds a CollisionData object to the container's X-axis if the movement distance is less than or equal to collision data collected so far.
     *
     * @method tryToAddX
     * @param collisionData {platypus.CollisionData} The collision data to add.
     * @return {Boolean} Whether the collision data was added.
     */
    proto.tryToAddX = function (collisionData) {
        if (collisionData.deltaMovement > this.xDeltaMovement) {
            return false;
        } else if (collisionData.deltaMovement < this.xDeltaMovement) {
            this.resetX(collisionData.deltaMovement);
        }

        this.xData.push(collisionData);

        return true;
    };
    
    /**
     * Adds a CollisionData object to the container's Y-axis if the movement distance is less than or equal to collision data collected so far.
     *
     * @method tryToAddY
     * @param collisionData {platypus.CollisionData} The collision data to add.
     * @return {Boolean} Whether the collision data was added.
     */
    proto.tryToAddY = function (collisionData) {
        if (collisionData.deltaMovement > this.yDeltaMovement) {
            return false;
        } else if (collisionData.deltaMovement < this.yDeltaMovement) {
            this.resetY(collisionData.deltaMovement);
        }
        
        this.yData.push(collisionData);
        
        return true;
    };
    
    /**
     * Resets the X and Y axes.
     *
     * @method reset
     */
    proto.reset = function () {
        this.resetX(Infinity);
        this.resetY(Infinity);
    };
    
    /**
     * Resets the X axis.
     *
     * @param delta {Number} The delta value of the X-axis.
     * @method resetX
     * @since 0.8.7
     */
    proto.resetX = function (delta) {
        var xData = this.xData,
            i = xData.length;
        
        while (i--) {
            xData[i].recycle();
        }
        xData.length = 0;
        this.xDeltaMovement = delta;
    };
    
    /**
     * Resets the Y axis.
     *
     * @param delta {Number} The delta value of the Y-axis.
     * @method resetY
     * @since 0.8.7
     */
    proto.resetY = function (delta) {
        var yData = this.yData,
            i = yData.length;
        
        while (i--) {
            yData[i].recycle();
        }
        yData.length = 0;
        this.yDeltaMovement = delta;
    };
    
    /**
     * Returns an CollisionDataContainer from cache or creates a new one if none are available.
     *
     * @method CollisionDataContainer.setUp
     * @return {platypus.CollisionDataContainer} The instantiated CollisionDataContainer.
     * @since 0.8.7
     */
    /**
     * Returns a CollisionDataContainer back to the cache.
     *
     * @method CollisionDataContainer.recycle
     * @param CollisionDataContainer {platypus.CollisionDataContainer} The CollisionDataContainer to be recycled.
     * @since 0.8.7
     */
    /**
     * Relinquishes properties of the CollisionDataContainer and recycles it.
     *
     * @method recycle
     * @since 0.8.7
     */
    recycle.add(CollisionDataContainer, !!springroll.Debug, 'CollisionDataContainer');

    return CollisionDataContainer;
}());

//##############################################################################
// CollisionShape.js
//##############################################################################

/**
 * This class defines a collision shape, which defines the 'space' an entity occupies in the collision system. Currently only rectangle and circle shapes can be created. Collision shapes include an axis-aligned bounding box (AABB) that tightly wraps the shape. The AABB is used for initial collision checks.
 *
 * @namespace platypus
 * @class CollisionShape
 * @constructor
 * @param owner {platypus.Entity} The entity that uses this shape.
 * @param definition {Object} This is an object of key/value pairs describing the shape.
 * @param definition.x {number} The x position of the shape. The x is always located in the center of the object.
 * @param definition.y {number} The y position of the shape. The y is always located in the center of the object.
 * @param [definition.type="rectangle"] {String} The type of shape this is. Currently this can be either "rectangle" or "circle".
 * @param [definition.width] {number} The width of the shape if it's a rectangle.
 * @param [definition.height] {number} The height of the shape if it's a rectangle.
 * @param [definition.radius] {number} The radius of the shape if it's a circle.
 * @param [definition.offsetX] {number} The x offset of the collision shape from the owner entity's location.
 * @param [definition.offsetY] {number} The y offset of the collision shape from the owner entity's location.
 * @param [definition.regX] {number} The registration x of the collision shape with the owner entity's location if offsetX is not provided.
 * @param [definition.regY] {number} The registration y of the collision shape with the owner entity's location if offsetX is not provided.
 * @param collisionType {String} A string describing the collision type of this shape.
 */
/*global include, platypus, recycle, springroll */
platypus.CollisionShape = (function () {
    'use strict';
    
    var AABB = include('platypus.AABB'),
        Vector = include('platypus.Vector'),
        circleRectCollision = function (circle, rect) {
            var rectAabb         = rect.aABB,
                hh = rectAabb.halfHeight,
                hw = rectAabb.halfWidth,
                abs = Math.abs,
                pow = Math.pow,
                shapeDistanceX = abs(circle.x - rect.x),
                shapeDistanceY = abs(circle.y - rect.y),
                radius = circle.radius;
            
            /* This checks the following in order:
                - Is the x or y distance between shapes less than half the width or height respectively of the rectangle? If so, we know they're colliding.
                - Is the x or y distance between the shapes greater than the half width/height plus the radius of the circle? Then we know they're not colliding.
                - Otherwise, we check the distance between a corner of the rectangle and the center of the circle. If that distance is less than the radius of the circle, we know that there is a collision; otherwise there is not.
            */
            return (shapeDistanceX < hw) || (shapeDistanceY < hh) || ((shapeDistanceX < (hw + radius)) && (shapeDistanceY < (hh + radius)) && ((pow((shapeDistanceX - hw), 2) + pow((shapeDistanceY - hh), 2)) < pow(radius, 2)));
        },
        collidesCircle = function (shape) {
            var pow = Math.pow;
            
            return this.aABB.collides(shape.aABB) && (
                ((shape.type === 'rectangle') && circleRectCollision(this, shape)) ||
                ((shape.type === 'circle')    && ((pow((this.x - shape.x), 2) + pow((this.y - shape.y), 2)) <= pow((this.radius + shape.radius), 2)))
            );
        },
        collidesDefault = function () {
            return false;
        },
        collidesRectangle = function (shape) {
            return this.aABB.collides(shape.aABB) && (
                (shape.type === 'rectangle') ||
                ((shape.type === 'circle') && circleRectCollision(shape, this))
            );
        },
        CollisionShape = function (owner, definition, collisionType) {
            var regX = definition.regX,
                regY = definition.regY,
                width = definition.width || definition.radius * 2 || 0,
                height = definition.height || definition.radius * 2 || 0,
                radius = definition.radius || 0,
                type = definition.type || 'rectangle';

            // If this shape is recycled, the vectors will already be in place.
            if (!this.initialized) {
                this.initialized = true;
                Vector.assign(this, 'offset', 'offsetX', 'offsetY');
                Vector.assign(this, 'position', 'x', 'y');
                Vector.assign(this, 'size', 'width', 'height');
                this.aABB = AABB.setUp();
            }

            this.owner = owner;
            this.collisionType = collisionType;
            this.type = type;
            this.subType = '';
            
            /**
             * Determines whether shapes collide.
             *
             * @method collides
             * @param shape {platypus.CollisionShape} The shape to check against for collision.
             * @return {Boolean} Whether the shapes collide.
             * @since 0.7.4
             */
            if (type === 'circle') {
                width = height = radius * 2;
                this.collides = collidesCircle;
            } else if (type === 'rectangle') {
                this.collides = collidesRectangle;
            } else {
                this.collides = collidesDefault;
            }
            this.size.setXYZ(width, height);
            this.radius = radius;

            if (typeof regX !== 'number') {
                regX = width / 2;
            }
            if (typeof regY !== 'number') {
                regY = height / 2;
            }
            this.offset.setXYZ(definition.offsetX || ((width  / 2) - regX), definition.offsetY || ((height / 2) - regY));

            if (owner) {
                this.position.setXYZ(owner.x, owner.y).add(this.offset);
            } else {
                this.position.setXYZ(definition.x, definition.y).add(this.offset);
            }

            this.aABB.setAll(this.x, this.y, width, height);
        },
        proto = CollisionShape.prototype;

    /**
     * Updates the location of the shape and AABB. The position you send should be that of the owner, the offset of the shape is added inside the function.
     *
     * @method update
     * @param ownerX {number} The x position of the owner.
     * @param ownerY {number} The y position of the owner.
     */
    proto.update = function (ownerX, ownerY) {
        var x = ownerX + this.offsetX,
            y = ownerY + this.offsetY;

        this.position.setXYZ(x, y);
        this.aABB.move(x, y);
    };
    
    /**
     * Move the shape's x position.
     *
     * @method moveX
     * @param x {number} The x position to which the shape should be moved.
     */
    proto.moveX = function (x) {
        this.x = x;
        this.aABB.moveX(x);
    };
    
    /**
     * Move the shape's y position.
     *
     * @method moveY
     * @param y {number} The y position to which the shape should be moved.
     */
    proto.moveY = function (y) {
        this.y = y;
        this.aABB.moveY(y);
    };
    
    /**
     * Returns the axis-aligned bounding box of the shape.
     *
     * @method getAABB
     * @return {platypus.AABB} The AABB of the shape.
     */
    proto.getAABB = function () {
        return this.aABB;
    };
    
    /**
     * Set the shape's position as if the entity's x position is in a certain location.
     *
     * @method setXWithEntityX
     * @param entityX {number} The x position of the entity.
     */
    proto.setXWithEntityX = function (entityX) {
        this.x = entityX + this.offsetX;
        this.aABB.moveX(this.x);
    };
    
    /**
     * Set the shape's position as if the entity's y position is in a certain location.
     *
     * @method setYWithEntityY
     * @param entityY {number} The y position of the entity.
     */
    proto.setYWithEntityY = function (entityY) {
        this.y = entityY + this.offsetY;
        this.aABB.moveY(this.y);
    };
    
    /**
     * Transform the shape using a matrix transformation.
     *
     * @method multiply
     * @param matrix {Array} A matrix used to transform the shape.
     */
    proto.multiply = function (m) {
        var pos = this.position,
            own = this.owner.position;
        
        pos.subtractVector(own);
        
        pos.multiply(m);
        this.offset.multiply(m);
        this.size.multiply(m);
        
        pos.addVector(own);
        this.width  = Math.abs(this.width);
        this.height = Math.abs(this.height);
        
        this.aABB.setAll(this.x, this.y, this.width, this.height);
    };
    
    /**
     * Returns an CollisionShape from cache or creates a new one if none are available.
     *
     * @method CollisionShape.setUp
     * @return {platypus.CollisionShape} The instantiated CollisionShape.
     * @since 0.7.4
     */
    /**
     * Returns a CollisionShape back to the cache.
     *
     * @method CollisionShape.recycle
     * @param {platypus.CollisionShape} The CollisionShape to be recycled.
     * @since 0.7.4
     */
    /**
     * Relinquishes properties of the CollisionShape and recycles it.
     *
     * @method recycle
     * @since 0.7.4
     */
    recycle.add(CollisionShape, !!springroll.Debug, 'CollisionShape');
    
    return CollisionShape;
}());

//##############################################################################
// factory.js
//##############################################################################

/**
 * The component factory takes in component definitions and creates component classes that can be used to create components by entities.  It adds properties and methods that are common to all components so that component definitions can focus on unique properties and methods.
 *
 * To create an extended component class, use the following syntax:
 *
 *      platypus.createComponentClass(componentDefinition, prototype);
 *
 *  * `componentDefinition` is list of key/value pairs that describe the component's behavior.
 *  * `prototype` is an optional prototype that this component extends.
 * See [component-template.js]("component-template"%20Component.html) for an example componentDefinition that can be sent into this component class factory.
 *
 */
/* global extend, include, platypus */
(function () {
    'use strict';
    
    var Component = include('platypus.Component'),
        key = '',
        priority = 0,
        setupProperty = function (property, component, owner) {
            Object.defineProperty(component, property, {
                get: function () {
                    return owner[property];
                },
                set: function (value) {
                    owner[property] = value;
                },
                enumerable: true
            });
        },
        runBoth = function (f1, f2) {
            return function () {
                f1.apply(this, arguments);
                f2.apply(this, arguments);
            };
        };
        
    platypus.components = {};
    
    platypus.createComponentClass = function (componentDefinition, Prototype) {
        var component = function (owner, definition) {
                var prop  = '',
                    func  = '',
                    name  = '',
                    alias = '';
                    
                Component.call(this, componentDefinition.id, owner);

                // if prototype provided, set up its properties here.
                if (Prototype) {
                    Prototype.call(this);
                }

                // Set up properties, prioritizing component settings, entity settings, and finally defaults.
                if (componentDefinition.properties) {
                    for (prop in componentDefinition.properties) {
                        if (componentDefinition.properties.hasOwnProperty(prop)) {
                            if (typeof definition[prop] !== 'undefined') {
                                this[prop] = definition[prop];
                            } else if (typeof this.owner[prop] !== 'undefined') {
                                this[prop] = this.owner[prop];
                            } else {
                                this[prop] = componentDefinition.properties[prop];
                            }
                        }
                    }
                }

                // These component properties are equivalent with `entity.property`
                if (componentDefinition.publicProperties) {
                    for (prop in componentDefinition.publicProperties) {
                        if (componentDefinition.publicProperties.hasOwnProperty(prop)) {
                            setupProperty(prop, this, owner);
                            if (typeof definition[prop] !== 'undefined') {
                                this[prop] = definition[prop];
                            } else if (typeof this.owner[prop] !== 'undefined') {
                                this[prop] = this.owner[prop];
                            } else {
                                this[prop] = componentDefinition.publicProperties[prop];
                            }
                        }
                    }
                }

                if (componentDefinition.events) {
                    priority -= 1; // So event priority remains in order of component addition.
                    for (func in componentDefinition.events) {
                        if (componentDefinition.events.hasOwnProperty(func)) {
                            this.addEventListener(func, componentDefinition.events[func], priority);
                            if (definition.aliases) {
                                for (alias in definition.aliases) {
                                    if (definition.aliases.hasOwnProperty(alias) && (definition.aliases[alias] === func)) {
                                        this.addEventListener(alias, componentDefinition.events[func], priority);
                                    }
                                }
                            }
                        }
                    }
                }

                if (componentDefinition.publicMethods) {
                    for (func in componentDefinition.publicMethods) {
                        if (componentDefinition.publicMethods.hasOwnProperty(func)) {
                            name = func;
                            if (definition.aliases) {
                                for (alias in definition.aliases) {
                                    if (definition.aliases.hasOwnProperty(alias) && (definition.aliases[alias] === func)) {
                                        name = alias;
                                    }
                                }
                            }
                            this.addMethod(name, componentDefinition.publicMethods[func]);
                        }
                    }
                }

                if (this.constructor) {
                    this.constructor(definition);
                }
            },
            func  = null,
            proto = component.prototype;
        
        if (Prototype) { //absorb template prototype if it exists.
            proto = extend(component, Prototype);
            for (key in Component.prototype) {
                if (proto[key]) {
                    proto[key] = runBoth(proto[key], Component.prototype[key]);
                } else {
                    proto[key] = Component.prototype[key];
                }
            }
        } else {
            proto = extend(component, Component);
        }
        
        // Have to copy rather than replace so definition is not corrupted
        proto.constructor = componentDefinition.constructor;

        if (componentDefinition.methods) {
            for (func in componentDefinition.methods) {
                if (componentDefinition.methods.hasOwnProperty(func)) {
                    if (func === 'destroy') {
                        proto._destroy = componentDefinition.methods[func];
                    } else {
                        proto[func] = componentDefinition.methods[func];
                    }
                }
            }
        }
        if (componentDefinition.publicMethods) {
            for (func in componentDefinition.publicMethods) {
                if (componentDefinition.publicMethods.hasOwnProperty(func)) {
                    proto[func] = componentDefinition.publicMethods[func];
                }
            }
        }

        component.getAssetList     = componentDefinition.getAssetList     || Component.getAssetList;
        component.getLateAssetList = componentDefinition.getLateAssetList || Component.getLateAssetList;

        platypus.components[componentDefinition.id] = component;
    };
}());

//##############################################################################
// PlatypusPlugin.js
//##############################################################################

/**
 * This plugin instantiates a Platypus game using the configuration file. Configurations should be placed within the SpringRoll config with the following structure:
 *
 *      {
 *          "platypus": {
 *              "entities": {},
 *              "levels": {},
 *              "scenes": {},
 *              "spriteSheets": {}
 *          },
 *          "sounds": {} // Platypus uses the SpringRoll audio system and syntax for audio assets.
 *      }
 *
 * The Platypus game instance is `app.platypus` on the SpringRoll Application and `platypus.game` within the platypus namespace.
 *
 * @namespace platypus
 * @class PlatypusPlugin
 */
/*global console, document, include, platypus, window */
(function () {
    'use strict';
    
    var Application = include('springroll.Application'),
        ApplicationPlugin = include('springroll.ApplicationPlugin'),
        updateFunction = null,
        plugin = new ApplicationPlugin(),
        resizeFunction = null,
        sayHello = (function () {
            var getPortion = function (num, max) {
                    var min = 204;
                
                    return Math.floor(min * num / max);
                },
                getStyle = function (title, version) {
                    var max = 0,
                        min = 0,
                        style = 'color: #ffffff; padding:3px 0; border-radius: 6px;',
                        r = 0,
                        g = 0,
                        b = 0,
                        v = null;
                        
                    if (version) {
                        v = version.greenSplit('.');
                    }
                    
                    if (version && (v.length === 3)) {
                        r = parseInt(v[0], 10);
                        g = parseInt(v[1], 10);
                        b = parseInt(v[2], 10);
                    } else {
                        r = title.charCodeAt(0) || 0;
                        g = title.charCodeAt(1) || 0;
                        b = title.charCodeAt(2) || 0;
                        min = Math.min(r, g, b);
                        r -= min;
                        g -= min;
                        b -= min;
                    }
                    
                    if (v) {
                        v.recycle();
                    }
                    
                    max = Math.max(r, g, b, 1);

                    return style + ' background: rgb(' + getPortion(r, max) + ',' + getPortion(g, max) + ',' + getPortion(b, max) + ');';
                },
                getVersions = function (text, title, arr) {
                    var i = 0,
                        str = '',
                        versions = Array.setUp(text, getStyle(title, title.substr(title.lastIndexOf(' ') - title.length + 1)), '');
                    
                    for (i = 0; i < arr.length; i++) {
                        str = arr[i];
                        versions.push(getStyle(str, str.substr(str.lastIndexOf(' ') - str.length + 1)), '');
                    }
                    
                    return versions;
                };
            
            return function (settings, app) {
                var cJS     = window.createjs,
                    options = app.options,
                    author  = (options.author ? 'by ' + options.author : ''),
                    pixi    = window.PIXI,
                    title   = app.name || document.title || '',
                    engine  = 'Platypus ' + platypus.version,
                    version = options.version || '(?)',
                    using   = Array.setUp(),
                    usingV  = Array.setUp();
                
                if (!options.hideHello) {
                    using   = Array.setUp('SpringRoll ' + Application.version);
                    
                    if (pixi) {
                        using.push('Pixi.js ' + pixi.VERSION);
                    }
                    if (cJS) {
                        if (cJS.EaselJS) {
                            using.push('EaselJS ' + cJS.EaselJS.version);
                        }
                        if (cJS.PreloadJS) {
                            using.push('PreloadJS ' + cJS.PreloadJS.version);
                        }
                        if (cJS.SoundJS) {
                            using.push('SoundJS ' + cJS.SoundJS.version);
                        }
                        if (cJS.TweenJS) {
                            using.push('TweenJS ' + cJS.TweenJS.version);
                        }
                    }
                    
                    if (version !== '(?)') {
                        title += ' ' + version;
                    }
                    
                    if (platypus.supports.firefox || platypus.supports.chrome) {
                        using.push(engine);
                        usingV = getVersions('\n%c ' + title + ' %c ' + author + ' \n\nUsing %c ' + using.join(' %c %c ') + ' %c\n\n', title, using);
                        console.log.apply(console, usingV);
                        usingV.recycle();
                    } else {
                        console.log('--- "' + title + '" ' + author + ' - Using ' + using.join(', ') + ', and ' + engine + ' ---');
                    }

                    using.recycle();
                }
    
                platypus.debug.olive("Game config loaded.", settings);
            };
        }()),
        flattenEntityList = function (entityList) {
            var entity = null,
                folder = null,
                folderEntity = null,
                resultList = {};
            
            for (entity in entityList) {
                if (!entityList[entity].id) {
                    folder = flattenEntityList(entityList[entity]);
                    for (folderEntity in folder) {
                        if (folder.hasOwnProperty(folderEntity)) {
                            resultList[folderEntity] = folder[folderEntity];
                        }
                    }
                } else {
                    resultList[entity] = entityList[entity];
                }
            }
            return resultList;
        },
        setSpriteSheetIds = function (ss) { // Putting this here for now. May handle differently in the future. - DDD 2/2/2016
            var key = '';
            
            for (key in ss) {
                if (ss.hasOwnProperty(key)) {
                    ss[key].id = key;
                }
            }
        };
    
    if (window.PIXI) {
        window.PIXI.utils._saidHello = true; // Over-riding the pixi.js hello since we're creating our own.
    }

    plugin.setup = function () {
        var author = '',
            authorTag = document.getElementsByName('author'),
            options = this.options;
        
        if (authorTag.length) { // Set default author by page meta data if it exists.
            author = authorTag[0].getAttribute('content') || '';
        }
        
        /**
         * Sets credit for the game. Defaults to the "author" META tag if present on the document.
         *
         * @property {String} options.author
         * @default ''
         */
        options.add('author', author, true);

        /**
         * Hides console hello for the game.
         *
         * @property {Boolean} options.hideHello
         * @default false
         */
        options.add('hideHello', false, true);
    };
    
    // Preload is an optional asynchronous call for doing any loading
    // before the application is init. Make sure that done() is called
    // when this is complete. The display and options are available here.
    plugin.preload = function (done) {
        var config = this.config.platypus || this.config,
            game = null,
            priority = 320,
            time = {
                delta: 0
            };
        
        if (!config) {
            platypus.debug.warn('PlatypusPlugin: Platypus requires a game configuration.');
        } else {
            if (this.options.debug) { // Set debug property on game configuration.
                config.debug = true;
            }
            
            sayHello(config, this);
            
            config.entities = flattenEntityList(config.entities);
            
            if (config.spriteSheets) {
                setSpriteSheetIds(config.spriteSheets);
            }
            
            game = this.platypus = new platypus.Game(config, this);
            
            updateFunction = function (elapsed) {
                time.delta = elapsed;
                game.tick(time);
            };
            this.on('update', updateFunction, priority); // Needs to occur before PIXI's ticker update so rendered objects can be positioned correctly.
    
            resizeFunction = function (event) {
                if (game.currentScene) {
                    game.currentScene.triggerOnChildren('resize', event);
                }
            };
            this.on('resize', resizeFunction);
        }

        done(); // required!
    };

    // Clean-up when the application is destroyed
    plugin.teardown = function () {
        if (this.platypus) { // May not exist if game failed to instantiate in preload.
            this.off('update', updateFunction);
            this.off('resize', resizeFunction);
            this.platypus.destroy();
            delete this.platypus;
        }
    };
    
}());

//##############################################################################
// AIChaser.js
//##############################################################################

/**
 * This component acts as a simple AI that will chase another entity.
 *
 * @namespace platypus.components
 * @class AIChaser
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector');

    return platypus.createComponentClass({
        
        id: 'AIChaser',
        
        properties: {
            /**
             * Sets whether the speed property should enact acceleration upon the entity rather than velocity.
             *
             * @property accelerate
             * @type boolean
             * @default false
             */
            accelerate: false,
            
            /**
             * Whether the entity is in a chasing state.
             *
             * @property chasing
             * @type boolean
             * @default true
             */
            chasing: true
        },
        
        publicProperties: {
            /**
             * Sets the velocity of the entity. This property is accessible on the entity as `entity.speed`.
             *
             * @property speed
             * @type number
             * @default 0.3
             */
            speed: 0.3
        },
        
        constructor: function () {
            this.target = this.owner.target || null;
            this.offset = Vector.setUp(0, 0);
            this.state = this.owner.state;
            this.state.set('chasing', false);
        },

        events: {
            /**
             * This component listens for this event to initialize movement.
             *
             * @method 'load'
             */
            "load": function () {
                if (!this.owner.addMover) {
                    platypus.debug.warn('The "AIChaser" component requires a "Mover" component to function correctly.');
                    return;
                }
                
                this.direction = this.owner.addMover({
                    vector: [this.speed, 0, 0],
                    event: "chase",
                    accelerator: this.accelerate
                }).vector;
            },
        
            /**
             * This AI listens for a step message triggered by its entity parent in order to perform its logic on each tick.
             *
             * @method 'handle-ai'
             */
            "handle-ai": function () {
                var v = null,
                    m = 0,
                    c = false;

                if (this.target && this.chasing) {
                    v = Vector.setUp(this.offset).add(this.target.position).subtractVector(this.owner.position);
                    m = v.magnitude(2);

                    if (m) {
                        c = true;
                        this.direction.setVector(v).normalize().multiply(this.speed);
                    }

                    v.recycle();
                }
                
                if (c !== this.state.get('chasing')) {
                    this.state.set('chasing', c);
                    
                    /**
                     * This event is triggered whenever the entity begins chasing another entity or stops chasing another entity.
                     *
                     * @event 'chase'
                     * @param chasing {boolean} Whether the entity is chasing another entity.
                     */
                    this.owner.triggerEvent('chase', c);
                }
            },
            
            /**
             * On receiving this message, the component will change its target and begin chasing the new entity.
             *
             * @method 'set-target'
             * @param entity {platypus.Entity} Sets this entity's target to the provided entity.
             */
            "set-target": function (entity) {
                this.target = entity;
                this.offset.x = 0;
                this.offset.y = 0;
            },
            
            /**
             * On receiving this message, the component will change its target offset.
             *
             * @method 'set-target-offset'
             * @param offset {Object|Vector} Sets the chased entity's offset to the provided offset.
             * @param offset.x {number} The offset along the x-axis.
             * @param offset.y {number} The offset along the y-axis.
             */
            "set-target-offset": function (offset) {
                this.offset.x = offset.x;
                this.offset.y = offset.y;
            },
            
            /**
             * On receiving this message, the component will begin chasing the entity.
             *
             * @method 'start-chasing'
             * @param [entity] {platypus.Entity} Sets the entity if it's provided.
             */
            "start-chasing": function (entity) {
                if (entity) {
                    this.target = entity;
                }
                this.chasing = true;
            },
            
            /**
             * On receiving this message, the component will cease chasing the entity.
             *
             * @method 'stop-chasing'
             */
            "stop-chasing": function () {
                this.chasing = false;
            }
        },
        
        methods: {// These are methods that are called on the component
            destroy: function () {
                this.target = null;
                this.offset.recycle();
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// AIPacer.js
//##############################################################################

/**
 * This component acts as a simple AI that will reverse the movement direction of an object when it collides with something.
 *
 * @namespace platypus.components
 * @class AIPacer
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: "AIPacer",
        
        properties: {
            /**
             * This determines the direction of movement. Can be "horizontal", "vertical", or "both".
             *
             * @property movement
             * @type String
             * @default "both"
             */
            movement: 'both',
            
            /**
             * This sets the initial direction of movement. Defaults to "up", or "left" if movement is horizontal.
             *
             * @property direction
             * @type String
             * @default "up"
             */
            direction: null
        },
        
        constructor: function () {
            this.lastDirection    = '';
            this.currentDirection = this.direction || ((this.movement === 'horizontal') ? 'left' : 'up');
        },
        
        events: {
            /**
             * This AI listens for a step message triggered by its entity parent in order to perform its logic on each tick.
             *
             * @method 'handle-ai'
             */
            "handle-ai": function () {
                if (this.currentDirection !== this.lastDirection) {
                    this.lastDirection = this.currentDirection;
                    
                    /**
                     * Triggers this event prior to changing direction.
                     *
                     * @event 'stop'
                     */
                    this.owner.triggerEvent('stop');
                    
                    /**
                     * Triggers this event when the entity is moving right and collides with something.
                     *
                     * @event 'go-left'
                     */
                    /**
                     * Triggers this event when the entity is moving left and collides with something.
                     *
                     * @event 'go-right'
                     */
                    /**
                     * Triggers this event when the entity is moving up and collides with something.
                     *
                     * @event 'go-down'
                     */
                    /**
                     * Triggers this event when the entity is moving down and collides with something.
                     *
                     * @event 'go-up'
                     */
                    this.owner.triggerEvent('go-' + this.currentDirection);
                }
            },
            
            /**
             * On receiving this message, the component will check the collision side and re-orient itself accordingly.
             *
             * @method 'turn-around'
             * @param collisionInfo {platypus.CollisionData} Uses direction of collision to determine whether to turn around.
             */
            "turn-around": function (collisionInfo) {
                if ((this.movement === 'both') || (this.movement === 'horizontal')) {
                    if (collisionInfo.x > 0) {
                        this.currentDirection = 'left';
                    } else if (collisionInfo.x < 0) {
                        this.currentDirection = 'right';
                    }
                }
                if ((this.movement === 'both') || (this.movement === 'vertical')) {
                    if (collisionInfo.y > 0) {
                        this.currentDirection = 'up';
                    } else if (collisionInfo.y < 0) {
                        this.currentDirection = 'down';
                    }
                }
            }
        }
    });
}());

//##############################################################################
// AudioSFX.js
//##############################################################################

/**
 * This component plays audio using the SpringRoll Sound instance. Audio is played in one of two ways, by triggering specific messages defined in the audio component definition or using an audio map which plays sounds when the entity enters specified states.
 *
 * @namespace platypus.components
 * @class AudioSFX
 * @uses platypus.Component
 * @since 0.6.0
 */
/*global include, createjs, platypus */
(function () {
    'use strict';
    
    var Application = include('springroll.Application'), // Import SpringRoll classes
        Data = include('platypus.Data'),
        StateMap = include('platypus.StateMap'),
        defaultSettings = {
            interrupt: createjs.Sound.INTERRUPT_ANY, //INTERRUPT_ANY, INTERRUPT_EARLY, INTERRUPT_LATE, or INTERRUPT_NONE
            delay: 0,
            offset: 0,
            loop: 0,
            volume: 1,
            pan: 0,
            mute: false,
            paused: false
        },
        playSound = function (soundDefinition) {
            var sound      = '',
                attributes = null,
                completed  = function (data/*, cancelled*/) {
                    if (data.audio) {
                        this.onComplete(data.audio);
                    }
                    data.recycle();
                };
            
            if (typeof soundDefinition === 'string') {
                sound      = soundDefinition;
                attributes = {};
            } else {
                sound      = soundDefinition.sound;
                attributes = {
                    interrupt: soundDefinition.interrupt,
                    delay: soundDefinition.delay,
                    offset: soundDefinition.offset,
                    loop: soundDefinition.loop,
                    volume: soundDefinition.volume,
                    pan: soundDefinition.pan,
                    startTime: soundDefinition.startTime,
                    duration: soundDefinition.duration,
                    mute: soundDefinition.mute,
                    paused: soundDefinition.paused
                };
            }

            return function (value) {
                var data = null;

                value = value || attributes;
                
                data = Data.setUp(
                    "interrupt", value.interrupt || attributes.interrupt || defaultSettings.interrupt,
                    "delay",     value.delay     || attributes.delay  || defaultSettings.delay,
                    "loop",      value.loop      || attributes.loop   || defaultSettings.loop,
                    "offset",    value.offset    || attributes.offset || defaultSettings.offset,
                    "volume",    (typeof value.volume !== 'undefined') ? value.volume : ((typeof attributes.volume !== 'undefined') ? attributes.volume : defaultSettings.volume),
                    "pan",       value.pan       || attributes.pan    || defaultSettings.pan,
                    "mute",      value.mute      || attributes.mute   || defaultSettings.mute,
                    "paused",    value.paused    || attributes.paused || defaultSettings.paused
                );
                data.complete = completed.bind(this, data);
                data.audio = this.player.play(sound, data);
                
                if (data.audio) {
                    data.audio.soundId = sound;
                    this.activeAudioClips.push(data.audio);
                }
            };
        },
        stateAudioPlay = function (checkData, audioId, play, state) {
            var active = state.includes(checkData.states);

            if (active !== checkData.playing) {
                if (active) {
                    play();
                } else {
                    this.stopAudio(audioId, this.forcePlaythrough);
                }
                checkData.playing = active;
            }
        };
    
    return platypus.createComponentClass({
        id: 'AudioSFX',
        
        properties: {
            /**
             * Use the audioMap property object to map messages triggered with audio clips to play. At least one audio mapping should be included for audio to play. Here is an example audioMap object:
             *
             *       {
             *           "message-triggered": "audio-id",
             *           // This simple form is useful to listen for "message-triggered" and play "audio-id" using default audio properties.
             *
             *           "another-message": {
             *           // To specify audio properties, instead of mapping the message to an audio id string, map it to an object with one or more of the properties shown below. Many of these properties directly correspond to SoundJS play parameters.
             *
             *               "sound": "another-audio-id",
             *               // Required. This is the audio clip to play when "another-message" is triggered.
             *
             *               "interrupt": "none",
             *               // Optional. Can be "any", "early", "late", or "none". Determines how to handle the audio when it's already playing but a new play request is received. Default is "any".
             *
             *               "delay": 500,
             *               // Optional. Time in milliseconds to wait before playing audio once the message is received. Default is 0.
             *
             *               "offset": 1500,
             *               // Optional. Time in milliseconds determining where in the audio clip to begin playback. Default is 0.
             *
             *               "length": 2500,
             *               // Optional. Time in milliseconds to play audio before stopping it. If 0 or not specified, play continues to the end of the audio clip.
             *
             *               "loop": 4,
             *               // Optional. Determines how many more times to play the audio clip once it finishes. Set to -1 for an infinite loop. Default is 0.
             *
             *               "volume": 0.75,
             *               // Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.
             *
             *               "pan": -0.25
             *               // Optional. Used to specify the pan of audio on a range of -1 (left) to 1 (right). Default is 0.
             *           }
             *       }
             *
             * @property audioMap
             * @type Object
             * @default null
             */
            audioMap: null,
            
            /**
             * Determines whether a sound that's started should play through completely regardless of entity state changes.
             *
             * @property forcePlayThrough
             * @type boolean
             * @default true
             */
            forcePlayThrough: true,

            /**
             * Optional. Specifies whether this component should listen to events matching the animationMap to animate. Set this to true if the component should animate for on events.
             *
             * @property eventBased
             * @type Boolean
             * @default true
             * @since 0.7.5
             */
            eventBased: true,

            /**
             * Optional. Specifies whether this component should listen to changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on this.owner.state.
             *
             * @property stateBased
             * @type Boolean
             * @default false
             * @since 0.7.5 - Defaults to `true` prior to version 0.9.0
             */
            stateBased: false
        },
            
        constructor: function (definition) {
            var key      = '',
                playClip = null,
                sound    = null;
            
            this.activeAudioClips = Array.setUp();
    
            this.state = this.owner.state;
            this.stateChange = false;
            
            this.player = Application.instance.sound;
    
            if (definition.audioMap) {
                if (this.stateBased) {
                    this.checkStates = Array.setUp();
                }
                for (key in definition.audioMap) {
                    if (definition.audioMap.hasOwnProperty(key)) {
                        sound = definition.audioMap[key];
                        playClip = playSound(sound);
                        if (sound.sound) {
                            sound = sound.sound;
                        }
                        
                        /**
                         * Listens for messages specified by the `audioMap` and on receiving them, begins playing corresponding audio clips. Audio play message can optionally include several parameters, many of which correspond with SoundJS play parameters.
                         *
                         * @method '*'
                         * @param message.interrupt (string) - Optional. Can be "any", "early", "late", or "none". Determines how to handle the audio when it's already playing but a new play request is received. Default is "any".
                         * @param message.delay (integer) - Optional. Time in milliseconds to wait before playing audio once the message is received. Default is 0.
                         * @param message.offset (integer) - Optional. Time in milliseconds determining where in the audio clip to begin playback. Default is 0.
                         * @param message.length (integer) - Optional. Time in milliseconds to play audio before stopping it. If 0 or not specified, play continues to the end of the audio clip.
                         * @param message.loop (integer) - Optional. Determines how many more times to play the audio clip once it finishes. Set to -1 for an infinite loop. Default is 0.
                         * @param message.volume (float) - Optional. Used to specify how loud to play audio on a range from 0 (mute) to 1 (full volume). Default is 1.
                         * @param message.pan (float) - Optional. Used to specify the pan of audio on a range of -1 (left) to 1 (right). Default is 0.
                         * @param message.next (string) - Optional. Used to specify the next audio clip to play once this one is complete.
                         */
                        if (this.eventBased) {
                            this.addEventListener(key, playClip);
                        }
                        if (this.stateBased) {
                            this.addStateCheck(key, sound, playClip);
                        }
                    }
                }
            }
            
            this.paused          = false;
        },

        events: {
            /**
             * On each `handle-render` message, this component checks its list of playing audio clips and stops any clips whose play length has been reached.
             *
             * @method 'handle-render'
             */
            "handle-render": function () {
                var i = 0,
                    cs = null,
                    state = this.state;
                
                if (this.paused) {
                    return;
                }
                
                if (this.stateBased && this.stateChange) {
                    cs = this.checkStates;
                    i = cs.length;
                    while (i--) {
                        cs[i].check(state);
                    }
                    this.stateChange = false;
                }
            },
             
            /**
             * This component listens for changes to the entity state and tests the current state of the entity against the audio map. If a match is found, the matching audio clip is played.
             *
             * @method 'state-changed'
             */
            "state-changed": function () {
                this.stateChange = true;
            },

            /**
             * On receiving this message, the audio will mute if unmuted, and unmute if muted.
             *
             * @method 'toggle-mute'
             * @param audioId {String} If an audioId is provided, that particular sound instance is toggled. Otherwise all audio is toggled from mute to unmute or vice versa.
             */
            "toggle-mute": function (audioId) {
                this.handleClip(audioId, function (clip) {
                    if (clip) {
                        if (clip.unmuted) {
                            clip.volume = clip.unmuted;
                            delete clip.unmuted;
                        } else {
                            clip.unmuted = clip.volume;
                            clip.volume = 0;
                        }
                    }
                });
            },

            /**
             * On receiving this message, audio will stop playing.
             *
             * @method 'stop-audio'
             * @param audioId {String} If an audioId is provided, that particular sound instance is stopped. Otherwise all audio is stopped.
             */
            "stop-audio": function (audioId) {
                if (!audioId) {
                    this.stopAudio();
                } else if (typeof audioId === 'string') {
                    this.stopAudio(audioId);
                } else {
                    this.stopAudio(audioId.audioId || false, audioId.playthrough || false);
                }
            },

            /**
             * On receiving this message all audio will mute, or a particular sound instance will mute if an id is specified.
             *
             * @method 'mute-audio'
             * @param audioId {String} If an audioId is provided, that particular sound instance will mute. Otherwise all audio is muted.
             */
            "mute-audio": function (audioId) {
                this.handleClip(audioId, function (clip) {
                    if (clip) {
                        clip.unmuted = clip.volume;
                        clip.volume = 0;
                    }
                });
            },

            /**
             * On receiving this message all audio will unmute, or a particular sound instance will unmute if an id is specified.
             *
             * @method 'unmute-audio'
             * @param audioId {String} If an audioId is provided, that particular sound instance will unmute. Otherwise all audio is unmuted.
             */
            "unmute-audio": function (audioId) {
                this.handleClip(audioId, function (clip) {
                    if (clip) {
                        clip.volume = clip.unmuted;
                        delete clip.unmuted;
                    }
                });
            },

            /**
             * On receiving this message all audio will pause, or a particular sound instance will pause if an id is specified.
             *
             * @method 'pause-audio'
             * @param audioId {String} If an audioId is provided, that particular sound instance will pause. Otherwise all audio is paused.
             */
            "pause-audio": function (audioId) {
                this.handleClip(audioId, function (clip) {
                    if (clip) {
                        clip.pause();
                    }
                });
            },

            /**
             * On receiving this message all audio will unpause, or a particular sound instance will unpause if an id is specified.
             *
             * @method 'unpause-audio'
             * @param audioId {String} If an audioId is provided, that particular sound instance will unpause. Otherwise all audio is unpaused.
             */
            "unpause-audio": function (audioId) {
                this.handleClip(audioId, function (clip) {
                    if (clip) {
                        clip.unpause();
                    }
                });
            },
             
            /**
             * This message sets the volume of playing audio.
             *
             * @method 'set-volume'
             * @param audioId {String} If an audioId is provided, that particular sound instance's volume is set. Otherwise all audio volume is changed.
             */
            "set-volume": function (volume) {
                var vol     = 0,
                    handler = function (clip) {
                        clip.volume = vol;
                    };

                if (typeof volume === 'number') {
                    vol = volume;
                    this.getAllClips(handler);
                } else if (volume.volume) {
                    vol = volume.volume;
                    this.handleClip(volume.soundId, handler);
                }
            }
        },
        
        methods: {
            handleClip: function (audioId, handler) {
                if (typeof audioId === 'string') {
                    this.getClipById(audioId, handler);
                } else {
                    this.getAllClips(handler);
                }
            },
            
            getClipById: function (id, onGet) {
                var i     = 0,
                    clips = this.activeAudioClips;
                
                for (i = 0; i < clips.length; i++) {
                    if (clips[i].soundId === id) {
                        if (onGet) {
                            onGet(clips[i]);
                        }
                        return clips[i];
                    }
                }
                
                if (onGet) {
                    onGet(null);
                }

                return null;
            },
            
            getAllClips: function (onGet) {
                var i     = 0,
                    clips = this.activeAudioClips;
                
                if (onGet) {
                    for (i = 0; i < clips.length; i++) {
                        onGet(clips[i]);
                    }
                }

                return clips;
            },
            
            stopAudio: (function () {
                var
                    loopFunc = function (instance) {
                        this.stopAudioInstance(instance.currentTarget);
                    };
                
                return function (audioId, playthrough) {
                    var clips = this.activeAudioClips,
                        func = null,
                        i = clips.length;
                    
                    if (audioId) {
                        func = loopFunc.bind(this);
                        while (i--) {
                            if (clips[i].soundId === audioId) {
                                if (playthrough) {
                                    clips[i].addEventListener('loop', func);
                                } else {
                                    clips[i].stop();
                                    clips.greenSplice(i);
                                }
                            }
                        }
                    } else if (playthrough) {
                        func = loopFunc.bind(this);
                        while (i--) {
                            clips[i].addEventListener('loop', func);
                        }
                    } else {
                        while (i--) {
                            clips[i].stop();
                        }
                        clips.length = 0;
                    }
                };
            }()),
            
            stopAudioInstance: function (instance) {
                var clips = this.activeAudioClips,
                    i     = clips.indexOf(instance);
                
                if (i >= 0) {
                    clips.greenSplice(i).stop();
                }
            },
            
            onComplete: function (data) {
                if (!this.owner.destroyed) {
                    //clean up active clips
                    this.removeClip(data.audio);
                    
                    /**
                     * When a sound effect is finished playing, this event is triggered.
                     *
                     * @event clip-complete
                     */
                    this.owner.triggerEvent('clip-complete');
                }
            },
            
            removeClip: function (audioClip) {
                var i = this.activeAudioClips.indexOf(audioClip);

                if (i >= 0) {
                    this.activeAudioClips.greenSplice(i);
                }
            },
            
            addStateCheck: function (key, value, play) {
                var states = StateMap.setUp(key),
                    checkData = Data.setUp(
                        "states", states,
                        "playing", false
                    );
                
                checkData.check = stateAudioPlay.bind(this, checkData, value, play.bind(this));
                this.checkStates.push(checkData);
            },
            
            destroy: function () {
                var c = this.checkStates,
                    ci = null,
                    i = 0;
                
                this.stopAudio();
                this.activeAudioClips.recycle();
                
                this.state = null;

                if (c) {
                    i = c.length;
                    while (i--) {
                        ci = c[i];
                        ci.states.recycle();
                        ci.recycle();
                    }
                    c.recycle();
                    this.checkStates = null;
                }
            }
        }
    });
}());

//##############################################################################
// AudioVO.js
//##############################################################################

/**
 * This component plays audio using the SpringRoll VOPlayer instance. Audio is played by triggering specific messages defined in the audio component definition.
 *
 * @namespace platypus.components
 * @class AudioVO
 * @uses platypus.Component
 * @since 0.6.0
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Application = include('springroll.Application'), // Import SpringRoll classes
        Data = include('platypus.Data'),
        sortByTime = function (a, b) {
            return a.time - b.time;
        },
        addEvents = function (fromList, toList) {
            var i = 0;
            
            for (i = 0; i < fromList.length; i++) {
                toList.push(Data.setUp(
                    'event', fromList[i].event,
                    'time', fromList[i].time || 0,
                    'message', fromList[i].message
                ));
            }
            
            if (i) {
                toList.sort(sortByTime);
            }
            
            return toList;
        },
        offsetEvents = function (fromList, toList, player) {
            var i = 0,
                offset = player.getElapsed();
            
            for (i = 0; i < fromList.length; i++) {
                toList.push(Data.setUp(
                    'event', fromList[i].event,
                    'time', (fromList[i].time || 0) + offset,
                    'message', fromList[i].message || null
                ));
            }
            
            if (i) {
                toList.sort(sortByTime);
            }
        },
        setupEventList = function (sounds, eventList, player) { // This function merges events from individual sounds into a full list queued to sync with the SpringRoll voPlayer.
            var i = 0,
                soundList = Array.setUp();
            
            // Create alias-only sound list.
            for (i = 0; i < sounds.length; i++) {
                if (sounds[i].sound) {
                    if (sounds[i].events) {
                        soundList.push(offsetEvents.bind(this, sounds[i].events, eventList, player));
                    }
                    soundList.push(sounds[i].sound);
                } else {
                    soundList.push(sounds[i]);
                }
            }
            return soundList;
        },
        onComplete = function (complete, soundList) {
            this.playingAudio = false;
            if (!this.owner.destroyed) {
                this.checkTimeEvents(true);
                
                /**
                 * When an audio sequence is finished playing, this event is triggered.
                 *
                 * @event sequence-complete
                 */
                this.owner.triggerEvent('sequence-complete');
            }
            soundList.recycle();
        },
        playSound = function (soundDefinition, value) {
            var soundList = null,
                eventList = this.eventList,
                player = this.player;
            
            if (typeof soundDefinition === 'string') {
                soundList = Array.setUp(soundDefinition);
            } else if (Array.isArray(soundDefinition)) {
                soundList = setupEventList(soundDefinition, eventList, player);
            } else {
                if (soundDefinition.events) {
                    addEvents(soundDefinition.events, eventList);
                }
                if (Array.isArray(soundDefinition.sound)) {
                    soundList = setupEventList(soundDefinition.sound, eventList, player);
                } else {
                    soundList = Array.setUp(soundDefinition.sound);
                }
            }
            
            if (value && value.events) {
                addEvents(value.events, eventList);
            }

            this.playingAudio = true;
            player.play(soundList, onComplete.bind(this, true, soundList), onComplete.bind(this, false, soundList));
        };
    
    return platypus.createComponentClass({
        id: 'AudioVO',
        
        properties: {
            /**
             * Use the audioMap property object to map messages triggered with audio clips to play. At least one audio mapping should be included for audio to play. Here is an example audioMap object:
             *
             *       {
             *           "message-triggered": "audio-id",
             *           // This simple form is useful to listen for "message-triggered" and play "audio-id" using default audio properties.
             *
             *           "another-message": {
             *           // To specify audio properties, instead of mapping the message to an audio id string, map it to an object with one or more of the properties shown below. Many of these properties directly correspond to SoundJS play parameters.
             *
             *               "sound": "another-audio-id",
             *               // Required. This is the audio clip to play when "another-message" is triggered.
             *
             *               "events": [{
             *                   "event": "walk-to-the-left",
             *                   "time": 1500
             *               }]
             *               // Optional. Used to specify a list of events to play once the VO begins.
             *           }
             *       }
             *
             * @property audioMap
             * @type Object
             * @default null
             */
            audioMap: null
        },
            
        constructor: function (definition) {
            var key = '';
            
            this.eventList = Array.setUp();
    
            this.playingAudio = false;
            this.player = Application.instance.voPlayer;
    
            if (definition.audioMap) {
                for (key in definition.audioMap) {
                    if (definition.audioMap.hasOwnProperty(key)) {

                        /**
                         * Listens for messages specified by the `audioMap` and on receiving them, begins playing corresponding audio clips.
                         *
                         * @method '*'
                         * @param [message.events] {Array} Used to specify the list of events to trigger while playing this audio sequence.
                         */
                        this.addEventListener(key, playSound.bind(this, definition.audioMap[key]));
                    }
                }
            }
            
            this.paused = false;
        },

        events: {
            /**
             * On each `handle-render` message, this component checks its list of playing audio clips and stops any clips whose play length has been reached.
             *
             * @method 'handle-render'
             */
            "handle-render": function () {
                if (!this.paused) {
                    this.checkTimeEvents(false);
                }
            },

            /**
             * On receiving this message, audio will stop playing.
             *
             * @method 'stop-audio'
             */
            "stop-audio": function () {
                this.player.stop();
            }
        },
        
        methods: {
            checkTimeEvents: function (finished) {
                var event = null,
                    events = this.eventList,
                    currentTime = 0,
                    owner = this.owner;
                
                if (events && events.length) {
                    currentTime = this.player.getElapsed();

                    while (events.length && (finished || (events[0].time <= currentTime))) {
                        event = events.greenSplice(0);
                        owner.trigger(event.event, event.message);
                        event.recycle();
                    }
                }
            },

            destroy: function () {
                if (this.playingAudio) {
                    this.player.stop();
                }
                this.eventList.recycle();
            }
        }
    });
}());

//##############################################################################
// Camera.js
//##############################################################################

/**
 * This component controls the game camera deciding where and how it should move. The camera also broadcasts messages when the window resizes or its orientation changes.
 *
 * @namespace platypus.components
 * @class Camera
 * @uses platypus.Component
*/
/*global createjs, PIXI, platypus, include, window */
(function () {
    'use strict';
    
    var Application = include("springroll.Application"),
        AABB = include('platypus.AABB'),
        Data = include('platypus.Data'),
        Vector = include('platypus.Vector'),
        anchorBound = function (anchorAABB, entityOffsetX, entityOffsetY, entity) {
            var aabb = AABB.setUp(entity.x + entityOffsetX, entity.y + entityOffsetY, entity.width, entity.height),
                x = anchorAABB.x,
                y = anchorAABB.y;

            if (aabb.top < anchorAABB.top) {
                y -= (anchorAABB.top - aabb.top);
            } else if (aabb.bottom > anchorAABB.bottom) {
                y += (anchorAABB.bottom - aabb.bottom);
            }
            
            if (aabb.left < anchorAABB.left) {
                x -= (anchorAABB.left - aabb.left);
            } else if (aabb.right > anchorAABB.right) {
                x += (anchorAABB.right - aabb.right);
            }
            
            aabb.recycle();
            
            return this.move(x, y, 0);
        },
        doNothing = function () {
            return false;
        };
    
    return platypus.createComponentClass({
        id: 'Camera',
        properties: {
            /**
             * Number specifying width of viewport in world coordinates.
             *
             * @property width
             * @type number
             * @default 0
             **/
            "width": 0,
             
            /**
             * Number specifying height of viewport in world coordinates.
             *
             * @property height
             * @type number
             * @default 0
             **/
            "height": 0,
            
            "mode": "static",
            
            /**
             * Whether camera overflows to cover the whole canvas or remains contained within its aspect ratio's boundary.
             *
             * @property overflow
             * @type boolean
             * @default false
             */
            "overflow": false,
            
            /**
             * Boolean value that determines whether the camera should stretch the world viewport when window is resized. Defaults to false which maintains the proper aspect ratio.
             *
             * @property stretch
             * @type boolean
             * @default: false
             */
            "stretch": false,
            
            /**
             * Sets how many units the followed entity can move before the camera will re-center. This should be lowered for small-value coordinate systems such as Box2D.
             *
             * @property threshold
             * @type number
             * @default 1
             **/
            "threshold": 1,
            
            /**
             * Whether, when following an entity, the camera should rotate to match the entity's orientation.
             *
             * @property rotate
             * @type boolean
             * @default false
             **/
            "rotate": false,

            /**
             * Number specifying the horizontal center of viewport in world coordinates.
             *
             * @property x
             * @type number
             * @default 0
             **/
            "x": 0,
             
            /**
             * Number specifying the vertical center of viewport in world coordinates.
             *
             * @property y
             * @type number
             * @default 0
             **/
            "y": 0
        },
        publicProperties: {
            /**
             * The entity's canvas element is used to determine the window size of the camera.
             *
             * @property canvas
             * @type DOMElement Canvas
             * @default null
             */
            "canvas": null,
            
            /**
             * Sets how quickly the camera should pan to a new position in the horizontal direction.
             *
             * @property transitionX
             * @type number
             * @default 400
             **/
            "transitionX": 400,
            
            /**
             * Sets how quickly the camera should pan to a new position in the vertical direction.
             *
             * @property transitionY
             * @type number
             * @default 600
             **/
            "transitionY": 600,
             
            /**
             * Sets how quickly the camera should rotate to a new orientation.
             *
             * @property transitionAngle
             * @type number
             * @default: 600
             **/
            "transitionAngle": 600
        },
        constructor: function (definition) {
            var worldVP = AABB.setUp(this.x, this.y, this.width, this.height),
                worldCamera = Data.setUp(
                    "viewport", worldVP,
                    "orientation", definition.orientation || 0
                );

            //The dimensions of the camera in the window
            this.viewport = AABB.setUp(0, 0, 0, 0);
            
            //The dimensions of the camera in the game world
            this.worldCamera = worldCamera;

            //Message object defined here so it's reusable
            this.worldDimensions = AABB.setUp();
            this.message = Data.setUp(
                "viewport", AABB.setUp(),
                "scaleX", 0,
                "scaleY", 0,
                "orientation", 0,
                "stationary", false,
                "world", this.worldDimensions
            );
            this.cameraLoadedMessage = Data.setUp(
                "viewport", this.message.viewport,
                "world", this.worldDimensions
            );
    
            //Whether the map has finished loading.
            this.worldIsLoaded = false;
            
            this.following = null;
            this.state = 'static';//'roaming';
            if (this.mode === 'pan') {
                this.state = 'mouse-pan';
            }
            
            //FOLLOW MODE VARIABLES
            
            //--Bounding
            this.boundingBox = AABB.setUp(worldVP.x, worldVP.y, worldVP.width / 2, worldVP.height / 2);
            
            //Forward Follow
            this.lastX = worldVP.x;
            this.lastY = worldVP.y;
            this.lastOrientation = worldCamera.orientation;
            this.forwardX = 0;
            this.forwardY = 0;
            this.forwardAngle = 0;
            this.averageOffsetX = 0;
            this.averageOffsetY = 0;
            this.averageOffsetAngle = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.offsetAngle = 0;
            this.forwardFollower = Data.setUp(
                "x", this.lastX,
                "y", this.lastY,
                "orientation", this.lastOrientation
            );
            
            this.lastFollow = Data.setUp(
                "entity", null,
                "mode", null,
                "offsetX", 0,
                "offsetY", 0,
                "begin", 0
            );
            
            this.xMagnitude = 0;
            this.yMagnitude = 0;
            this.xWaveLength = 0;
            this.yWaveLength = 0;
            this.xShakeTime = 0;
            this.yShakeTime = 0;
            this.shakeTime = 0;
            this.shakeIncrementor = 0;
            
            this.direction = true;
            this.stationary = false;
            
            this.viewportUpdate = false;
            
            if (this.owner.container) {
                this.parentContainer = this.owner.container;
            } else if (this.owner.stage) {
                this.canvas = this.canvas || Application.instance.display.canvas; //TODO: Probably need to find a better way to handle resizing - DDD 10/4/2015
                this.parentContainer = this.owner.stage;
                this.owner.width  = this.canvas.width;
                this.owner.height = this.canvas.height;
            } else {
                platypus.debug.warn('Camera: There appears to be no Container on this entity for the camera to display.');
            }
            this.container = new PIXI.Container();
            this.matrix = this.container.transformMatrix = new PIXI.Matrix();
            this.parentContainer.addChild(this.container);
        },
        events: {
            /**
             * Sets up the camera window size on load.
             *
             * @method 'load'
             */
            "load": function () {
                this.resize();
            },
            
            /**
             * On receiving this message, the camera begins viewing the world.
             *
             * @method 'render-world'
             * @param data {Object} Information about the world.
             * @param data.world {PIXI.Container} The container containing world entities.
             */
            "render-world": function (data) {
                this.world = data.world;
                this.world.transformMatrix = this.world.transformMatrix || new PIXI.Matrix();
                this.container.addChild(this.world);
            },
            
            /**
             * If children entities are listening for a `camera-update` message, they are added to an internal list.
             *
             * @method 'child-entity-added'
             * @param entity {platypus.Entity} Expects an entity as the message object to determine whether to trigger `camera-update` on it.
              **/
            "child-entity-added": function (entity) {
                this.viewportUpdate = true;
                
                if (this.worldIsLoaded) {
                    /**
                     * On receiving a "world-loaded" message, the camera broadcasts the world size to all children in the world.
                     *
                     * @event 'camera-loaded'
                     * @param message
                     * @param message.world {platypus.AABB} The dimensions of the world map.
                     **/
                    entity.triggerEvent('camera-loaded', this.cameraLoadedMessage);
                }
            },

            /**
             * Triggers "camera-update" on newly changed entities.
             *
             * @method 'child-entity-updated'
             * @param entity {platypus.Entity} Expects an entity as the message object to determine whether to trigger `camera-update` on it.
             * @since 0.6.8
             **/
            "child-entity-updated": function (entity) {
                this.viewportUpdate = true;
                
                if (this.worldIsLoaded) {
                    entity.triggerEvent('camera-update', this.message);
                }
            },

            /**
             * On receiving this message, the camera updates its world location and size as necessary. An example of this message is triggered by the [TiledLoader](platypus.components.TiledLoader.html) component.
             *
             * @method 'world-loaded'
             * @param message {Object}
             * @param [message.width] {number} The width of the loaded world.
             * @param [message.height] {number} The height of the loaded world.
             * @param [message.camera] {platypus.Entity} An entity that the camera should follow in the loaded world.
             **/
            "world-loaded": function (values) {
                var msg = this.message;
                
                msg.viewport.set(this.worldCamera.viewport);
                this.worldDimensions.set(values.world);
                
                this.worldIsLoaded = true;
                if (values.camera) {
                    this.follow(values.camera);
                }
                if (this.owner.triggerEventOnChildren) {
                    this.owner.triggerEventOnChildren('camera-loaded', this.cameraLoadedMessage);
                }
                this.updateMovementMethods();
            },
            
            "mousedown": function (event) {
                var worldVP = this.worldCamera.viewport;

                if (this.state === 'mouse-pan') {
                    if (!this.mouseVector) {
                        this.mouseVector = Vector.setUp();
                        this.mouseWorldOrigin = Vector.setUp();
                    }
                    this.mouse = this.mouseVector;
                    this.mouse.x = event.event.x;
                    this.mouse.y = event.event.y;
                    this.mouseWorldOrigin.x = worldVP.x;
                    this.mouseWorldOrigin.y = worldVP.y;
                }
            },
            
            "pressmove": function (event) {
                if (this.mouse) {
                    if (this.move(this.mouseWorldOrigin.x + (this.mouse.x - event.event.x) / this.world.transformMatrix.a, this.mouseWorldOrigin.y + (this.mouse.y - event.event.y) / this.world.transformMatrix.d)) {
                        this.viewportUpdate = true;
                    }
                }
            },

            "pressup": function () {
                this.mouse = null;
            },
            
            /**
             * On a "tick" step event, the camera updates its location according to its current state.
             *
             * @method 'tick'
             * @param message {Object}
             * @param message.delta {Number} If necessary, the current camera update function may require the length of the tick to adjust movement rate.
             **/
            "tick": function (resp) {
                var msg       = this.message,
                    viewport  = msg.viewport,
                    transform = null,
                    worldCamera = this.worldCamera;
                
                if ((this.state === 'following') && this.followingFunction(this.following, resp.delta)) {
                    this.viewportUpdate = true;
                }
                
                // Need to update owner's size information for changes to canvas size
                if (this.canvas) {
                    this.owner.width  = this.canvas.width;
                    this.owner.height = this.canvas.height;
                }
                
                // Check for owner resizing
                if ((this.owner.width !== this.lastWidth) || (this.owner.height !== this.lastHeight)) {
                    this.resize();
                    this.lastWidth = this.owner.width;
                    this.lastHeight = this.owner.height;
                }
                
                if (this.viewportUpdate) {
                    this.viewportUpdate = false;
                    this.stationary = false;
                    msg.stationary = false;
                    
                    viewport.set(worldCamera.viewport);

                    if (this.shakeIncrementor < this.shakeTime) {
                        this.viewportUpdate = true;
                        this.shakeIncrementor += resp.delta;
                        this.shakeIncrementor = Math.min(this.shakeIncrementor, this.shakeTime);
                        
                        if (this.shakeIncrementor < this.xShakeTime) {
                            viewport.moveX(viewport.x + Math.sin((this.shakeIncrementor / this.xWaveLength) * (Math.PI * 2)) * this.xMagnitude);
                        }
                        
                        if (this.shakeIncrementor < this.yShakeTime) {
                            viewport.moveY(viewport.y + Math.sin((this.shakeIncrementor / this.yWaveLength) * (Math.PI * 2)) * this.yMagnitude);
                        }
                    }

                    // Set up the rest of the camera message:
                    msg.scaleX         = this.windowPerWorldUnitWidth;
                    msg.scaleY         = this.windowPerWorldUnitHeight;
                    msg.orientation    = worldCamera.orientation;
                    
                    // Transform the world to appear within camera
                    //this.world.setTransform(viewport.halfWidth * msg.scaleX, viewport.halfHeight * msg.scaleY, msg.scaleX, msg.scaleY, (msg.orientation || 0) * 180 / Math.PI, 0, 0, viewport.x, viewport.y);
                    transform = this.world.transformMatrix;
                    transform.a = msg.scaleX;
                    transform.b = 0;
                    transform.c = 0;
                    transform.d = msg.scaleY;
                    if (msg.orientation) {
                        transform.rotate(msg.orientation);
                    }
                    transform.tx = (viewport.halfWidth - viewport.x) * msg.scaleX;
                    transform.ty = (viewport.halfHeight - viewport.y) * msg.scaleY;
                    
                    /**
                     * This component fires "camera-update" when the position of the camera in the world has changed. This event is triggered on both the entity (typically a layer) as well as children of the entity.
                     *
                     * @event 'camera-update'
                     * @param message {Object}
                     * @param message.world {platypus.AABB} The dimensions of the world map.
                     * @param message.orientation {Number} Number describing the orientation of the camera.
                     * @param message.scaleX {Number} Number of window pixels that comprise a single world coordinate on the x-axis.
                     * @param message.scaleY {Number} Number of window pixels that comprise a single world coordinate on the y-axis.
                     * @param message.viewport {platypus.AABB} An AABB describing the world viewport area.
                     * @param message.stationary {Boolean} Whether the camera is moving.
                     **/
                    this.owner.triggerEvent('camera-update', msg);
                    if (this.owner.triggerEventOnChildren) {
                        this.owner.triggerEventOnChildren('camera-update', msg);
                    }
                } else if (!this.stationary) {
                    this.stationary = true;
                    msg.stationary = true;

                    this.owner.triggerEvent('camera-update', msg);
                    if (this.owner.triggerEventOnChildren) {
                        this.owner.triggerEventOnChildren('camera-update', msg);
                    }
                }
                
                if (this.lastFollow.begin) {
                    if (this.lastFollow.begin < Date.now()) {
                        this.follow(this.lastFollow);
                    }
                }
            },
            
            /**
            * The camera listens for this event to change its world viewport size.
            *
            * @method 'resize-camera'
            * @param dimensions {Object} List of key/value pairs describing new viewport size
            * @param dimensions.width {number} Width of the camera viewport
            * @param dimensions.height {number} Height of the camera viewport
            **/
            "resize-camera": function (dimensions) {
                this.worldCamera.viewport.resize(dimensions.width, dimensions.height);
                this.resize();
            },
            
            /**
             * The camera listens for this event to change its position in the world.
             *
             * @method 'relocate'
             * @param location {Vector|Object} List of key/value pairs describing new location
             * @param location.x {Number} New position along the x-axis.
             * @param location.y {Number} New position along the y-axis.
             * @param [location.time] {Number} The time to transition to the new location.
             * @param [location.ease] {Function} The ease function to use. Defaults to a linear transition.
             */
            "relocate": (function () {
                var move = function (v) {
                        if (this.move(v.x, v.y)) {
                            this.viewportUpdate = true;
                        }
                    },
                    stop = function () {
                        this.recycle();
                    };

                return function (location) {
                    var v = null,
                        worldVP = this.worldCamera.viewport;

                    if (location.time && window.createjs && createjs.Tween) {
                        v = Vector.setUp(worldVP.x, worldVP.y);
                        createjs.Tween.get(v).to({x: location.x, y: location.y}, location.time, location.ease).on('change', move.bind(this, v)).call(stop.bind(v));
                    } else if (this.move(location.x, location.y)) {
                        this.viewportUpdate = true;
                    }
                };
            }()),
            
            /**
            * On receiving this message, the camera begins following the requested object.
            *
            * @method 'follow'
            * @param message {Object}
            * @param message.mode {String} Can be "locked", "forward", "bounding", "anchor-bound", or "static". "static" suspends following, but the other three settings require that the entity parameter be defined. Also set the bounding area parameters if sending "bounding" as the following method and the movement parameters if sending "forward" as the following method.
            * @param [message.entity] {platypus.Entity} The entity that the camera should commence following.
            * @param [message.top] {number} The top of a bounding box following an entity.
            * @param [message.left] {number} The left of a bounding box following an entity.
            * @param [message.width] {number} The width of a bounding box following an entity.
            * @param [message.height] {number} The height of a bounding box following an entity.
            * @param [message.movementX] {number} Movement multiplier for focusing the camera ahead of a moving entity in the horizontal direction.
            * @param [message.movementY] {number} Movement multiplier for focusing the camera ahead of a moving entity in the vertical direction.
            * @param [message.offsetX] {number} How far to offset the camera from the entity horizontally.
            * @param [message.offsetY] {number} How far to offset the camera from the entity vertically.
            * @param [message.time] {number} How many milliseconds to follow the entity.
            **/
            "follow": function (def) {
                this.follow(def);
            },
            
            /**
            * On receiving this message, the camera will shake around its target location.
            *
            * @method 'shake'
            * @param shake {Object}
            * @param [shake.xMagnitude] {number} How much to move along the x axis.
            * @param [shake.yMagnitude] {number} How much to move along the y axis.
            * @param [shake.xFrequency] {number} How quickly to shake along the x axis.
            * @param [shake.yFrequency] {number} How quickly to shake along the y axis.
            * @param [shake.time] {number} How long the camera should shake.
            **/
            "shake": function (shakeDef) {
                var def = shakeDef || {},
                    xMag    = def.xMagnitude || 0,
                    yMag    = def.yMagnitude || 0,
                    xFreq   = def.xFrequency || 0, //Cycles per second
                    yFreq   = def.yFrequency || 0, //Cycles per second
                    second  = 1000,
                    time    = def.time || 0;
                
                this.viewportUpdate = true;
                
                this.shakeIncrementor = 0;
                
                this.xMagnitude = xMag;
                this.yMagnitude = yMag;
                
                if (xFreq === 0) {
                    this.xWaveLength = 1;
                    this.xShakeTime = 0;
                } else {
                    this.xWaveLength = (second / xFreq);
                    this.xShakeTime = Math.ceil(time / this.xWaveLength) * this.xWaveLength;
                }
                
                if (yFreq === 0) {
                    this.yWaveLength = 1;
                    this.yShakeTime = 0;
                } else {
                    this.yWaveLength = (second / yFreq);
                    this.yShakeTime = Math.ceil(time / this.yWaveLength) * this.yWaveLength;
                }
                
                this.shakeTime = Math.max(this.xShakeTime, this.yShakeTime);
            }
        },
        
        methods: {
            follow: function (def) {
                var portion = 0.1;
                
                if (def.time) { //save current follow
                    if (!this.lastFollow.begin) {
                        this.lastFollow.entity = this.following;
                        this.lastFollow.mode   = this.mode;
                        this.lastFollow.offsetX = this.offsetX;
                        this.lastFollow.offsetY = this.offsetY;
                    }
                    this.lastFollow.begin  = Date.now() + def.time;
                } else if (this.lastFollow.begin) {
                    this.lastFollow.begin = 0;
                }
                
                this.mode = def.mode;
                
                switch (def.mode) {
                case 'locked':
                    this.state = 'following';
                    this.following = def.entity;
                    this.followingFunction = this.lockedFollow;
                    this.offsetX = def.offsetX || 0;
                    this.offsetY = def.offsetY || 0;
                    this.offsetAngle = def.offsetAngle || 0;
                    break;
                case 'forward':
                    this.state = 'following';
                    this.followFocused   = false;
                    this.following       = def.entity;
                    this.lastX           = def.entity.x - def.offsetX || 0;
                    this.lastY           = def.entity.y - def.offsetY || 0;
                    this.lastOrientation = def.entity.orientation || 0;
                    this.forwardX  = def.movementX || (this.transitionX * portion);
                    this.forwardY  = def.movementY || (this.transitionY * portion);
                    this.averageOffsetX = 0;
                    this.averageOffsetY = 0;
                    this.averageOffsetAngle = 0;
                    this.offsetX = def.offsetX || 0;
                    this.offsetY = def.offsetY || 0;
                    this.offsetAngle = def.offsetAngle || 0;
                    this.followingFunction = this.forwardFollow;
                    break;
                case 'bounding':
                    this.state = 'following';
                    this.following = def.entity;
                    this.offsetX = def.offsetX || 0;
                    this.offsetY = def.offsetY || 0;
                    this.offsetAngle = def.offsetAngle || 0;
                    this.boundingBox.setAll(def.x, def.y, def.width, def.height);
                    this.followingFunction = this.boundingFollow;
                    break;
                case 'anchor-bound':
                    this.state = 'following';
                    this.following = def.entity;
                    this.followingFunction = anchorBound.bind(this, def.anchorAABB, def.offsetX || 0, def.offsetY || 0);
                    break;
                case 'pan':
                    this.state = 'mouse-pan';
                    this.following = null;
                    this.followingFunction = null;
                    if (def && (typeof def.x === 'number') && (typeof def.y === 'number')) {
                        this.move(def.x, def.y, def.orientation || 0);
                        this.viewportUpdate = true;
                    }
                    break;
                default:
                    this.state = 'static';
                    this.following = null;
                    this.followingFunction = null;
                    if (def && (typeof def.x === 'number') && (typeof def.y === 'number')) {
                        this.move(def.x, def.y, def.orientation || 0);
                        this.viewportUpdate = true;
                    }
                    break;
                }
                
                if (def.begin) { // get rid of last follow
                    def.begin = 0;
                }

            },
            
            move: function (x, y, newOrientation) {
                var moved = this.moveX(x);
                moved = this.moveY(y) || moved;
                if (this.rotate) {
                    moved = this.reorient(newOrientation || 0) || moved;
                }
                return moved;
            },
            
            moveX: doNothing,
            
            moveY: doNothing,
            
            reorient: function (newOrientation) {
                var errMargin = 0.0001,
                    worldCamera = this.worldCamera;
                
                if (Math.abs(worldCamera.orientation - newOrientation) > errMargin) {
                    worldCamera.orientation = newOrientation;
                    return true;
                }
                return false;
            },
            
            lockedFollow: (function () {
                var min = Math.min,
                    getTransitionalPoint = function (a, b, ratio) {
                        // Find point between two points according to ratio.
                        return ratio * b + (1 - ratio) * a;
                    },
                    getRatio = function (transition, time) {
                        // Look at the target transition time (in milliseconds) and set up ratio accordingly.
                        if (transition) {
                            return min(time / transition, 1);
                        } else {
                            return 1;
                        }
                    };
                
                return function (entity, time) {
                    var worldCamera = this.worldCamera,
                        worldVP = worldCamera.viewport,
                        x = getTransitionalPoint(worldVP.x, entity.x, getRatio(this.transitionX, time)),
                        y = getTransitionalPoint(worldVP.y, entity.y, getRatio(this.transitionY, time));

                    if (this.rotate) { // Only run the orientation calculations if we need them.
                        return this.move(x, y, getTransitionalPoint(worldCamera.orientation, -(entity.orientation || 0), getRatio(this.transitionAngle, time)));
                    } else {
                        return this.move(x, y, 0);
                    }
                };
            }()),
            
            forwardFollow: function (entity, time) {
                var avgFraction = 0.9,
                    avgFractionFlip = 1 - avgFraction,
                    ff = this.forwardFollower,
                    moved  = false,
                    ms = 15,
                    standardizeTimeDistance = ms / time, //This allows the camera to pan appropriately on slower devices or longer ticks
                    worldCamera = this.worldCamera,
                    worldVP = worldCamera.viewport,
                    x = entity.x + this.offsetX,
                    y = entity.y + this.offsetY,
                    a = (entity.orientation || 0) + this.offsetAngle;
                
                if (this.followFocused && (this.lastX === x) && (this.lastY === y)) {
                    return this.lockedFollow(ff, time);
                } else {
                    // span over last 10 ticks to prevent jerkiness
                    this.averageOffsetX *= avgFraction;
                    this.averageOffsetY *= avgFraction;
                    this.averageOffsetX += avgFractionFlip * (x - this.lastX) * standardizeTimeDistance;
                    this.averageOffsetY += avgFractionFlip * (y - this.lastY) * standardizeTimeDistance;

                    if (Math.abs(this.averageOffsetX) > (worldVP.width / (this.forwardX * 2))) {
                        this.averageOffsetX = 0;
                    }
                    if (Math.abs(this.averageOffsetY) > (worldVP.height / (this.forwardY * 2))) {
                        this.averageOffsetY = 0;
                    }
                    
                    if (this.rotate) {
                        this.averageOffsetAngle *= avgFraction;
                        this.averageOffsetAngle += avgFractionFlip * (a - this.lastOrientation) * standardizeTimeDistance;
                        if (Math.abs(this.averageOffsetAngle) > (worldCamera.orientation / (this.forwardAngle * 2))) {
                            this.averageOffsetAngle = 0;
                        }
                    }

                    ff.x = this.averageOffsetX * this.forwardX + x;
                    ff.y = this.averageOffsetY * this.forwardY + y;
                    ff.orientation = this.averageOffsetAngle * this.forwardAngle + a;
                    
                    this.lastX = x;
                    this.lastY = y;
                    this.lastOrientation = a;
                    
                    moved = this.lockedFollow(ff, time);

                    if (!this.followFocused && !moved) {
                        this.followFocused = true;
                    }
                    
                    return moved;
                }
                
                
            },
            
            boundingFollow: function (entity, time) {
                var x = 0,
                    y = 0,
                    ratioX  = (this.transitionX ? Math.min(time / this.transitionX, 1) : 1),
                    iratioX = 1 - ratioX,
                    ratioY  = (this.transitionY ? Math.min(time / this.transitionY, 1) : 1),
                    iratioY = 1 - ratioY,
                    worldVP = this.worldCamera.viewport;
                
                this.boundingBox.move(worldVP.x, worldVP.y);
                
                if (entity.x > this.boundingBox.right) {
                    x = entity.x - this.boundingBox.halfWidth;
                } else if (entity.x < this.boundingBox.left) {
                    x = entity.x + this.boundingBox.halfWidth;
                }
                
                if (entity.y > this.boundingBox.bottom) {
                    y = entity.y - this.boundingBox.halfHeight;
                } else if (entity.y < this.boundingBox.top) {
                    y = entity.y + this.boundingBox.halfHeight;
                }
                
                if (x !== 0) {
                    x = this.moveX(ratioX * x + iratioX * worldVP.x);
                }
                
                if (y !== 0) {
                    y = this.moveY(ratioY * y + iratioY * worldVP.y);
                }
                
                return x || y;
            },
            
            resize: function () {
                var worldAspectRatio = this.width / this.height,
                    windowAspectRatio = this.owner.width / this.owner.height,
                    worldVP = this.worldCamera.viewport;
                
                //The dimensions of the camera in the window
                this.viewport.setAll(this.owner.width / 2, this.owner.height / 2, this.owner.width, this.owner.height);
                
                if (!this.stretch) {
                    if (windowAspectRatio > worldAspectRatio) {
                        if (this.overflow) {
                            worldVP.resize(this.height * windowAspectRatio, this.height);
                        } else {
                            this.viewport.resize(this.viewport.height * worldAspectRatio, this.viewport.height);
                        }
                    } else if (this.overflow) {
                        worldVP.resize(this.width, this.width / windowAspectRatio);
                    } else {
                        this.viewport.resize(this.viewport.width, this.viewport.width / worldAspectRatio);
                    }
                }
                
                this.worldPerWindowUnitWidth  = worldVP.width  / this.viewport.width;
                this.worldPerWindowUnitHeight = worldVP.height / this.viewport.height;
                this.windowPerWorldUnitWidth  = this.viewport.width  / worldVP.width;
                this.windowPerWorldUnitHeight = this.viewport.height / worldVP.height;
                
                //this.container.cache(0, 0, this.viewport.width, this.viewport.height, 1);
                this.matrix.tx = this.viewport.x - this.viewport.halfWidth;
                this.matrix.ty = this.viewport.y - this.viewport.halfHeight;
                
                this.viewportUpdate = true;
                
                this.updateMovementMethods();
            },
            
            updateMovementMethods: (function () {
                // This is used to change movement modes as needed rather than doing a check every tick to determine movement type. - DDD 2/29/2016
                var doNot = doNothing,
                    centerX = function () {
                        var world = this.worldDimensions;
                        
                        this.worldCamera.viewport.moveX(world.width / 2 + world.left);
                        this.moveX = doNot;
                        return true;
                    },
                    centerY = function () {
                        var world = this.worldDimensions;
                        
                        this.worldCamera.viewport.moveY(world.height / 2 + world.top);
                        this.moveY = doNot;
                        return true;
                    },
                    containX = function (x) {
                        var aabb = this.worldCamera.viewport,
                            d = this.worldDimensions,
                            w = d.width,
                            l = d.left;
                        
                        if (Math.abs(aabb.x - x) > this.threshold) {
                            if (x + aabb.halfWidth > w + l) {
                                aabb.moveX(w - aabb.halfWidth + l);
                            } else if (x < aabb.halfWidth + l) {
                                aabb.moveX(aabb.halfWidth + l);
                            } else {
                                aabb.moveX(x);
                            }
                            return true;
                        }
                        return false;
                    },
                    containY = function (y) {
                        var aabb = this.worldCamera.viewport,
                            d = this.worldDimensions,
                            h = d.height,
                            t = d.top;
                        
                        if (Math.abs(aabb.y - y) > this.threshold) {
                            if (y + aabb.halfHeight > h + t) {
                                aabb.moveY(h - aabb.halfHeight + t);
                            } else if (y < aabb.halfHeight + t) {
                                aabb.moveY(aabb.halfHeight + t);
                            } else {
                                aabb.moveY(y);
                            }
                            return true;
                        }
                        return false;
                    },
                    allX = function (x) {
                        var aabb = this.worldCamera.viewport;
                        
                        if (Math.abs(aabb.x - x) > this.threshold) {
                            aabb.moveX(x);
                            return true;
                        }
                        return false;
                    },
                    allY = function (y) {
                        var aabb = this.worldCamera.viewport;
                        
                        if (Math.abs(aabb.y - y) > this.threshold) {
                            aabb.moveY(y);
                            return true;
                        }
                        return false;
                    };
                
                return function () {
                    var threshold = this.threshold,
                        worldVP = this.worldCamera.viewport,
                        world = this.worldDimensions,
                        w = world.width,
                        h = world.height;
                    
                    if (!w) {
                        this.moveX = allX;
                    } else if (w < worldVP.width) {
                        this.moveX = centerX;
                    } else {
                        this.moveX = containX;
                    }

                    if (!h) {
                        this.moveY = allY;
                    } else if (h < worldVP.height) {
                        this.moveY = centerY;
                    } else {
                        this.moveY = containY;
                    }

                    // Make sure camera is correctly contained:
                    this.threshold = -1; // forces update
                    this.moveX(worldVP.x);
                    this.moveY(worldVP.y);
                    this.threshold = threshold;
                };
            }()),
            
            destroy: function () {
                this.parentContainer.removeChild(this.container);
                this.parentContainer = null;
                this.container = null;
                if (this.mouseVector) {
                    this.mouseVector.recycle();
                    this.mouseWorldOrigin.recycle();
                }
                
                this.boundingBox.recycle();
                this.viewport.recycle();
                this.worldCamera.viewport.recycle();
                this.worldCamera.recycle();
                this.message.viewport.recycle();
                this.message.recycle();
                this.cameraLoadedMessage.recycle();
                this.worldDimensions.recycle();
    
                this.forwardFollower.recycle();
                this.lastFollow.recycle();
            }
        }
    });
}());

//##############################################################################
// CameraFollowMe.js
//##############################################################################

/**
 * This component can request that the camera focus on this entity.
 *
 * @namespace platypus.components
 * @class CameraFollowMe
 * @uses platypus.Component
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Data = include('platypus.Data');

    return platypus.createComponentClass({
        id: 'CameraFollowMe',
        
        properties: {
            /**
             * Sets initial camera settings when the entity is being followed. This can be over-written by the "follow-me" call itself. If any of these attributes are not provided, the following are used by default:
             *
                  {
                      "time": 500,
                      // Optional. Time in milliseconds that the camera should focus before returning to the original focus.
                      
                      "mode": "forward",
                      // Optional. Camera mode that the camera should use.
                      
                      "top": 100,
                      // Optional number specifying top of viewport in world coordinates
                      
                      "left": 100,
                      // Optional number specifying left of viewport in world coordinates
                      
                      "width": 100,
                      // Optional number specifying width of viewport in world coordinates
                      
                      "height": 100,
                      // Optional number specifying height of viewport in world coordinates
                      
                      "offsetX": 20,
                      // Optional number setting how far to offset the camera from the entity horizontally.
                      
                      "offsetY": 40
                      // Optional number setting how far to offset the camera from the entity vertically.
                  }
             *
             * @property camera
             * @type Object
             * @default {}
             */
            camera: {},
            
            /**
             * Camera mode that the camera should use.
             *
             * @property mode
             * @type String
             * @default "forward"
             */
            mode: "forward",

            /**
             * Whether to pause the game while the camera is focused.
             *
             * @property pause
             * @type boolean
             * @default false
             */
            pause: false
        },
        
        constructor: function () {
            this.pauseGame = (this.pause && this.camera.time) ? {
                time: this.camera.time
            } : null;
            
            this.camera = Data.setUp(
                "entity", this.owner,
                "mode", this.camera.mode || this.mode,
                "top", this.camera.top,
                "left", this.camera.left,
                "offsetX", this.camera.offsetX,
                "offsetY", this.camera.offsetY,
                "width", this.camera.width,
                "height", this.camera.height,
                "time", this.camera.time
            );
        },
        
        events: {
            /**
             * On receiving this message, the component will trigger a message requesting that the parent camera begin following this entity.
             *
             * @method 'follow-me'
             * @param [options] {Object} A list of key/value paris describing camera options to set.
             * @param [options.mode] {String} Camera following mode.
             * @param [options.top] {number} The top of a bounding box.
             * @param [options.left] {number} The left of a bounding box.
             * @param [options.width] {number} The width of a bounding box.
             * @param [options.height] {number} The height of a bounding box.
             * @param [options.offsetX] {number} How far to offset the camera from the entity horizontally.
             * @param [options.offsetY] {number} How far to offset the camera from the entity vertically.
             * @param [options.time] {number} How many milliseconds to follow the entity.
             */
            "follow-me": function (options) {
                var msg = null;
                
                if (options) {
                    msg = Data.setUp(
                        "entity",  this.owner,
                        "mode",    options.mode    || this.camera.mode,
                        "top",     options.top     || this.camera.top,
                        "left",    options.left    || this.camera.left,
                        "offsetX", options.offsetX || this.camera.offsetX,
                        "offsetY", options.offsetY || this.camera.offsetY,
                        "width",   options.width   || this.camera.width,
                        "height",  options.height  || this.camera.height,
                        "time",    options.time    || this.camera.time
                    );
                } else {
                    msg = Data.setUp(this.camera);
                }

                if (this.pauseGame) {

                    /**
                     * This component fires this message on the parent entity to pause logic if required.
                     *
                     * @event 'pause-logic'
                     * @param options {Object}
                     * @param options.time {number} The amount of time to pause before re-enabling logic.
                     */
                    this.owner.parent.triggerEvent('pause-logic',  this.pauseGame);
                    
                    /**
                     * This component fires this message on the parent entity to pause rendering if required.
                     *
                     * @event 'pause-render'
                     * @param options {Object}
                     * @param options.time {number} The amount of time to pause before re-enabling render updates.
                     */
                    this.owner.parent.triggerEvent('pause-render', this.pauseGame);
                }
                
                /**
                 * This component fires this message on this entity's parent so the camera will begin following this entity.
                 *
                 * @event 'follow'
                 * @param options {Object} A list of key/value pairs describing camera options to set.
                 * @param options.entity {platypus.Entity} Sends this entity for the camera to follow.
                 * @param options.mode {String} Camera following mode.
                 * @param options.top {number} The top of a bounding box.
                 * @param options.left {number} The left of a bounding box.
                 * @param options.width {number} The width of a bounding box.
                 * @param options.height {number} The height of a bounding box.
                 * @param options.offsetX {number} How far to offset the camera from the entity horizontally.
                 * @param options.offsetY {number} How far to offset the camera from the entity vertically.
                 * @param options.time {number} How many milliseconds to follow the entity.
                 */
                this.owner.parent.triggerEvent('follow', msg);
                
                msg.recycle();
            }
        },
        
        methods: {
            destroy: function () {
                this.camera.recycle();
            }
        }
    });
}());

//##############################################################################
// CollisionBasic.js
//##############################################################################

/**
 * This component causes this entity to collide with other entities. It must be part of a collision group and will receive messages when colliding with other entities in the collision group.
 *
 * Multiple collision components may be added to a single entity if distinct messages should be triggered for certain collision areas on the entity or if the soft collision area is a different shape from the solid collision area. Be aware that too many additional collision areas may adversely affect performance.
 *
 * @namespace platypus.components
 * @class CollisionBasic
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var AABB = include('platypus.AABB'),
        CollisionShape = include('platypus.CollisionShape'),
        Data = include('platypus.Data'),
        DataMap = include('platypus.DataMap'),
        Vector = include('platypus.Vector'),

        /**
         * On receiving a 'hit-by' message, custom messages are triggered on the entity corresponding with the component's `solidCollisions` and `softCollisions` key/value mappings.
         *
         * @event *
         * @param collision {Object} A list of key/value pairs describing the collision.
         */
        entityBroadcast = (function () {
            var stringBroadcast = function (event, collisionType, solidOrSoft, value) {
                    if (value.myType === collisionType) {
                        if (value.hitType === solidOrSoft) {
                            this.owner.triggerEvent(event, value);
                        }
                    }
                },
                arrayBroadcast = function (event, collisionType, solidOrSoft, value) {
                    var i = 0;
                    
                    if (value.myType === collisionType) {
                        if (value.hitType === solidOrSoft) {
                            for (i = 0; i < event.length; i++) {
                                this.owner.triggerEvent(event[i], value);
                            }
                        }
                    }
                },
                directionalBroadcast = function (event, collisionType, solidOrSoft, collisionInfo) {
                    var dx = collisionInfo.x,
                        dy = collisionInfo.y;

                    if (collisionInfo.entity && !(dx || dy)) {
                        dx = collisionInfo.entity.x - this.owner.x;
                        dy = collisionInfo.entity.y - this.owner.y;
                    }

                    if (collisionInfo.myType === collisionType) {
                        if (collisionInfo.hitType === solidOrSoft) {
                            if ((dy > 0) && event.bottom) {
                                this.owner.trigger(event.bottom, collisionInfo);
                            } else if ((dy < 0) && event.top) {
                                this.owner.trigger(event.top, collisionInfo);
                            }
                            if ((dx > 0) && event.right) {
                                this.owner.trigger(event.right, collisionInfo);
                            } else if ((dx < 0) && event.left) {
                                this.owner.trigger(event.left, collisionInfo);
                            }
                            if (event.all) {
                                this.owner.trigger(event.all, collisionInfo);
                            }
                        }
                    }
                };
            
            return function (self, event, solidOrSoft) {
                if (typeof event === 'string') {
                    return stringBroadcast.bind(self, event, self.collisionType, solidOrSoft);
                } else if (Array.isArray(event)) {
                    return arrayBroadcast.bind(self, event, self.collisionType, solidOrSoft);
                } else {
                    return directionalBroadcast.bind(self, event, self.collisionType, solidOrSoft);
                }
            };
        }()),
        setupCollisionFunctions = (function () {
            var entityGetAABB = function (aabb, colFuncs, collisionType) {
                    var keys = colFuncs.keys,
                        i = keys.length,
                        funcs = null;

                    if (!collisionType) {
                        aabb.reset();
                        while (i--) {
                            aabb.include(colFuncs.get(keys[i]).getAABB());
                        }
                        return aabb;
                    } else {
                        funcs = colFuncs.get(collisionType);
                        if (funcs) {
                            return funcs.getAABB();
                        } else {
                            return null;
                        }
                    }
                },
                entityGetPreviousAABB = function (colFuncs, collisionType) {
                    var colFunc = colFuncs.get(collisionType);
                    
                    if (colFunc) {
                        return colFunc.getPreviousAABB();
                    } else {
                        return null;
                    }
                },
                entityGetShapes = function (colFuncs, collisionType) {
                    var colFunc = colFuncs.get(collisionType);
                    
                    if (colFunc) {
                        return colFunc.getShapes();
                    } else {
                        return null;
                    }
                },
                entityGetPrevShapes = function (colFuncs, collisionType) {
                    var colFunc = colFuncs.get(collisionType);
                    
                    if (colFunc) {
                        return colFunc.getPrevShapes();
                    } else {
                        return null;
                    }
                },
                entityPrepareCollision = function (colFuncs, x, y) {
                    var keys = colFuncs.keys,
                        i = keys.length;
                    
                    while (i--) {
                        colFuncs.get(keys[i]).prepareCollision(x, y);
                    }
                },
                entityRelocateEntity = (function () {
                    var handleStuck = function (position, data, owner) {
                            var m = 0,
                                s = data.stuck;

                            if (s) {
                                m = position.magnitude();
                                if (data.thatShape.owner && (Math.abs(s) > 1)) {
                                    s *= 0.05;
                                }
                                if (!m || (m > Math.abs(s))) {
                                    if (data.vector.x) {
                                        position.x = s;
                                        position.y = 0;
                                    }
                                    if (data.vector.y) {
                                        position.x = 0;
                                        position.y = s;
                                    }
                                    if (owner.stuckWith) {
                                        owner.stuckWith.recycle();
                                    }
                                    owner.stuckWith = Vector.setUp(data.thatShape.x, data.thatShape.y);
                                }
                            }
                        },
                        message = {
                            position: null,
                            unstick: null
                        };
                    
                    return function (vector, collisionData) {
                        var colX = collisionData.xData[0],
                            colY = collisionData.yData[0],
                            msg = message,
                            v = null;

                        if (colX) {
                            v = Vector.setUp(0, 0, 0);
                            handleStuck(v, colX, this);
                        }

                        if (colY) {
                            v = v || Vector.setUp(0, 0, 0);
                            handleStuck(v, colY, this);
                        }

                        msg.position = vector;
                        msg.unstick = v;
                        this.triggerEvent('relocate-entity', msg);
                        
                        if (v) {
                            v.recycle();
                        }
                    };
                }()),
                entityMovePreviousX = function (colFuncs, x) {
                    var keys = colFuncs.keys,
                        i = keys.length;
                    
                    while (i--) {
                        colFuncs.get(keys[i]).movePreviousX(x);
                    }
                },
                entityGetCollisionTypes = function () {
                    return this.collisionTypes;
                },
                entityGetSolidCollisions = function () {
                    return this.solidCollisionMap;
                },
                getAABB = function () {
                    return this.getAABB();
                },
                getPreviousAABB = function () {
                    return this.getPreviousAABB();
                },
                getShapes = function () {
                    return this.getShapes();
                },
                getPrevShapes = function () {
                    return this.getPrevShapes();
                },
                prepareCollision = function (x, y) {
                    this.prepareCollision(x, y);
                },
                movePreviousX = function (x) {
                    this.movePreviousX(x);
                };
            
            return function (self, entity) {
                var colFuncs = entity.collisionFunctions;
                
                // This allows the same component type to be added multiple times.
                if (!colFuncs) {
                    colFuncs = entity.collisionFunctions = DataMap.setUp();
                    entity.aabb = AABB.setUp();
                    entity.getAABB = entityGetAABB.bind(entity, entity.aabb, colFuncs);
                    entity.getPreviousAABB = entityGetPreviousAABB.bind(entity, colFuncs);
                    entity.getShapes = entityGetShapes.bind(entity, colFuncs);
                    entity.getPrevShapes = entityGetPrevShapes.bind(entity, colFuncs);
                    entity.prepareCollision = entityPrepareCollision.bind(entity, colFuncs);
                    entity.relocateEntity = entityRelocateEntity.bind(entity);
                    entity.movePreviousX = entityMovePreviousX.bind(entity, colFuncs);
                    entity.getCollisionTypes = entityGetCollisionTypes.bind(entity);
                    entity.getSolidCollisions = entityGetSolidCollisions.bind(entity);
                }

                colFuncs.set(self.collisionType, Data.setUp(
                    "getAABB", getAABB.bind(self),
                    "getPreviousAABB", getPreviousAABB.bind(self),
                    "getShapes", getShapes.bind(self),
                    "getPrevShapes", getPrevShapes.bind(self),
                    "prepareCollision", prepareCollision.bind(self),
                    "movePreviousX", movePreviousX.bind(self)
                ));
            };
        }());

    return platypus.createComponentClass({
        
        id: 'CollisionBasic',

        properties: {
            /**
             * Defines how this entity should be recognized by other colliding entities.
             *
             * @property collisionType
             * @type String
             * @default "none"
             */
            collisionType: "none",

            /**
             * Defines the type of colliding shape.
             *
             * @property shapeType
             * @type String
             * @default "rectangle"
             */
            shapeType: "rectangle",
            
            /**
             * Determines whether the collision area should transform on orientation changes.
             *
             * @property ignoreOrientation
             * @type boolean
             * @default false
             */
            ignoreOrientation: false,
            
            /**
             * Determines the x-axis center of the collision shape.
             *
             * @property regX
             * @type number
             * @default width / 2
             */
            regX: null,
            
            /**
             * Determines the y-axis center of the collision shape.
             *
             * @property regY
             * @type number
             * @default height / 2
             */
            regY: null,
            
            /**
             * Sets the width of the collision area in world coordinates.
             *
             * @property width
             * @type number
             * @default 0
             */
            width: 0,
            
            /**
             * Sets the height of the collision area in world coordinates.
             *
             * @property height
             * @type number
             * @default 0
             */
            height: 0,
            
            /**
             * Sets the radius of a circle collision area in world coordinates.
             *
             * @property radius
             * @type number
             * @default 0
             */
            radius: 0,
            
            /**
             * Determines which collision types this entity should consider soft, meaning this entity may pass through them, but triggers collision messages on doing so. Example:
             *
             *     {
             *         "water": "soaked",       // This triggers a "soaked" message on the entity when it passes over a "water" collision-type entity.
             *         "lava": ["burn", "ouch"] // This triggers both messages on the entity when it passes over a "lava" collision-type entity.
             *     }
             *
             * @property softCollisions
             * @type Object
             * @default null
             */
            softCollisions: null,
            
            /**
             * Determines which collision types this entity should consider solid, meaning this entity should not pass through them. Example:
             *
             *     {
             *         "boulder": "",                       // This specifies that this entity should not pass through other "boulder" collision-type entities.
             *         "diamond": "crack-up",               // This specifies that this entity should not pass through "diamond" collision-type entities, but if it touches one, it triggers a "crack-up" message on the entity.
             *         "marble": ["flip", "dance", "crawl"] // This specifies that this entity should not pass through "marble" collision-type entities, but if it touches one, it triggers all three specified messages on the entity.
             *     }
             *
             * @property solidCollisions
             * @type Object
             * @default null
             */
            solidCollisions: null,
            
            /**
             * This is the margin around the entity's width and height. This is an alternative method for specifying the collision shape in terms of the size of the entity. Can also pass in an object specifying the following parameters if the margins vary per side: top, bottom, left, and right.
             *
             * @property margin
             * @type number|Object
             * @default 0
             */
            margin: 0,
            
            /**
             * Defines one or more shapes to create the collision area. Defaults to a single shape with the width, height, regX, and regY properties of the entity if not specified. See [CollisionShape](CollisionShape.html) for the full list of properties.
             *
             * @property shapes
             * @type Array
             * @default null
             */
            shapes: null
        },
        
        publicProperties: {
            /**
             * This property should be set to true if entity doesn't move for better optimization. This causes other entities to check against this entity, but this entity performs no checks of its own. Available on the entity as `entity.immobile`.
             *
             * @property immobile
             * @type boolean
             * @default false
             */
            immobile: false,

            /**
             * Whether this entity should be tested across its entire movement path. This is necessary for fast-moving entities, but shouldn't be used for others due to the processing overhead. Available on the entity as `entity.bullet`.
             *
             * @property bullet
             * @type boolean
             * @default false
             */
            bullet: false,
            
            /**
             * Whether the entity is only solid when being collided with from the top.
             *
             * @property jumpThrough
             * @type boolean
             * @default: false
             */
            jumpThrough: false
        },
        
        constructor: function (definition) {
            var arr = null,
                x            = 0,
                key          = '',
                shapes       = null,
                regX         = this.regX,
                regY         = this.regY,
                width        = this.width,
                height       = this.height,
                radius       = this.radius,
                marginLeft   = 0,
                marginRight  = 0,
                marginTop    = 0,
                marginBottom = 0;

            if (typeof this.margin === "number") {
                marginLeft   = this.margin;
                marginRight  = this.margin;
                marginTop    = this.margin;
                marginBottom = this.margin;
            } else {
                marginLeft   = this.margin.left || 0;
                marginRight  = this.margin.right || 0;
                marginTop    = this.margin.top || 0;
                marginBottom = this.margin.bottom || 0;
            }
            
            if (regX === null) {
                regX = this.regX = width / 2;
            }
            
            if (regY === null) {
                regY = this.regY = height / 2;
            }
            
            Vector.assign(this.owner, 'position', 'x', 'y', 'z');
            Vector.assign(this.owner, 'previousPosition', 'previousX', 'previousY', 'previousZ');
            this.owner.previousX = this.owner.previousX || this.owner.x;
            this.owner.previousY = this.owner.previousY || this.owner.y;
            
            this.aabb     = AABB.setUp();
            this.prevAABB = AABB.setUp();
            
            if (this.shapes) {
                shapes = this.shapes;
            } else if (this.shapeType === 'circle') {
                radius = radius || (((width || 0) + (height || 0)) / 4);
                shapes = [{
                    regX: (isNaN(regX) ? radius : regX) - (marginRight - marginLeft) / 2,
                    regY: (isNaN(regY) ? radius : regY) - (marginBottom - marginTop) / 2,
                    radius: radius,
                    type: this.shapeType
                }];
            } else {
                shapes = [{
                    //regX: (isNaN(regX) ? (width  || 0) / 2 : regX) - (marginRight  - marginLeft) / 2,
                    //regY: (isNaN(regY) ? (height || 0) / 2 : regY) - (marginBottom - marginTop)  / 2,
                    regX: (isNaN(regX) ? (width  || 0) / 2 : regX) + marginLeft,
                    regY: (isNaN(regY) ? (height || 0) / 2 : regY) + marginTop,
                    points: definition.points,
                    width: (width  || 0) + marginLeft + marginRight,
                    height: (height || 0) + marginTop  + marginBottom,
                    type: this.shapeType
                }];
            }
            
            this.owner.collisionTypes = this.owner.collisionTypes || Array.setUp();
            this.owner.collisionTypes.push(this.collisionType);
            
            this.shapes = Array.setUp();
            this.prevShapes = Array.setUp();
            this.entities = null;
            for (x = 0; x < shapes.length; x++) {
                this.shapes.push(CollisionShape.setUp(this.owner, shapes[x], this.collisionType));
                this.prevShapes.push(CollisionShape.setUp(this.owner, shapes[x], this.collisionType));
                this.prevAABB.include(this.prevShapes[x].aABB);
                this.aabb.include(this.shapes[x].aABB);
            }
            
            setupCollisionFunctions(this, this.owner);
            
            this.owner.solidCollisionMap = this.owner.solidCollisionMap || DataMap.setUp();
            arr = this.owner.solidCollisionMap.set(this.collisionType, Array.setUp());
            if (this.solidCollisions) {
                for (key in this.solidCollisions) {
                    if (this.solidCollisions.hasOwnProperty(key)) {
                        arr.push(key);
                        if (this.solidCollisions[key]) { // To make sure it's not an empty string.
                            this.addEventListener('hit-by-' + key, entityBroadcast(this, this.solidCollisions[key], 'solid'));
                        }
                    }
                }
            }
    
            this.owner.softCollisionMap = this.owner.softCollisionMap || DataMap.setUp();
            arr = this.owner.softCollisionMap.set(this.collisionType, Array.setUp());
            if (this.softCollisions) {
                for (key in this.softCollisions) {
                    if (this.softCollisions.hasOwnProperty(key)) {
                        arr.push(key);
                        if (this.softCollisions[key]) { // To make sure it's not an empty string.
                            this.addEventListener('hit-by-' + key, entityBroadcast(this, this.softCollisions[key], 'soft'));
                        }
                    }
                }
            }
            
            this.stuck = false;
        },
        
        events: {
            /**
             * On receiving this message, the component triggers `add-collision-entity` on the parent.
             *
             * @method 'collide-on'
             * @param type {String} If specified, only collision components of this type are added to the collision list.
             */
            "collide-on": function (type) {
                var owner = this.owner,
                    colType = this.collisionType,
                    colTypes = owner.collisionTypes;
                
                /**
                 * On receiving 'collide-on', this message is triggered on the parent to turn on collision.
                 *
                 * @event 'add-collision-entity'
                 * @param entity {platypus.Entity} The entity this component is attached to.
                 */
                if ((typeof type !== 'string') || (type === colType)) {
                    if (colTypes.indexOf(colType) === -1) {
                        colTypes.push(colType);
                    }
                    owner.parent.triggerEvent('add-collision-entity', owner);
                    this.active = true;
                }
            },
            
            /**
             * On receiving this message, the component triggers `remove-collision-entity` on the parent.
             *
             * @method 'collide-off'
             * @param type {String} If specified, only collision components of this type are removed from the collision list.
             */
            "collide-off": function (type) {
                var index = 0,
                    owner = this.owner,
                    parent = owner.parent,
                    colType = this.collisionType,
                    colTypes = owner.collisionTypes;
                
                /**
                 * On receiving 'collide-off', this message is triggered on the parent to turn off collision.
                 *
                 * @event 'remove-collision-entity'
                 * @param entity {platypus.Entity} The entity this component is attached to.
                 */
                if ((typeof type !== 'string') || (type === colType)) {
                    parent.triggerEvent('remove-collision-entity', owner);
                    index = colTypes.indexOf(colType);
                    if (index >= 0) {
                        colTypes.greenSplice(index);
                    }
                    this.active = false;

                    if (colTypes.length) {
                        parent.triggerEvent('add-collision-entity', owner);
                    }
                }
            },
            
            /**
             * This message causes the entity's x,y coordinates to update.
             *
             * @method 'relocate-entity'
             * @param position {platypus.Vector} The new coordinates.
             * @param [position.relative=false] {boolean} Determines whether the provided x,y coordinates are relative to the entity's current position.
             */
            "relocate-entity": function (resp) {
                var unstick = resp.unstick,
                    um      = 0,
                    i       = 0,
                    x       = 0,
                    y       = 0,
                    aabb    = this.aabb,
                    owner   = this.owner,
                    shape   = null,
                    shapes  = this.shapes;
                
                if (unstick) {
                    um = unstick.magnitude();
                }
                
                if (this.move) {
                    this.move.recycle();
                    this.move = null;
                }
                
                if (resp.relative) {
                    owner.position.setVector(owner.previousPosition).add(resp.position);
                } else {
                    owner.position.setVector(resp.position);
                }

                if (this.stuck) {
                    if (um > 0) {
                        owner.position.add(unstick);
                    } else {
                        this.stuck = false;
                    }
                }
                
                x = owner.x;
                y = owner.y;
                
                aabb.reset();
                i = shapes.length;
                while (i--) {
                    shape = shapes[i];
                    shape.update(x, y);
                    aabb.include(shape.aABB);
                }

                owner.previousPosition.setVector(owner.position);
                
                if (um > 0) { // to force check in all directions for ultimate stuck resolution (esp. for stationary entities)
                    if (!this.stuck) {
                        this.stuck = true;
                    }
                    this.move = owner.stuckWith.copy().add(-x, -y).normalize();
                }
            },
            
            /**
             * If the entity is stuck to another entity, this component tries to unstick the entity on each logic step.
             *
             * @method 'handle-logic'
             */
            "handle-logic": function () {
                if (this.move) {
                    this.owner.position.add(this.move); // By trying to move into it, we should get pushed back out.
                }
            },
            
            /**
             * Collision shapes are updated to reflect the new orientation when this message occurs.
             *
             * @method 'orientation-updated'
             * @param matrix {Array} A 2D matrix describing the new orientation.
             */
            "orientation-updated": function (matrix) {
                var i = 0;
                
                if (!this.ignoreOrientation) {
                    for (i = 0; i < this.shapes.length; i++) {
                        this.shapes[i].multiply(matrix);
                    }
                }
            }
        },
        
        methods: {
            getAABB: function () {
                return this.aabb;
            },
            
            getPreviousAABB: function () {
                return this.prevAABB;
            },
            
            getShapes: function () {
                return this.shapes;
            },
            
            getPrevShapes: function () {
                return this.prevShapes;
            },
            
            prepareCollision: function (x, y) {
                var i          = 0,
                    shape      = null,
                    prevShapes = this.shapes,
                    shapes     = this.prevShapes,
                    aabb       = this.aabb;
                
                this.owner.x = x;
                this.owner.y = y;
                
                this.prevShapes = prevShapes;
                this.shapes = shapes;
                
                this.prevAABB.set(aabb);
                aabb.reset();
                
                // update shapes
                i = shapes.length;
                while (i--) {
                    shape = shapes[i];
                    shape.update(x, y);
                    aabb.include(shape.aABB);
                }
            },
            
            movePreviousX: function (x) {
                var i = 0;
                
                this.prevAABB.moveX(x);
                for (i = 0; i < this.prevShapes.length; i++) {
                    this.prevShapes[i].setXWithEntityX(x);
                }
            },
            
            destroy: function () {
                var colFuncs = this.owner.collisionFunctions,
                    collisionType = this.collisionType,
                    i = this.owner.collisionTypes.indexOf(collisionType),
                    owner = this.owner;
                
                owner.parent.triggerEvent('remove-collision-entity', owner);

                this.aabb.recycle();
                delete this.aabb;
                this.prevAABB.recycle();
                delete this.prevAABB;
                
                if (i >= 0) {
                    owner.collisionTypes.greenSplice(i);
                }
                
                if (owner.solidCollisionMap.has(collisionType)) {
                    owner.solidCollisionMap.delete(collisionType).recycle();
                }
                if (owner.softCollisionMap.has(collisionType)) {
                    owner.softCollisionMap.delete(collisionType).recycle();
                }

                colFuncs.delete(collisionType).recycle();
                
                i = this.shapes.length;
                while (i--) {
                    this.shapes[i].recycle();
                    this.prevShapes[i].recycle();
                }
                this.shapes.recycle();
                this.prevShapes.recycle();
                delete this.shapes;
                delete this.prevShapes;

                delete this.entities;

                if (owner.collisionTypes.length) {
                    owner.parent.triggerEvent('add-collision-entity', owner);
                } else { //remove collision functions
                    colFuncs.recycle();
                    owner.collisionFunctions = null;
                    owner.solidCollisionMap.recycle();
                    owner.solidCollisionMap = null;
                    owner.softCollisionMap.recycle();
                    owner.softCollisionMap = null;
                    owner.aabb.recycle();
                    owner.aabb = null;
                }
            }
        }
    });
}());

//##############################################################################
// CollisionFilter.js
//##############################################################################

/**
 * This component will listen for a particular collision message and, depending on a given entity.state attribute, retrigger the collision as another collision message.
 *
 * @namespace platypus.components
 * @class CollisionFilter
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    var collidePos = function (state, event, collInfo) {
            if (this.state.get(state)) {
                this.trigger(event, collInfo);
            }
        },
        collideNeg = function (state, event, collInfo) {
            if (!this.state.get(state)) {
                this.trigger(event, collInfo);
            }
        };
    
    return platypus.createComponentClass({
        id: 'CollisionFilter',
        
        properties: {
            /**
             * One or more collision events for which to listen. For example, if the state property is set to "allergic":
             *
                   {
                       "hitting-flowers": "sneeze",
                       // Listen for "hitting-flowers", and if the entity is "allergic", trigger a "sneeze" event.
                    
                       "in-the-weeds": "cough"
                       // Another collision event that triggers "cough" if the entity is "allergic".
                   }
             *
             * @property collisions
             * @type Object
             * @default {}
             */
            collisions: {},
            
            /**
             * The entity state that should cause the following list of collisions to trigger events. If this state is not true, no events are triggered. To trigger events on the inverse of a state, place "!" before the state such as "!allergic".
             *
             * @property state
             * @type String
             * @default ""
             */
            state: ""
        },
        
        constructor: function () {
            var event      = "",
                collisions = this.collisions,
                state      = this.state;
            
            if (collisions) {
                /**
                 * Events defined by the `collisions` property trigger whenever collisions happen while in the defined state.
                 *
                 * @event *
                 * @param collisionData {CollisionData} Information regarding the collision that occurred.
                 */
                if (state[0] === '!') {
                    state = state.substring(1);
                    for (event in collisions) {
                        if (collisions.hasOwnProperty(event)) {
                            this.addEventListener(event, collideNeg.bind(this.owner, state, collisions[event]));
                        }
                    }
                } else {
                    for (event in collisions) {
                        if (collisions.hasOwnProperty(event)) {
                            this.addEventListener(event, collidePos.bind(this.owner, state, collisions[event]));
                        }
                    }
                }
            }
        }
    });
}());

//##############################################################################
// CollisionGroup.js
//##############################################################################

/**
 * This component groups other entities with this entity for collision checking. This is useful for carrying and moving platforms. It uses `EntityContainer` component messages if triggered to add to its collision list and also listens for explicit add/remove messages (useful in the absence of an `EntityContainer` component).
 *
 * @namespace platypus.components
 * @class CollisionGroup
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';

    var AABB = include('platypus.AABB'),
        DataMap = include('platypus.DataMap'),
        Vector = include('platypus.Vector');
    
    return platypus.createComponentClass({
        id: 'CollisionGroup',
        
        constructor: function () {
            this.solidEntities = Array.setUp();
            
            // These are used as return values for methods, but are instantiated here for recycling later.
            this.collisionTypes = Array.setUp();
            this.shapes = Array.setUp();
            this.prevShapes = Array.setUp();
            
            this.terrain  = null;
            this.aabb     = AABB.setUp(this.owner.x, this.owner.y);
            this.prevAABB = AABB.setUp(this.owner.x, this.owner.y);
            this.filteredAABB = AABB.setUp();

            Vector.assign(this.owner, 'position', 'x', 'y', 'z');
            Vector.assign(this.owner, 'previousPosition', 'previousX', 'previousY', 'previousZ');
            this.owner.previousX = this.owner.previousX || this.owner.x;
            this.owner.previousY = this.owner.previousY || this.owner.y;
            
            this.collisionGroup = this.owner.collisionGroup = {
                getAllEntities: function () {
                    var x           = 0,
                        count       = 0,
                        childEntity = null;
                    
                    for (x = 0; x < this.solidEntities.length; x++) {
                        childEntity = this.solidEntities[x];
                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                            count += childEntity.collisionGroup.getAllEntities();
                        } else {
                            count += 1;
                        }
                    }

                    return count;
                }.bind(this),
                getSize: function () {
                    return this.solidEntities.length;
                }.bind(this),
                getCollisionTypes: function () {
                    return this.getCollisionTypes();
                }.bind(this),
                getSolidCollisions: function () {
                    return this.getSolidCollisions();
                }.bind(this),
                getAABB: function (collisionType) {
                    return this.getAABB(collisionType);
                }.bind(this),
                getPreviousAABB: function (collisionType) {
                    return this.getPreviousAABB(collisionType);
                }.bind(this),
                getShapes: function (collisionType) {
                    return this.getShapes(collisionType);
                }.bind(this),
                getPrevShapes: function (collisionType) {
                    return this.getPrevShapes(collisionType);
                }.bind(this),
                prepareCollision: function (x, y) {
                    return this.prepareCollision(x, y);
                }.bind(this),
                relocateEntity: function (vector, collisionData) {
                    return this.relocateEntity(vector, collisionData);
                }.bind(this),
                movePreviousX: function (x) {
                    return this.movePreviousX(x);
                }.bind(this),
                getSolidEntities: function () {
                    return this.solidEntities;
                }.bind(this),
                jumpThrough: false //TODO: this introduces odd behavior - not sure how to resolve yet. - DDD
            };
        },
        
        events: {
            /**
             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.
             *
             * @method 'child-entity-added'
             * @param entity {platypus.Entity} The entity to be added.
             */
            "child-entity-added": function (entity) {
                this.addCollisionEntity(entity);
            },
            
            /**
             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.
             *
             * @method 'add-collision-entity'
             * @param entity {platypus.Entity} The entity to be added.
             */
            "add-collision-entity": function (entity) {
                this.addCollisionEntity(entity);
            },
            
            /**
             * On receiving this message, the component looks for the entity in its collision group and removes it.
             *
             * @method 'child-entity-removed'
             * @param entity {platypus.Entity} The entity to be removed.
             */
            "child-entity-removed": function (entity) {
                this.removeCollisionEntity(entity);
            },
            
            /**
             * On receiving this message, the component looks for the entity in its collision group and removes it.
             *
             * @method 'remove-collision-entity'
             * @param entity {platypus.Entity} The entity to be removed.
             */
            "remove-collision-entity": function (entity) {
                this.removeCollisionEntity(entity);
            },
            
            /**
             * When this message is triggered, the collision group updates its record of the owner's last (x, y) coordinate.
             *
             * @method 'relocate-entity'
             */
            "relocate-entity": function () {
                this.owner.previousPosition.setVector(this.owner.position);
                this.updateAABB();
            }
        },
        
        methods: {
            addCollisionEntity: function (entity) {
                var i     = 0,
                    types = entity.collisionTypes;
                
                if (types) {
                    i = types.length;
                    while (i--) {
                        if (entity.solidCollisionMap.get(types[i]).length && !entity.immobile) {
                            this.solidEntities[this.solidEntities.length] = entity;
                        }
                    }
                    this.updateAABB();
                }
            },
            
            removeCollisionEntity: function (entity) {
                var x     = 0,
                    i     = 0,
                    types = entity.collisionTypes;

                if (types) {
                    i = types.length;
                    while (i--) {
                        if (entity.solidCollisionMap.get(types[i]).length) {
                            x = this.solidEntities.indexOf(entity);
                            if (x >= 0) {
                                this.solidEntities.greenSplice(x);
                            }
                        }
                    }
                    this.updateAABB();
                }
            },
            
            getCollisionTypes: function () {
                var childEntity  = null,
                    compiledList = this.collisionTypes,
                    se = this.solidEntities,
                    i = se.length;
                
                compiledList.length = 0;
                
                while (i--) {
                    childEntity = se[i];
                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                    }
                    compiledList.union(childEntity.getCollisionTypes());
                }
                
                return compiledList;
            },

            getSolidCollisions: function () {
                var x            = 0,
                    key          = '',
                    keys = null,
                    childEntity  = null,
                    compiledList = DataMap.setUp(),
                    entityList   = null,
                    i = 0,
                    toList = null,
                    fromList = null,
                    recycle = false;
                
                for (x = 0; x < this.solidEntities.length; x++) {
                    recycle = false;
                    childEntity = this.solidEntities[x];
                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                        recycle = true;
                    }
                    entityList = childEntity.getSolidCollisions();
                    keys = entityList.keys;
                    i = keys.length;
                    while (i--) {
                        key = keys[i];
                        toList = compiledList.get(key);
                        fromList = entityList.get(key);
                        if (!toList) {
                            toList = compiledList.set(key, Array.setUp());
                        }
                        toList.union(fromList);
                        if (recycle) {
                            fromList.recycle();
                        }
                    }
                    if (recycle) {
                        entityList.recycle();
                    }
                }
                
                return compiledList; // TODO: Track down where this is used and make sure the arrays are recycled. - DDD 2/1/2016
            },
            
            getAABB: function (collisionType) {
                var i = 0,
                    aabb        = this.filteredAABB,
                    childEntity = null,
                    incAABB = null,
                    sE = this.solidEntities;
                
                if (!collisionType) {
                    return this.aabb;
                } else {
                    aabb.reset();
                    i = sE.length;
                    while (i--) {
                        childEntity = sE[i];
                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                            childEntity = childEntity.collisionGroup;
                        }
                        incAABB = childEntity.getAABB(collisionType);
                        if (incAABB) {
                            aabb.include(incAABB);
                        }
                    }
                    return aabb;
                }
            },

            getPreviousAABB: function (collisionType) {
                var i = 0,
                    aabb        = this.filteredAABB,
                    childEntity = null,
                    incAABB = null,
                    sE = this.solidEntities;
                
                if (!collisionType) {
                    return this.prevAABB;
                } else {
                    aabb.reset();
                    i = sE.length;
                    while (i--) {
                        childEntity = sE[i];
                        if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                            childEntity = childEntity.collisionGroup;
                        }

                        incAABB = childEntity.getPreviousAABB(collisionType);
                        if (incAABB) {
                            aabb.include(incAABB);
                        }
                    }
                    return aabb;
                }
            },
            
            updateAABB: function () {
                var aabb = this.aabb,
                    sE = this.solidEntities,
                    entity = null,
                    x = sE.length,
                    owner = this.owner;
                
                aabb.reset();
                while (x--) {
                    entity = sE[x];
                    aabb.include(((entity !== owner) && entity.getCollisionGroupAABB) ? entity.getCollisionGroupAABB() : entity.getAABB());
                }
            },
            
            getShapes: function (collisionType) {
                var x           = 0,
                    childEntity = null,
                    shapes      = this.shapes,
                    newShapes   = null;
                    
                shapes.length = 0;
                
                for (x = 0; x < this.solidEntities.length; x++) {
                    childEntity = this.solidEntities[x];
                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                    }
                    newShapes = childEntity.getShapes(collisionType);
                    if (newShapes) {
                        shapes.union(newShapes);
                    }
                }
                return shapes;
            },

            getPrevShapes: function (collisionType) {
                var x           = 0,
                    childEntity = null,
                    newShapes   = null,
                    shapes      = this.prevShapes;
                    
                shapes.length = 0;
                
                for (x = 0; x < this.solidEntities.length; x++) {
                    childEntity = this.solidEntities[x];
                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                    }
                    newShapes = childEntity.getPrevShapes(collisionType);
                    if (newShapes) {
                        shapes.union(newShapes);
                    }
                }
                return shapes;
            },
            
            prepareCollision: function (x, y) {
                var i           = 0,
                    childEntity = null,
                    oX          = 0,
                    oY          = 0;
                
                for (i = 0; i < this.solidEntities.length; i++) {
                    childEntity = this.solidEntities[i];
                    childEntity.saveDX = childEntity.x - childEntity.previousX;
                    childEntity.saveDY = childEntity.y - childEntity.previousY;
                    oX = childEntity.saveOX = this.owner.previousX - childEntity.previousX;
                    oY = childEntity.saveOY = this.owner.previousY - childEntity.previousY;
                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                    }
                    childEntity.prepareCollision(x - oX, y - oY);
                }
            },
            
            movePreviousX: function (x) {
                var childEntity = null,
                    offset      = 0,
                    i           = 0;
                
                for (i = 0; i < this.solidEntities.length; i++) {
                    childEntity = this.solidEntities[i];
                    offset = childEntity.saveOX;
                    if ((childEntity !== this.owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                    }
                    childEntity.movePreviousX(x - offset);
                }
            },
            
            relocateEntity: function (vector, collisionData) {
                var childEntity = null,
                    entity      = null,
                    i           = 0,
                    list        = null,
                    owner       = this.owner,
                    solids      = this.solidEntities,
                    v           = null;
                
                owner.saveDX -= vector.x - owner.previousX;
                owner.saveDY -= vector.y - owner.previousY;

                list = collisionData.xData;
                i = list.length;
                while (i--) {
                    if (list[i].thisShape.owner === owner) {
                        owner.saveDX = 0;
                        break;
                    }
                }
                
                list = collisionData.yData;
                i = list.length;
                while (i--) {
                    if (list[i].thisShape.owner === owner) {
                        owner.saveDY = 0;
                        break;
                    }
                }
                
                for (i = 0; i < solids.length; i++) {
                    childEntity = entity = solids[i];
                    if ((childEntity !== owner) && childEntity.collisionGroup) {
                        childEntity = childEntity.collisionGroup;
                    }
                    v = Vector.setUp(vector.x - entity.saveOX, vector.y - entity.saveOY, childEntity.z);
                    childEntity.relocateEntity(v, collisionData);
                    v.recycle();
                    entity.x += entity.saveDX;
                    entity.y += entity.saveDY;
                    if (entity !== owner) {
                        entity.x += owner.saveDX;
                        entity.y += owner.saveDY;
                    }
                }
            },

            destroy: function () {
                this.solidEntities.recycle();
                this.collisionTypes.recycle();
                this.shapes.recycle();
                this.prevShapes.recycle();
                this.aabb.recycle();
                this.prevAABB.recycle();
                this.filteredAABB.recycle();
            }
        },
        
        publicMethods: {
            /**
             * Gets the bounding box of the group of entities.
             *
             * @method getCollisionGroupAABB
             * @return platypus.AABB
             */
            getCollisionGroupAABB: function () {
                return this.getAABB();
            },
            
            /**
             * Gets a list of all the entities in the world.
             *
             * @method getWorldEntities
             * @return Array
             */
            getWorldEntities: function () {
                return this.owner.parent.getWorldEntities();
            },
            
            /**
             * Gets the collision entity representing the world's terrain.
             *
             * @method getWorldTerrain
             * @return platypus.Entity
             */
            getWorldTerrain: function () {
                return this.owner.parent.getWorldTerrain();
            }
        }
    });
}());

//##############################################################################
// CollisionTiles.js
//##############################################################################

/**
 * This component causes the tile-map to collide with other entities. It must be part of a collision group and will cause "hit-by-tile" messages to fire on colliding entities.
 *
 * @namespace platypus.components
 * @class CollisionTiles
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var AABB = include('platypus.AABB'),
        CollisionShape = include('platypus.CollisionShape'),
        Data = include('platypus.Data'),
        maskJumpThrough = 0x10000000,
        maskRotation = 0x20000000,
        maskXFlip = 0x80000000,
        maskYFlip = 0x40000000,
        maskIndex = 0x0fffffff,
        getDefaultType = function () {
            return this.collisionType;
        },
        getCollisionType = function (index) {
            return this.collisionTypeMap[index & maskIndex] || this.collisionType;
        },
        flipDiagonal = function (num) {
            if (num === 0) {
                return num;
            } else {
                return num ^ maskYFlip ^ maskRotation;
            }
        },
        flipDiagonalInverse = function (num) {
            if (num === 0) {
                return num;
            } else {
                return num ^ maskXFlip ^ maskRotation;
            }
        },
        flipX = function (num) {
            if (num === 0) {
                return num;
            } else {
                return num ^ maskXFlip;
            }
        },
        flipY = function (num) {
            if (num === 0) {
                return num;
            } else {
                return num ^ maskYFlip;
            }
        },
        rotate90 = function (num) {
            if (num === 0) {
                return num;
            } else if (maskRotation & num) {
                return num ^ maskYFlip ^ maskRotation;
            } else {
                return num ^ maskXFlip ^ maskRotation;
            }
        },
        rotate180 = function (num) {
            if (num === 0) {
                return num;
            } else {
                return num ^ maskXFlip ^ maskYFlip;
            }
        },
        rotate270 = function (num) {
            if (num === 0) {
                return num;
            } else if (maskRotation & num) {
                return num ^ maskXFlip ^ maskRotation;
            } else {
                return num ^ maskYFlip ^ maskRotation;
            }
        },
        copySection = function (array, originX, originY, width, height) {
            var x   = 0,
                y   = 0,
                arr = Array.setUp();

            for (y = 0; y < height; y++) {
                arr[y] = Array.setUp();
                for (x = 0; x < width; x++) {
                    arr[y][x] = array[originX + x][originY + y];
                }
            }
            return arr;
        },
        cutSection = function (array, originX, originY, width, height) {
            var x   = 0,
                y   = 0,
                arr = Array.setUp();

            for (y = 0; y < height; y++) {
                arr[y] = Array.setUp();
                for (x = 0; x < width; x++) {
                    arr[y][x] = array[originX + x][originY + y];
                    array[originX + x][originY + y] = -1;
                }
            }
            return arr;
        },
        pasteSection = function (destinationArray, sourceArray, originX, originY, width, height) {
            var x = 0,
                y = 0;

            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    destinationArray[originX + x][originY + y] = sourceArray[y][x];
                }
            }
            return destinationArray;
        },
        transforms = {
            "diagonal": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    fD    = flipDiagonal,
                    x     = 0,
                    y     = 0;

                for (x = 0; x < width; x++) {
                    for (y = 0; y < height; y++) {
                        array[originX + x][originY + y] = fD(arr[x][y]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "diagonal-inverse": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    fDI   = flipDiagonalInverse,
                    x     = 0,
                    y     = 0;

                for (x = 0; x < width; x++) {
                    for (y = 0; y < height; y++) {
                        array[originX + width - x - 1][originY + height - y - 1] = fDI(arr[x][y]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "horizontal": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    fX    = flipX,
                    x     = 0,
                    y     = 0;

                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        array[originX + width - x - 1][originY + y] = fX(arr[y][x]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "vertical": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    fY    = flipY,
                    x     = 0,
                    y     = 0;

                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        array[originX + x][originY + height - y - 1] = fY(arr[y][x]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "rotate-90": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    r90   = rotate90,
                    x     = 0,
                    y     = 0;

                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        array[originX + height - y - 1][originY + x] = r90(arr[y][x]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "rotate-180": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    r180  = rotate180,
                    x     = 0,
                    y     = 0;

                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        array[originX + width - x - 1][originY + height - y - 1] = r180(arr[y][x]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "rotate-270": function (array, originX, originY, width, height) {
                var arr   = copySection(array, originX, originY, width, height),
                    r270  = rotate270,
                    x     = 0,
                    y     = 0;

                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        array[originX + y][originY + width - x - 1] = r270(arr[y][x]);
                    }
                }
                arr.recycle(2);
                return array;
            },
            "translate": function (array, originX, originY, width, height, dx, dy) {
                var arr = cutSection(array, originX, originY, width, height),
                    x   = 0,
                    y   = 0;

                for (y = 0; y < height; y++) {
                    for (x = 0; x < width; x++) {
                        array[originX + x + dx][originY + y + dy] = arr[y][x];
                    }
                }
                arr.recycle(2);
                return array;
            }
        };

    return platypus.createComponentClass({
        id: 'CollisionTiles',
        
        properties: {
            /**
             * Maps tile indexes to particular collision types. This defaults to a "tiles" collision type for all non-zero values if a particular collision map is not provided.
             *
             * @property collisionTypeMap
             * @type Object
             * @default null
             * @since 0.8.3
             */
            collisionTypeMap: null,
            
            /**
             * Sets the default collision type for non-zero map tiles.
             *
             * @property collisionType
             * @type String
             * @default "tiles"
             * @since 0.8.3
             */
            collisionType: 'tiles',
            
            /**
             * The map's top offset.
             *
             * @property top
             * @type Number
             * @default 0
             * @since 0.7.5
             */
            top: 0,
            
            /**
             * The map's left offset.
             *
             * @property left
             * @type Number
             * @default 0
             * @since 0.7.5
             */
            left: 0
        },
        
        publicProperties: {
            /**
             * A 2D array describing the tile-map with off (0) and on (!0) states. The indexes match Tiled map data indexes with an additional bit setting (0x2000000) for jumpthrough tiles. Example: `[[0, 0, 0], [1, 0, 0], [1, 1, 1]]`. Available on the entity as `entity.collisionMap`.
             *
             * @property collisionMap
             * @type Array
             * @default []
             */
            collisionMap: [],
            
            /**
             * The width of tiles in world coordinates. Available on the entity as `entity.tileWidth`.
             *
             * @property tileWidth
             * @type number
             * @default 10
             */
            tileWidth: 10,

            /**
             * The height of tiles in world coordinates. Available on the entity as `entity.tileHeight`.
             *
             * @property tileWidth
             * @type number
             * @default 10
             */
            tileHeight: 10
        },
        constructor: function () {
            this.tileOffsetLeft  = this.tileWidth / 2 + this.left;
            this.tileOffsetTop = this.tileHeight / 2 + this.top;
            
            this.columns = this.collisionMap.length;
            this.rows = this.collisionMap[0].length;
            
            this.shapeDefinition = Data.setUp(
                "x", 0,
                "y", 0,
                "type", 'rectangle',
                "width", this.tileWidth,
                "height", this.tileHeight
            );
            
            this.storedTiles = Array.setUp();
            this.serveTiles = Array.setUp();
            this.storedTileIndex = 0;
            
            this.aabb = AABB.setUp();
            this.aabb.setBounds(this.left, this.top, this.tileWidth * this.columns + this.left, this.tileHeight * this.rows + this.top);
            
            if (this.collisionTypeMap) {
                this.getType = getCollisionType;
            } else {
                this.getType = getDefaultType;
            }
        },
        
        events: {
            /**
             * Performs a transform of a subset of the collision tile grid.
             *
             * @method 'transform'
             * @param [transform] {Object} A list of key/value pairs describing the transform.
             * @param [transform.type="horizontal"] {String} The type of transform; one of the following: "horizontal", "vertical", "diagonal", "diagonal-inverse", "rotate-90", "rotate-180", "rotate-270". Height and width should match for diagonal flips and 90 degree rotations.
             * @param [transform.left=0] {number} Grid coordinate for the left side of the bounding box.
             * @param [transform.top=0] {number} Grid coordinate for the top of the bounding box.
             * @param [transform.width=grid.width] {number} Cell width of the bounding box.
             * @param [transform.height=grid.height] {number} Cell height of the bounding box.
             */
            "transform": function (transform) {
                this.transform(transform);
            },

            /**
             * Performs a translation of a subset of the collision tile grid.
             *
             * @method 'translate'
             * @param [translate] {Object} A list of key/value pairs describing the translation.
             * @param [translate.dx=0] {number} Movement in columns.
             * @param [translate.dy=0] {number} Movement in rows.
             * @param [translate.left=0] {number} Grid coordinate for the left side of the bounding box.
             * @param [translate.top=0] {number} Grid coordinate for the top of the bounding box.
             * @param [translate.width=grid.width] {number} Cell width of the bounding box.
             * @param [translate.height=grid.height] {number} Cell height of the bounding box.
             */
            "translate": function (translate) {
                this.translate(translate);
            }
        },
        
        methods: {
            getShape: function (x, y, type) {
                var i = this.storedTileIndex,
                    shape = null,
                    storedTiles = this.storedTiles;
                
                if (i === storedTiles.length) {
                    shape = CollisionShape.setUp(null, this.shapeDefinition, type);
                    storedTiles.push(shape);
                } else {
                    shape = storedTiles[i];
                    shape.collisionType = type;
                }
                
                shape.update(x * this.tileWidth + this.tileOffsetLeft, y * this.tileHeight + this.tileOffsetTop);

                this.storedTileIndex += 1;
                
                return shape;
            },
            
            addShape: function (shapes, prevAABB, x, y, collisionType) {
                var xy = this.collisionMap[x][y],
                    index = xy & maskIndex,
                    jumpThrough = maskJumpThrough,
                    rotation = maskRotation,
                    xFlip = maskXFlip,
                    yFlip = maskYFlip;
                
                if (xy && (this.getType(index) === collisionType)) {
                    jumpThrough &= xy;
                    if (jumpThrough) {
                        rotation &= xy;
                        xFlip &= xy;
                        yFlip &= xy;
                        if (rotation && xFlip) { // Right
                            if (prevAABB.left >= (x + 1) * this.tileWidth + this.left) {
                                shapes.push(this.getShape(x, y, collisionType));
                            }
                        } else if (rotation) { // Left
                            if (prevAABB.right <= x * this.tileWidth + this.left) {
                                shapes.push(this.getShape(x, y, collisionType));
                            }
                        } else if (yFlip) { // Bottom
                            if (prevAABB.top >= (y + 1) * this.tileHeight + this.top) {
                                shapes.push(this.getShape(x, y, collisionType));
                            }
                        } else if (prevAABB.bottom <= y * this.tileHeight + this.top) { // Top
                            shapes.push(this.getShape(x, y, collisionType));
                        }
                    } else {
                        shapes.push(this.getShape(x, y, collisionType));
                    }
                }

                return shapes;
            },
            
            destroy: function () {
                var store = this.storedTiles,
                    i = store.length;
                
                this.shapeDefinition.recycle();
                delete this.shapeDefinition;
                
                while (i--) {
                    store[i].recycle();
                }
                store.recycle();
                delete this.storedTiles;

                this.serveTiles.recycle();
                delete this.serveTiles;
                
                this.aabb.recycle();
                delete this.aabb;
            }
        },
        
        publicMethods: {
            /**
             * Returns the axis-aligned bounding box of the entire map.
             *
             * @method getAABB
             * @return aabb {platypus.AABB} The returned object provides the top, left, width, and height of the collision map.
             */
            getAABB: function () {
                return this.aabb;
            },
            
            /**
             * Confirms whether a particular map grid coordinate contains a tile.
             *
             * @method isTile
             * @param x {number} Integer specifying the column of tiles in the collision map to check.
             * @param y {number} Integer specifying the row of tiles in the collision map to check.
             * @return {boolean} Returns `true` if the coordinate contains a collision tile, `false` if it does not.
             */
            isTile: function (x, y) {
                return !((x < 0) || (y < 0) || (x >= this.columns) || (y >= this.rows) || (this.collisionMap[x][y] === -1));
            },
            
            /**
             * Returns all the collision tiles within the provided axis-aligned bounding box as an array of shapes.
             *
             * @method getTileShapes
             * @param aabb {platypus.AABB} The axis-aligned bounding box for which tiles should be returned.
             * @param prevAABB {platypus.AABB} The axis-aligned bounding box for a previous location to test for jump-through tiles.
             * @param [collisionType] {String} The type of collision to check for. If not specified, "tiles" is used. (Since 0.8.3)
             * @return {Array} Each returned object provides the [CollisionShape](CollisionShape.html) of a tile.
             */
            getTileShapes: function (aabb, prevAABB, collisionType) {
                var colType = collisionType || 'tiles',
                    l = this.left,
                    t = this.top,
                    th = this.tileHeight,
                    tw = this.tileWidth,
                    left   = Math.max(Math.floor((aabb.left - l) / tw),  0),
                    top    = Math.max(Math.floor((aabb.top - t) / th), 0),
                    right  = Math.min(Math.ceil((aabb.right - l) / tw),  this.columns),
                    bottom = Math.min(Math.ceil((aabb.bottom - t) / th), this.rows),
                    x      = 0,
                    y      = 0,
                    shapes = this.serveTiles;
                
                shapes.length = 0;
                this.storedTileIndex = 0;
                
                for (x = left; x < right; x++) {
                    for (y = top; y < bottom; y++) {
                        this.addShape(shapes, prevAABB, x, y, colType);
                    }
                }
                
                return shapes;
            },
            
            /**
             * Performs a transform of a subset of the collision tile grid.
             *
             * @method transform
             * @param [transform] {Object} A list of key/value pairs describing the transform.
             * @param [transform.type="horizontal"] {String} The type of transform; one of the following: "horizontal", "vertical", "diagonal", "diagonal-inverse", "rotate-90", "rotate-180", "rotate-270". Height and width should match for diagonal flips and 90 degree rotations.
             * @param [transform.left=0] {number} Grid coordinate for the left side of the bounding box.
             * @param [transform.top=0] {number} Grid coordinate for the top of the bounding box.
             * @param [transform.width=grid.width] {number} Cell width of the bounding box.
             * @param [transform.height=grid.height] {number} Cell height of the bounding box.
             */
            transform: function (transform) {
                var t      = transform || {},
                    x      = t.left    || 0,
                    y      = t.top     || 0,
                    width  = t.width   || this.rows,
                    height = t.height  || this.columns,
                    type   = t.type    || "horizontal";
                
                if (transforms[type]) {
                    return transforms[type](this.collisionMap, x, y, width, height);
                } else {
                    return null;
                }
            },
            
            /**
             * Performs a translation of a subset of the collision tile grid.
             *
             * @method translate
             * @param [translate] {Object} A list of key/value pairs describing the translation.
             * @param [translate.dx=0] {number} Movement in columns.
             * @param [translate.dy=0] {number} Movement in rows.
             * @param [translate.left=0] {number} Grid coordinate for the left side of the bounding box.
             * @param [translate.top=0] {number} Grid coordinate for the top of the bounding box.
             * @param [translate.width=grid.width] {number} Cell width of the bounding box.
             * @param [translate.height=grid.height] {number} Cell height of the bounding box.
             */
            translate: function (translate) {
                var t      = translate || {},
                    x      = t.left    || 0,
                    y      = t.top     || 0,
                    width  = t.width   || this.rows,
                    height = t.height  || this.columns,
                    dx     = t.dx      || 0,
                    dy     = t.dy      || 0;
                
                return transforms.translate(this.collisionMap, x, y, width, height, dx, dy);
            },
            
            /**
             * Gets a subset of the collision tile grid as a 2D array.
             *
             * @method getCollisionMatrix
             * @param originX {number} Grid coordinate for the left side of the bounding box.
             * @param originY {number} Grid coordinate for the top of the bounding box.
             * @param width {number} Cell width of the bounding box.
             * @param height {number} Cell height of the bounding box.
             * @return {Array}
             */
            getCollisionMatrix: function (originX, originY, width, height) {
                return copySection(this.collisionMap, originX, originY, width, height);
            },
            
            /**
             * Sets a subset of the collision tile grid.
             *
             * @method setCollisionMatrix
             * @param sourceArray {Array} A 2D array describing the collision tiles to insert into the collision tile grid.
             * @param originX {number} Grid coordinate for the left side of the bounding box.
             * @param originY {number} Grid coordinate for the top of the bounding box.
             * @param width {number} Cell width of the bounding box.
             * @param height {number} Cell height of the bounding box.
             */
            setCollisionMatrix: function (sourceArray, originX, originY, width, height) {
                return pasteSection(this.collisionMap, sourceArray, originX, originY, width, height);
            }
        }
    });
}());

//##############################################################################
// ComponentSwitcher.js
//##############################################################################

/**
 * This component listens for messages and, according to its preset settings, will remove and add components to the entity. This is useful if certain events should modify the behavior of the entity in some way: for example, acquiring a pogo-stick might add a jumping component so the hero can jump.
 *
 * @namespace platypus.components
 * @class ComponentSwitcher
 * @uses platypus.Component
 */
/* global platypus */
(function () {
    'use strict';

    var
        addSwitch = function (event) {
            this.switches.push(event);
        };
    
    return platypus.createComponentClass({
        id: 'ComponentSwitcher',
        
        properties: {
            /**
             * This is the list of messages to listen for (as the keys) with the settings as two arrays of components to add and components to remove.
             *
                {
                    "found-pogostick":{
                      "add":[
                      // This is a list of components to add when "found-pogostick" is triggered on the entity. If it's adding a single component, "add" can be a reference to the component definition itself rather than an array of one object.
                        {"type": "Mover"},
                        {"type": "HeadGear"}
                      ]
                      
                      "remove": ["CarSeat"]
                      // This is a string list of component ids to remove when "found-pogostick" is triggered on the entity. It will ignore listed components that are not connected to the entity.
                    },
                    
                    // Multiple events can cause unique components to be added or removed
                    "walking-indoors":{
                      "remove": ["HeadGear"]
                    },
                    
                    "contemplate":{
                      "add": {"type": "AIPacer"}
                    }
                  }
                }
             *
             * @property componentMap
             * @type Object
             * @default null
             */
            componentMap: null
        },
        
        constructor: function () {
            var event = '';
            
            this.switches = Array.setUp(); // The list of switches to make.
            
            if (this.componentMap) {
                for (event in this.componentMap) {
                    if (this.componentMap.hasOwnProperty(event)) {
                        /**
                         * Message(s) listed by `componentMap` will add or remove components.
                         *
                         * @method '*'
                         */
                        this.addEventListener(event, addSwitch.bind(this, event));
                    }
                }
            }
        },
        
        events: {
            /**
             * This component handles component-switching on this call so that it doesn't interfere with the "handle-logic" loop.
             *
             * @method 'prepare-logic'
             */
            "prepare-logic": function () {
                var i = 0;
                
                if (this.switches.length) {
                    for (i = 0; i < this.switches.length; i++) {
                        this.switchComponents(this.componentMap[this.switches[i]]);
                    }
                    this.switches.length = 0;
                }
            }
        },
        
        methods: {
            switchComponents: function (definition) {
                var i = 0,
                    j = 0,
                    owner = this.owner,
                    components = owner.components,
                    remove = definition.remove,
                    add = definition.add;
                    
                if (remove) {
                    if (!Array.isArray(remove)) {
                        for (i = components.length - 1; i > -1; i--) {
                            if (components[i].type === remove) {
                                owner.removeComponent(components[i]);
                            }
                        }
                    } else {
                        for (i = 0; i < remove.length; i++) {
                            for (j = components.length - 1; j > -1; j--) {
                                if (components[j].type === remove[i]) {
                                    owner.removeComponent(components[j]);
                                }
                            }
                        }
                    }
                }

                if (add) {
                    if (!Array.isArray(add)) {
                        owner.addComponent(new platypus.components[add.type](owner, add));
                    } else {
                        for (i = 0; i < add.length; i++) {
                            owner.addComponent(new platypus.components[add[i].type](owner, add[i]));
                        }
                    }
                }
                
                if (owner.parent) {
                    /**
                    * This message is triggered on the parent when the entity's components change.
                    *
                    * @event 'child-entity-updated'
                    * @param entity {platypus.Entity} This is the entity itself.
                    */
                    owner.parent.triggerEvent('child-entity-updated', owner);
                }
                /**
                * This message is triggered on the entity itself when its components change.
                *
                * @event 'add-remove-component-complete'
                */
                owner.triggerEvent('add-remove-component-complete');
            },
            
            destroy: function () {
                this.switches.recycle();
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var map = def.componentMap || props.componentMap || defaultProps.componentMap,
                event = '',
                i = 0,
                component = null,
                assets = Array.setUp(),
                arr = null;
            
            for (event in map) {
                if (map.hasOwnProperty(event)) {
                    for (i = 0; i < map[event].add.length; i++) {
                        component = platypus.components[map[event].add[i].type];
                        if (component) {
                            arr = component.getAssetList(map[event].add[i], props, defaultProps);
                            assets.union(arr);
                            arr.recycle();
                        }
                    }
                }
            }
            
            return assets;
        }
    });
}());

//##############################################################################
// Counter.js
//##############################################################################

/**
 * A simple component that keeps count of something and sends messages each time the count changes. Can also have a total. When it does it will display 'count / total'.
 *
 * @namespace platypus.components
 * @class Counter
 * @uses platypus.Component
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Data = include('platypus.Data');
    
    return platypus.createComponentClass({

        id: 'Counter',

        publicProperties: {
            /**
             * A total the counter is incrementing toward.
             *
             * @property total
             * @type number
             * @default 0
             */
            total: 0
        },

        constructor: function () {
            this.count = 0;
            this.lastTotal = 0;
            this.lastCount = 0;
            this.message = Data.setUp(
                "text", ""
            );
        },

        events: {
            /**
             * Each step, this component detects whether the count has changed and triggers an 'update-content' event if so.
             *
             * @method 'handle-logic'
             */
            "handle-logic": function () {
                var update  = false,
                    msg = this.message;
                
                if (this.total !== this.lastTotal) {
                    this.lastTotal = this.total;
                    update = true;
                }
                
                if (this.count !== this.lastCount) {
                    this.lastCount = this.count;
                    update = true;
                }
                
                if (update) {
                    if (this.total) {
                        msg.text = String(this.count) + "/" + String(this.total);
                    } else {
                        msg.text = String(this.count);
                    }
                    
                    /**
                     * A call used to notify other components that the count or total has changed.
                     *
                     * @event 'update-content'
                     * @param update.text {string} String describing the current count.
                     */
                    this.owner.triggerEvent('update-content', msg);
                }
            },

            /**
             * Changes the total to the given value.
             *
             * @method 'change-total'
             * @param data.total {number} The new total value.
             */
            "change-total": function (total) {
                this.total = total;
            },

            /**
             * Changes the count to the given value.
             *
             * @method 'change-count'
             * @param data.count {number} The new count value.
             */
            "change-count": function (count) {
                this.count = count;
            },

            /**
             * Increments the count by 1.
             *
             * @method 'increment-count'
             */
            "increment-count": function () {
                this.count += 1;
            }
        },
        
        methods: {
            destroy: function () {
                this.message.recycle();
            }
        }
    });
}());

//##############################################################################
// EntityContainer.js
//##############################################################################

/**
 * This component allows the entity to contain child entities. It will add several methods to the entity to manage adding and removing entities.
 *
 * @namespace platypus.components
 * @class EntityContainer
 * @extends platypus.Messenger
 * @uses platypus.Component
 */
/**
### Local Broadcasts:
- **child-entity-added** - This message is triggered when a new entity has been added to the list of children entities.
  - @param message ([[Entity]] object) - The entity that was just added.
- **child-entity-removed** - This message is triggered when an entity has been removed from the list of children entities.
  - @param message ([[Entity]] object) - The entity that was just removed.

### Child Broadcasts:
- **peer-entity-added** - This message is triggered when a new entity has been added to the parent's list of children entities.
  - @param message ([[Entity]] object) - The entity that was just added.
- **peer-entity-removed** - This message is triggered when an entity has been removed from the parent's list of children entities.
  - @param message ([[Entity]] object) - The entity that was just removed.
- **[Messages specified in definition]** - Listens for specified messages and on receiving them, re-triggers them on child entities.
  - @param message (object) - sends the message object received by the original message.

## Entity Methods:
- **addEntity** -  This method will add the provided entity to this component's list of entities.
  - @param entity ([[Entity]] object) - Required. This is the entity to be added as a child.
  - @return entity ([[Entity]] object) - Returns the entity that was just added.
- **removeEntity** - This method will remove the provided entity from the list of child entities.
  - @param message ([[Entity]] object) - Required. The entity to remove.
  - @return entity ([[Entity]] object | false) - Returns the entity that was just removed. If the entity was not foudn as a child, `false` is returned, indicated that the provided entity was not a child of this entity.
- **getEntitiesByType** - This method will return all child entities (including grandchildren) that match the provided type.
  - @param type (string) - Required. The entity type to find.
  - @return entities (Array of [[Entity]] objects) - Returns the entities that match the specified entity type.
- **getEntityById** - This method will return the first child entity it finds with a matching id (including grandchildren).
  - @param id (string) - Required. The entity id to find.
  - @return entity ([[Entity]] object) - Returns the entity that matches the specified entity id.
- **triggerOnChildren** - This method is used by both internal components and external entities to trigger messages on the child entities.
  - @param event (variant) - This is the message(s) to process. This can be a string, an object containing an "event" property (and optionally a "message" property, overriding the value below), or an array of the same.
  - @param value (variant) - This is a message object or other value to pass along to component functions.
  - @param debug (boolean) - This flags whether to output message contents and subscriber information to the console during game development. A "value" object parameter (above) will also set this flag if value.debug is set to true.
  - @return integer - The number of handlers for the triggered message: this is useful for determining how many child entities care about a given message.
- **triggerEvent** - This method is used by both internal components and external entities to trigger messages on the child entities.
  - @param event (string) - This is the message to process.
  - @param value (variant) - This is a message object or other value to pass along to component functions.
  - @param debug (boolean) - This flags whether to output message contents and subscriber information to the console during game development. A "value" object parameter (above) will also set this flag if value.debug is set to true.
  - @return integer - The number of handlers for the triggered message: this is useful for determining how many child entities care about a given message.
*/
/* global include, platypus */
(function () {
    'use strict';

    var Data = include('platypus.Data'),
        Entity = include('platypus.Entity'),
        childBroadcast = function (event) {
            return function (value, debug) {
                this.triggerOnChildren(event, value, debug);
            };
        };
    
    return platypus.createComponentClass({
        id: 'EntityContainer',
        
        properties: {
            /**
             * An Array listing messages that are triggered on the entity and should be triggered on the children as well.
             *
             * @property childEvents
             * @type Array
             * @default []
             */
            childEvents: []
        },
        
        constructor: function (definition) {
            var i = 0,
                events = this.childEvents;
    
             //saving list of entities for load message
            this.entityDefinitions = null;
            if (definition.entities && this.owner.entities) { //combine component list and entity list into one if they both exist.
                this.entityDefinitions = definition.entities.concat(this.owner.entities);
            } else {
                this.entityDefinitions = definition.entities || this.owner.entities || null;
            }

            this.owner.entities = this.entities = Array.setUp();
            
            this.childEvents = Array.setUp();
            for (i = 0; i < events.length; i++) {
                this.addNewPublicEvent(events[i]);
            }
            this.addNewPrivateEvent('peer-entity-added');
            this.addNewPrivateEvent('peer-entity-removed');
        },
        
        events: {
            /**
             * This component waits until all other entity components are loaded before it begins adding children entities. This allows other entity components to listen to entity-added messages and handle them if necessary.
             *
             * @method 'load'
             */
            "load": function () {
                // putting this here so all other components will have been loaded and can listen for "entity-added" calls.
                var i = 0,
                    entities   = this.entityDefinitions;
                
                if (entities) {
                    for (i = 0; i < entities.length; i++) {
                        this.addEntity(entities[i]);
                    }
                }

                delete this.entityDefinitions;
            },
            
            /**
             * This message will added the given entity to this component's list of entities.
             *
             * @method 'add-entity'
             * @param entity {platypus.Entity} This is the entity to be added as a child.
             */
            "add-entity": function (entity) {
                this.addEntity(entity);
            },
            
            /**
             * On receiving this message, the provided entity will be removed from the list of child entities.
             *
             * @method 'remove-entity'
             * @param entity {platypus.Entity} The entity to remove.
             */
            "remove-entity": function (entity) {
                this.removeEntity(entity);
            },
            
            "child-entity-updated": function (entity) {
                this.updateChildEventListeners(entity);
            }
        },
        
        methods: {
            addNewPublicEvent: function (event) {
                var i = 0;
                
                this.addNewPrivateEvent(event);
                
                for (i = 0; i < this.childEvents.length; i++) {
                    if (this.childEvents[i] === event) {
                        return false;
                    }
                }
                this.childEvents.push(event);
                /**
                 * Listens for specified messages and on receiving them, re-triggers them on child entities.
                 *
                 * @method '*'
                 * @param message {Object} Accepts a message object that it will include in the new message to be triggered.
                 */
                this.addEventListener(event, childBroadcast(event));
                
                return true;
            },
            
            addNewPrivateEvent: function (event) {
                var x = 0,
                    y = 0;
                
                if (this._listeners[event]) {
                    return false; // event is already added.
                }

                this._listeners[event] = Array.setUp(); //to signify it's been added even if not used
                
                //Listen for message on children
                for (x = 0; x < this.entities.length; x++) {
                    if (this.entities[x]._listeners[event]) {
                        for (y = 0; y < this.entities[x]._listeners[event].length; y++) {
                            this.addChildEventListener(this.entities[x], event, this.entities[x]._listeners[event][y]);
                        }
                    }
                }
                
                return true;
            },
            
            updateChildEventListeners: function (entity) {
                this.removeChildEventListeners(entity);
                this.addChildEventListeners(entity);
            },
            
            addChildEventListeners: function (entity) {
                var y     = 0,
                    event = '';
                
                for (event in this._listeners) {
                    if (this._listeners.hasOwnProperty(event) && entity._listeners[event]) {
                        for (y = 0; y < entity._listeners[event].length; y++) {
                            this.addChildEventListener(entity, event, entity._listeners[event][y]);
                        }
                    }
                }
            },
            
            removeChildEventListeners: function (entity) {
                var i        = 0,
                    events   = null,
                    messages = null;
                
                if (entity.containerListener) {
                    events   = entity.containerListener.events;
                    messages = entity.containerListener.messages;

                    for (i = 0; i < events.length; i++) {
                        this.removeChildEventListener(entity, events[i], messages[i]);
                    }
                    events.recycle();
                    messages.recycle();
                    entity.containerListener.recycle();
                    entity.containerListener = null;
                }
            },
            
            addChildEventListener: function (entity, event, callback) {
                if (!entity.containerListener) {
                    entity.containerListener = Data.setUp(
                        "events", Array.setUp(),
                        "messages", Array.setUp()
                    );
                }
                entity.containerListener.events.push(event);
                entity.containerListener.messages.push(callback);
                this.on(event, callback, callback._priority || 0);
            },
            
            removeChildEventListener: function (entity, event, callback) {
                var i        = 0,
                    events   = entity.containerListener.events,
                    messages = entity.containerListener.messages;
                
                for (i = 0; i < events.length; i++) {
                    if ((events[i] === event) && (!callback || (messages[i] === callback))) {
                        this.off(event, messages[i]);
                    }
                }
            },

            destroy: function () {
                var i = this.entities.length,
                    entity = null;
                
                while (i--) {
                    entity = this.entities[i];
                    this.removeChildEventListeners(entity);
                    entity.destroy();
                }
                this.entities.recycle();
                delete this.owner.entities;
                this.childEvents.recycle();
            }
        },
        
        publicMethods: {
            getEntityById: function (id) {
                var i         = 0,
                    selection = null;
                
                for (i = 0; i < this.entities.length; i++) {
                    if (this.entities[i].id === id) {
                        return this.entities[i];
                    }
                    if (this.entities[i].getEntityById) {
                        selection = this.entities[i].getEntityById(id);
                        if (selection) {
                            return selection;
                        }
                    }
                }
                return null;
            },

            getEntitiesByType: function (type) {
                var i         = 0,
                    selection = null,
                    entities  = Array.setUp();
                
                for (i = 0; i < this.entities.length; i++) {
                    if (this.entities[i].type === type) {
                        entities.push(this.entities[i]);
                    }
                    if (this.entities[i].getEntitiesByType) {
                        selection = this.entities[i].getEntitiesByType(type);
                        entities.union(selection);
                        selection.recycle();
                    }
                }
                return entities;
            },

            /**
             * This method adds an entity to the owner's group. If an entity definition or a reference to an entity definition is provided, the entity is created and then added to the owner's group.
             *
             * @method addEntity
             * @param newEntity {platypus.Entity|Object|String} Specifies the entity to add. If an object with a "type" property is provided or a String is provided, this component looks up the entity definition to create the entity.
             * @param [newEntity.type] {String} If an object with a "type" property is provided, this component looks up the entity definition to create the entity.
             * @param [newEntity.properties] {Object} A list of key/value pairs that sets the initial properties on the new entity.
             * @return {platypus.Entity} The entity that was just added.
             */
            addEntity: function (newEntity) {
                var entity = null,
                    x = 0;
                
                if (newEntity instanceof Entity) {
                    entity = newEntity;
                } else {
                    if (typeof newEntity === 'string') {
                        entity = new Entity(platypus.game.settings.entities[newEntity]);
                    } else if (newEntity.id) {
                        entity = new Entity(newEntity);
                    } else {
                        entity = new Entity(platypus.game.settings.entities[newEntity.type], newEntity);
                    }
                    this.owner.triggerEvent('entity-created', entity);
                }
                
                entity.parent = this.owner;
                entity.triggerEvent('adopted', entity);
                
                for (x = 0; x < this.entities.length; x++) {
                    if (!entity.triggerEvent('peer-entity-added', this.entities[x])) {
                        break;
                    }
                }
                this.triggerEventOnChildren('peer-entity-added', entity);

                this.addChildEventListeners(entity);
                this.entities.push(entity);
                this.owner.triggerEvent('child-entity-added', entity);
                return entity;
            },
            
            removeEntity: function (entity) {
                var i = this.entities.indexOf(entity);

                if (i >= 0) {
                    this.removeChildEventListeners(entity);
                    this.entities.greenSplice(i);
                    this.triggerEventOnChildren('peer-entity-removed', entity);
                    this.owner.triggerEvent('child-entity-removed', entity);
                    entity.destroy();
                    entity.parent = null;
                    return entity;
                }
                return false;
            },
            
            triggerEventOnChildren: function (event, message, debug) {
                if (this.destroyed) {
                    return 0;
                }
                
                if (!this._listeners[event]) {
                    this.addNewPrivateEvent(event);
                }
                return this.triggerEvent(event, message, debug);
            },

            triggerOnChildren: function (event, message, debug) {
                if (this.destroyed) {
                    return 0;
                }
                
                if (!this._listeners[event]) {
                    this.addNewPrivateEvent(event);
                }
                return this.trigger(event, message, debug);
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var i = 0,
                assets = Array.setUp(),
                entities = Array.setUp(),
                arr = null;
            
            if (def.entities) {
                entities.union(def.entities);
            }
            
            if (props && props.entities) {
                entities.union(props.entities);
            } else if (defaultProps && defaultProps.entities) {
                entities.union(defaultProps.entities);
            }

            for (i = 0; i < entities.length; i++) {
                arr = Entity.getAssetList(entities[i]);
                assets.union(arr);
                arr.recycle();
            }
            
            entities.recycle();
            
            return assets;
        }
    }, platypus.Messenger);
}());

//##############################################################################
// EntityController.js
//##############################################################################

/**
 * This component listens for input messages triggered on the entity and updates the state of any controller inputs it is listening for. It then broadcasts messages on the entity corresponding to the input it received.
 *
 * @namespace platypus.components
 * @class EntityController
 * @uses platypus.Component
 */
/*
## Dependencies:
- [[Handler-Controller]] (on entity's parent) - This component listens for a controller "tick" message in order to trigger messages regarding the state of its inputs.

## Messages

### Listens for:
- **handle-controller** - On each `handle-controller` message, this component checks its list of actions and if any of their states are currently true or were true on the last call, that action message is triggered.
- **mousedown** - This message triggers a new message on the entity that includes what button on the mouse was pressed: "mouse:left-button:down", "mouse:middle-button:down", or "mouse:right-button:down".
  - @param message.event (DOM Event object) - This event object is passed along with the new message.
- **mouseup** - This message triggers a new message on the entity that includes what button on the mouse was released: "mouse:left-button:up", "mouse:middle-button:up", or "mouse:right-button:up".
  - @param message.event (DOM Event object) - This event object is passed along with the new message.
- **mousemove** - Updates mouse action states with whether the mouse is currently over the entity.
  - @param message.over (boolean) - Whether the mouse is over the input entity.
- **pause-controls** - This message will stop the controller from triggering messages until "unpause-controls" is triggered on the entity.
- **unpause-controls** - This message will allow the controller to trigger messages until "pause-controls" is triggered on the entity.
- **[Messages specified in definition]** - Listens for additional messages and on receiving them, sets the appropriate state and broadcasts the associated message on the next `handle-controller` message. These messages come in pairs and typically have the form of "keyname:up" and "keyname:down" specifying the current state of the input.
  
### Local Broadcasts:
- **mouse:mouse-left:down, mouse:mouse-left:up, mouse:mouse-middle:down, mouse:mouse-middle:up, mouse:mouse-right:down, mouse:mouse-right:up** - This component triggers the state of mouse inputs on the entity if a render component of the entity accepts mouse input (for example [[Render-Animation]]).
  - @param message (DOM Event object) - The original mouse event object is passed along with the control message.
- **north, north-northeast, northeast, east-northeast, east, east-southeast, southeast, south-southeast, south, south-southwest, southwest, west-southwest, west, west-northwest, northwest, north-northwest** - If the soft joystick is enabled on this component, it will broadcast these directional messages if the joystick is in use.
  - @param message (DOM Event object) - Mirrors the mouse event object that moved the joystick.
- **joystick-orientation** - If the soft joystick is enabled on this component, this message will trigger to provide the current orientation of the joystick.
  - @param orientation (number) - A number in radians representing the orientation of the joystick.
- **[Messages specified in definition]** - Broadcasts active states using the JSON-defined message on each `handle-controller` message. Active states include `pressed` being true or `released` being true. If both of these states are false, the message is not broadcasted.
  - @param message.pressed (boolean) - Whether the current input is active.
  - @param message.released (boolean) - Whether the current input was active last tick but is no longer active.
  - @param message.triggered (boolean) - Whether the current input is active but was not active last tick.
  - @param message.over (boolean) - Whether the mouse was over the entity when pressed, released, or triggered. This value is always false for non-mouse input messages.

## JSON Definition:
    {
      "type": "EntityController",
      
      "joystick":{
      // Optional. Determines whether this entity should listen for mouse events to trigger directional events. Can be set simply to "true" to accept all joystick defaults
          
          "directions": 8,
          // Optional: 4, 8, or 16. Determines how many directions to broadcast. Default is 4 ("north", "east", "south", and "west").
          
          "innerRadius": 30,
          // Optional. Number determining how far the mouse must be from the entity's position before joystick events should be triggered. Default is 0.
          
          "outerRadius": 60
          // Optional. Number determining how far the mouse can move away from the entity's position before the joystick stops triggering events. Default is Infinity.
      }
    }
*/
/* global include, platypus */
(function () {
    'use strict';

    var ActionState = include('platypus.ActionState'),
        Data = include('platypus.Data'),
        DataMap = include('platypus.DataMap'),
        StateMap = include('platypus.StateMap'),
        distance = function (origin, destination) {
            var x = destination.x - origin.x,
                y = destination.y - origin.y;

            return Math.sqrt((x * x) + (y * y));
        },
        angle = function (origin, destination, distance) {
            var x      = destination.x - origin.x,
                y      = destination.y - origin.y,
                a      = 0,
                circle = Math.PI * 2;

            if (!distance) {
                return a;
            }

            a = Math.acos(x / distance);
            if (y < 0) {
                a = circle - a;
            }
            return a;
        },
        directions = [null, null, null, null, //joystick directions
            ['east', 'south', 'west', 'north'], null, null, null,
            ['east', 'southeast', 'south', 'southwest', 'west', 'northwest', 'north', 'northeast'], null, null, null, null, null, null, null,
            ['east', 'east-southeast', 'southeast', 'south-southeast', 'south', 'south-southwest', 'southwest', 'west-southwest', 'west', 'west-northwest', 'northwest', 'north-northwest', 'north', 'north-northeast', 'northeast', 'east-northeast']
            ],
        mouseMap = ['left-button', 'middle-button', 'right-button'],
        trigger = function (event, message) {
            if (!this.paused) {
                this.owner.trigger(event, message);
            }
        },
        filteredTrigger = function (state, event, message) {
            if (!this.paused && message[state]) {
                this.owner.trigger(event, message);
            }
        };

    return platypus.createComponentClass({
        id: 'EntityController',
        
        properties: {
            /**
             * Use the controlMap property object to map inputs to messages that should be triggered. At least one control mapping should be included. The following are a few examples:
             *
             *       {
             *           "key:x": "run-left",
             *           // This causes an "x" keypress to fire "run-left" on the entity. For a full listing of key names, check out the `HandlerController` component.
             *
             *           "button-pressed": "throw-block",
             *           // custom input messages can be fired on this entity from other entities, allowing for on-screen input buttons to run through the same controller channel as other inputs.
             *
             *           "mouse:left-button"
             *           // The controller can also handle mouse events on the entity if the entity's render component triggers mouse events on the entity (for example, the `RenderSprite` component).
             *       }
             *
             * @property controlMap
             * @type Object
             * @default {}
             */
            controlMap: {},
            
            /**
             * The stateMaps property can hold multiple control maps. Use this if certain controls should only be available for certain states. The controller finds the first valid state and falls back to the base `controlMap` as default if no matches are found.
             *
             * @property stateMaps
             * @type Object
             * @default {}
             * @since 0.6.7
             */
            stateMaps: {}
        },
        
        publicProperties: {
            /**
             * Whether input controls should be deactivated.
             *
             * @property paused
             * @type Boolean
             * @default false
             */
            paused: false
        },
        
        constructor: function (definition) {
            var key = '',
                filter = null;
            
            this.actions = DataMap.setUp();
            
            if (this.stateMaps) {
                for (key in this.stateMaps) {
                    if (this.stateMaps.hasOwnProperty(key)) {
                        filter = StateMap.setUp(key);
                        this.addMap(this.stateMaps[key], key, filter);
                        filter.recycle();
                    }
                }
            }
            
            this.addMap(this.controlMap, 'default');

            if (definition.joystick) {
                this.joystick = Data.setUp(
                    "directions",  definition.joystick.directions  || 4, // 4 = n,e,s,w; 8 = n,ne,e,se,s,sw,w,nw; 16 = n,nne,ene,e...
                    "handleEdge",  definition.joystick.handleEdge  || false,
                    "innerRadius", definition.joystick.innerRadius || 0,
                    "outerRadius", definition.joystick.outerRadius || Infinity
                );
            }
        },
        
        events: {
            "handle-controller": function () {
                var actions = this.actions,
                    keys = actions.keys,
                    i = keys.length,
                    action = '',
                    resolution = Array.setUp(),
                    state = this.owner.state;
                
                while (i--) {
                    action = actions.get(keys[i]);
                    if (action.update(state)) {
                        resolution.push(action);
                    }
                }
                
                i = resolution.length;
                while (i--) {
                    resolution[i].resolve();
                }
                
                resolution.recycle();
            },
            
            "mousedown": function (value) {
                this.owner.triggerEvent('mouse:' + mouseMap[value.event.button || 0] + ':down', value.event);
                if (this.joystick) {
                    this.owner.triggerEvent('joystick:down', value.event);
                    this.handleJoy(value);
                }
            },
            
            "pressup": function (value) {
                this.owner.triggerEvent('mouse:' + mouseMap[value.event.button || 0] + ':up', value.event);
                if (this.joystick) {
                    this.owner.triggerEvent('joystick:up', value.event);
                    this.handleJoy(value);
                }
            },
            
            "pressmove": function (value) {
                if (this.joystick) {
                    this.handleJoy(value);
                }
            },
            
            "pause-controls": function () {
                this.paused = true;
            },
            
            "unpause-controls": function () {
                this.paused = false;
            }
        },
        
        methods: {
            handleJoy: function (event) {
                // The following translate mouse and touch events into messages that this controller can handle in a systematic way
                var segment     = Math.PI / (this.joystick.directions / 2),
                    dist        = distance(this.owner, event),
                    orientation = 0,
                    direction   = '',
                    accuracy    = '';
                
                if ((dist > this.joystick.outerRadius) || (dist < this.joystick.innerRadius)) {
                    return;
                } else if (!this.paused) {
                    orientation = angle(this.owner, event, dist);
                    direction   = directions[this.joystick.directions][Math.floor(((orientation + segment / 2) % (Math.PI * 2)) / segment)];
                    
                    if (this.joystick.handleEdge) {
                        segment  = Math.PI / this.joystick.directions;
                        accuracy = directions[this.joystick.directions * 2][Math.floor(((orientation + segment / 2) % (Math.PI * 2)) / segment)];
                        if (accuracy !== direction) {
                            this.owner.triggerEvent(accuracy.replace(direction, '').replace('-', ''), event);  //There's probably a better way to perform this, but the current method is functional. - DDD
                        }
                    }
                    this.owner.triggerEvent(direction, event);
                    this.owner.triggerEvent("joystick-orientation", orientation);
                }
            },
            
            addController: (function () {
                var up = function (index) {
                        this.inputs[index] = false;
                    },
                    down = function (index) {
                        this.inputs[index] = true;
                    };
                
                return function (key, stateId, controller, states, controllerState) {
                    var actions = this.actions,
                        id = stateId + '-' + controller + '-' + (controllerState || 'all'),
                        actionState = actions.get(id); // If there's already a state storage object for this action, reuse it: there are multiple keys mapped to the same action.
                        
                    // Otherwise create a new state storage object
                    if (!actionState) {
                        if (controllerState) {
                            actionState = actions.set(id, ActionState.setUp(controller, states, filteredTrigger.bind(this, controllerState)));
                        } else {
                            actionState = actions.set(id, ActionState.setUp(controller, states, trigger.bind(this)));
                        }
                    }
                    
                    // Set up listeners and input flag.
                    this.addEventListener(key + ':up',   up.bind(actionState, actionState.inputs.length));
                    this.addEventListener(key + ':down', down.bind(actionState, actionState.inputs.length));
                    actionState.inputs.push(false);
                };
            }()),

            addMap: function (map, id, states) {
                var controller = null,
                    i = 0,
                    j = '',
                    key = '';
                
                for (key in map) {
                    if (map.hasOwnProperty(key)) {
                        controller = map[key];
                        if (typeof controller === 'string') {
                            this.addController(key, id, controller, states);
                        } else if (Array.isArray(controller)) {
                            for (i = 0; i < controller.length; i++) {
                                this.addController(key, id, controller[i], states);
                            }
                        } else {
                            for (j in controller) {
                                if (controller.hasOwnProperty(j)) {
                                    if (typeof controller[j] === 'string') {
                                        this.addController(key, id, controller[j], states, j);
                                    } else {
                                        for (i = 0; i < controller[j].length; i++) {
                                            this.addController(key, id, controller[j][i], states, j);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            
            destroy: function () {
                var actions = this.actions,
                    keys = actions.keys,
                    i = keys.length;
                
                while (i--) {
                    actions.get(keys[i]).recycle();
                }
                actions.recycle();
                if (this.joystick) {
                    this.joystick.recycle();
                }
            }
        }
    });
}());

//##############################################################################
// EventRender.js
//##############################################################################

/**
 * This component is typically added to an entity automatically by a render component. It handles mapping entity events to playable animations.
 *
 * @class EventRender
 * @uses platypus.Component
 * @since 0.9.0
 */
/*global platypus */
(function () {
    'use strict';
    
    return platypus.createComponentClass({
        id: 'EventRender',

        properties: {
            /**
             * An object containg key-value pairs that define a mapping from triggered events to the animation that should play.
             *
             *     "animationMap":{
             *         "move": "walk-animation",
             *         "jump": "jumping-animation"
             *     }
             *
             * The above will create two event listeners on the entity, "move" and "jump", that will play their corresponding animations when the events are triggered.
             *
             * @property animationMap
             * @type Object
             * @default null
             */
            "animationMap": null
        },

        constructor: (function () {
            var trigger = function (animation) {
                /**
                 * On receiving an animation-mapped event, this component triggers this event to play an animation.
                 *
                 * @event 'play-animation'
                 * @param animation {String} Describes the animation to play.
                 */
                this.owner.triggerEvent('play-animation', animation);
            };

            return function () {
                var animation = '',
                    map = this.animationMap;

                for (animation in map) {
                    if (map.hasOwnProperty(animation)) {
                        this.addEventListener(animation, trigger.bind(this, map[animation]));
                    }
                }
            };
        } ())
    });
}());

//##############################################################################
// HandlerCollision.js
//##############################################################################

/**
 * This component checks for collisions between entities which typically have either a [CollisionTiles](platypus.components.CollisionTiles.html) component for tile maps or a [CollisionBasic](platypus.components.CollisionBasic.html) component for other entities. It uses `EntityContainer` component messages if triggered to add to its collision list and also listens for explicit add/remove messages (useful in the absence of an `EntityContainer` component).
 *
 * @namespace platypus.components
 * @class HandlerCollision
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    //set here to make them reusable objects
    
    /**
     * When an entity collides with an entity of a listed collision-type, this message is triggered on the entity. * is the other entity's collision-type.
     *
     * @event 'hit-by-*'
     * @param collision {Object}
     * @param collision.entity {Entity} The entity with which the collision occurred.
     * @param collision.type {String} The collision type of the other entity.
     * @param collision.shape {CollisionShape} This is the shape of the other entity that caused the collision.
     * @param collision.x {number} Returns -1, 0, or 1 indicating on which side of this entity the collision occurred: left, neither, or right respectively.
     * @param collision.y {number} Returns -1, 0, or 1 indicating on which side of this entity the collision occurred: top, neither, or bottom respectively.
     */
    var AABB = include('platypus.AABB'),
        CollisionData = include('platypus.CollisionData'),
        CollisionDataContainer = include('platypus.CollisionDataContainer'),
        Data = include('platypus.Data'),
        DataMap = include('platypus.DataMap'),
        Vector = include('platypus.Vector'),
        triggerMessage = {
            entity: null,
            type: null,
            x: 0,
            y: 0,
            hitType: null,
            myType: null
        },
        groupSortBySize = function (a, b) {
            return a.collisionGroup.getAllEntities() - b.collisionGroup.getAllEntities();
        };
    
    return platypus.createComponentClass({
        id: 'HandlerCollision',
        
        properties: {
            /**
             *
             */
            gridBits: 8
        },
        
        constructor: function () {
            this.againstGrid = Data.setUp();
            
            this.solidEntitiesLive = Array.setUp();
            this.softEntitiesLive = Array.setUp();
            this.allEntitiesLive = Array.setUp();
            this.groupsLive = Array.setUp();
            this.nonColliders = Array.setUp();
            
            this.terrain = null;
            this.owner.previousX = this.owner.previousX || this.owner.x;
            this.owner.previousY = this.owner.previousY || this.owner.y;
            
            this.relocationMessage = Data.setUp(
                "position", Vector.setUp(),
                "relative", false
            );
        },
        
        events: {
            /**
             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.
             *
             * @method 'child-entity-added'
             * @param entity {Entity} The entity to be added.
             */
            "child-entity-added": function (entity) {
                if (!entity.collideOff) {
                    this.addCollisionEntity(entity);
                }
            },
            
            /**
             * On receiving this message, the component checks the entity to determine whether it listens for collision messages. If so, the entity is added to the collision group.
             *
             * @method 'add-collision-entity'
             * @param entity {Entity} The entity to be added.
             */
            "add-collision-entity": function (entity) {
                this.addCollisionEntity(entity);
            },
            
            /**
             * On receiving this message, the component looks for the entity in its collision group and removes it.
             *
             * @method 'child-entity-removed'
             * @param message {platypus.Entity} The entity to be removed.
             */
            "child-entity-removed": function (entity) {
                this.removeCollisionEntity(entity);
            },
            
            /**
             * On receiving this message, the component looks for the entity in its collision group and removes it.
             *
             * @method 'remove-collision-entity'
             * @param message {platypus.Entity} The entity to be removed.
             */
            "remove-collision-entity": function (entity) {
                this.removeCollisionEntity(entity);
            },
            
            /**
             * On receiving this message, the component looks for the entity in its collision group and updates it.
             *
             * @method 'child-entity-updated'
             * @param message {platypus.Entity} The entity to be updated.
             */
            "child-entity-updated": function (entity) {
                this.removeCollisionEntity(entity);
                this.addCollisionEntity(entity);
            },
            
            /**
             * This message causes the component to go through the entities and check for collisions.
             *
             * @method 'check-collision-group'
             * @param options {Object}
             * @param [options.camera] {Object} Specifies a region in which to check for collisions. Expects the camera object to contain the following properties: top, left, width, height, and buffer.
             */
            "check-collision-group": function (resp) {
                this.checkCamera(resp.camera, resp.entities);
                this.checkGroupCollisions();
                this.checkSolidCollisions();
                this.resolveNonCollisions();
                this.checkSoftCollisions(resp);
            }
        },
        
        methods: {
            mapDown: function (aabb2) {
                var aabb1 = AABB.setUp(),
                    gb = this.gridBits;
                
                return aabb1.setBounds(aabb2.left >> gb, aabb2.top >> gb, aabb2.right >> gb, aabb2.bottom >> gb);
            },
            
            getAgainstGrid: function (entity, sweep, types) {
                var aabb = this.mapDown(sweep),
                    arr = null,
                    data = Data.setUp(),
                    i = 0,
                    list = null,
                    thisAgainstGrid = this.againstGrid,
                    tList = null,
                    type = '',
                    x = 0,
                    y = 0;
                
                if (sweep.equals(entity.againstAABB)) {
                    return this.getEntityAgainstGrid(entity, types);
                }

                for (x = aabb.left; x <= aabb.right; x++) {
                    for (y = aabb.top; y <= aabb.bottom; y++) {
                        list = thisAgainstGrid[((y << 16) ^ x) >>> 0];
                        if (list) {
                            i = types.length;
                            while (i--) {
                                type = types[i];
                                arr = list.get(type);
                                if (arr && arr.length) {
                                    tList = data[type];
                                    if (!tList) {
                                        data[type] = Array.setUp.apply(null, arr);
                                    } else {
                                        tList.union(arr);
                                    }
                                }
                            }
                        }
                    }
                }
                
                aabb.recycle();
                return data;
            },
            
            getEntityAgainstGrid: function (entity, types) {
                var ag = entity.againstGrid,
                    arr = null,
                    data = Data.setUp(),
                    i = ag.length,
                    j = 0,
                    list = null,
                    tList = null,
                    type = '';

                while (i--) {
                    list = ag[i];
                    j = types.length;
                    while (j--) {
                        type = types[j];
                        arr = list.get(type);
                        if (arr && arr.length) {
                            tList = data[type];
                            if (!tList) {
                                data[type] = Array.setUp.apply(null, arr);
                            } else {
                                tList.union(arr);
                            }
                        }
                    }
                }
                
                return data;
            },
            
            removeAgainst: function (entity) {
                var ag = entity.againstGrid,
                    types = entity.collisionTypes,
                    arr = null,
                    i = ag.length,
                    j = 0,
                    id = 0,
                    len = types.length,
                    list = null;
                    
                while (i--) {
                    list = ag[i];
                    j = len;
                    while (j--) {
                        arr = list.get(types[j]);
                        if (arr) {
                            id = arr.indexOf(entity);
                            if (id >= 0) {
                                arr.greenSplice(id);
                            }
                        }
                    }
                }
                ag.length = 0;
            },
            
            updateAgainst: function (entity) {
                var arr = null,
                    i = 0,
                    type = '',
                    types = entity.collisionTypes,
                    aabb = this.mapDown(entity.getAABB()),
                    ag = entity.againstGrid,
                    id = 0,
                    list = null,
                    thisAgainstGrid = this.againstGrid,
                    x = 0,
                    y = 0;
                
                if (!aabb.equals(entity.againstAABB)) {
                    entity.againstAABB.set(aabb);
                    this.removeAgainst(entity);

                    for (x = aabb.left; x <= aabb.right; x++) {
                        for (y = aabb.top; y <= aabb.bottom; y++) {
                            id = ((y << 16) ^ x) >>> 0;
                            list = thisAgainstGrid[id];
                            if (!list) {
                                list = thisAgainstGrid[id] = DataMap.setUp();
                            }
                            i = types.length;
                            while (i--) {
                                type = types[i];
                                arr = list.get(type);
                                if (!arr) {
                                    arr = list.set(type, Array.setUp());
                                }
                                arr.push(entity);
                            }
                            ag.push(list);
                        }
                    }
                }
                
                aabb.recycle();
            },
            
            addCollisionEntity: function (entity) {
                if (entity.getTileShapes) { // Has a CollisionTiles component
                    this.terrain = entity;
                } else if (entity.collisionTypes) {
                    entity.againstGrid = Array.setUp();
                    entity.againstAABB = AABB.setUp();
                    this.updateAgainst(entity);
                }
            },

            removeCollisionEntity: function (entity) {
                if (entity.againstGrid) {
                    this.removeAgainst(entity);
                    entity.againstGrid.recycle();
                    entity.againstGrid = null;
                    entity.againstAABB.recycle();
                    entity.againstAABB = null;
                }
            },
            
            checkCamera: function (camera, all) {
                var i        = all.length,
                    j        = 0,
                    allLive  = this.allEntitiesLive,
                    softs    = this.softEntitiesLive,
                    solids   = this.solidEntitiesLive,
                    nons     = this.nonColliders,
                    groups   = this.groupsLive,
                    entity        = null,
                    types = null,
                    collides = false;
                
                allLive.length = 0;
                solids.length = 0;
                softs.length = 0;
                nons.length = 0;
                groups.length = 0;

                while (i--) {
                    collides = false;
                    entity = all[i];
                    types = entity.collisionTypes;
                    if (!entity.immobile && types && types.length) {
                        allLive.push(entity);

                        if (entity !== this.owner) {
                            j = types.length;
                            while (j--) {
                                if (entity.solidCollisionMap.get(types[j]).length) {
                                    solids.push(entity);
                                    collides = true;
                                    break;
                                }
                            }
                        }
                        j = types.length;
                        while (j--) {
                            if (entity.softCollisionMap.get(types[j]).length) {
                                softs.push(entity);
                                break;
                            }
                        }

                        if (!collides) {
                            nons.push(entity);
                        }

                        if (entity.collisionGroup) {
                            groups.push(entity);
                        }
                    }
                }
                
                groups.sort(groupSortBySize);
            },
            
            resolveNonCollisions: function () {
                var entity = null,
                    msg    = this.relocationMessage,
                    nons   = this.nonColliders,
                    i      = nons.length;
                
                msg.relative = false;
                while (i--) {
                    entity = nons[i];
                    if ((entity.position.x !== entity.previousPosition.x) || (entity.position.y !== entity.previousPosition.y)) {
                        msg.position.setVector(entity.position);

                        /**
                         * This message is triggered on an entity that has been repositioned due to a solid collision.
                         *
                         * @event 'relocate-entity'
                         * @param object {Object}
                         * @param object.position {Vector} The relocated position of the entity.
                         */
                        entity.triggerEvent('relocate-entity', msg);
                        this.updateAgainst(entity);
                    }
                }
            },
            
            checkGroupCollisions: (function () {
                var triggerCollisionMessages = function (entity, otherEntity, thisType, thatType, x, y, hitType, vector) {
                    var msg = triggerMessage;
                    
                    msg.entity    = otherEntity;
                    msg.myType    = thisType;
                    msg.type      = thatType;
                    msg.x         = x;
                    msg.y         = y;
                    msg.direction = vector;
                    msg.hitType   = hitType;
                    entity.triggerEvent('hit-by-' + thatType, msg);
                    
                    if (otherEntity) {
                        msg.entity    = entity;
                        msg.type      = thisType;
                        msg.myType    = thatType;
                        msg.x         = -x;
                        msg.y         = -y;
                        msg.direction = vector.getInverse();
                        msg.hitType   = hitType;
                        otherEntity.triggerEvent('hit-by-' + thisType, msg);
                        
                        msg.direction.recycle();
                    }
                };

                return function () {
                    var i           = 0,
                        entities    = this.groupsLive,
                        x           = entities.length,
                        entity      = null,
                        list        = null,
                        messageData = null,
                        entityCDC   = null;
                    
                    while (x--) {
                        entity = entities[x];
                        if (entity.collisionGroup.getSize() > 1) {
                            entityCDC = this.checkSolidEntityCollision(entity, entity.collisionGroup);
                            
                            list = entityCDC.xData;
                            i = list.length;
                            while (i--) {
                                messageData = list[i];
                                triggerCollisionMessages(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, messageData.direction, 0, 'solid', messageData.vector);
                            }
                            
                            list = entityCDC.yData;
                            i = list.length;
                            while (i--) {
                                messageData = list[i];
                                triggerCollisionMessages(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, 0, messageData.direction, 'solid', messageData.vector);
                            }
                            
                            entityCDC.recycle();
                        }
                    }
                };
            }()),
            
            checkSolidCollisions: (function () {
                var triggerCollisionMessages = function (entity, otherEntity, thisType, thatType, x, y, hitType, vector) {
                    var msg = triggerMessage;
                    
                    msg.entity    = otherEntity;
                    msg.myType    = thisType;
                    msg.type      = thatType;
                    msg.x         = x;
                    msg.y         = y;
                    msg.direction = vector;
                    msg.hitType   = hitType;
                    entity.triggerEvent('hit-by-' + thatType, msg);
                    
                    if (otherEntity) {
                        msg.entity    = entity;
                        msg.type      = thisType;
                        msg.myType    = thatType;
                        msg.x         = -x;
                        msg.y         = -y;
                        msg.direction = vector.getInverse();
                        msg.hitType   = hitType;
                        otherEntity.triggerEvent('hit-by-' + thisType, msg);
                        
                        msg.direction.recycle();
                    }
                };

                return function () {
                    var i           = 0,
                        entities    = this.solidEntitiesLive,
                        x           = entities.length,
                        entity      = null,
                        list        = null,
                        messageData = null,
                        entityCDC   = null,
                        trigger = triggerCollisionMessages;
                    
                    while (x--) {
                        entity = entities[x];
                        entityCDC = this.checkSolidEntityCollision(entity, entity);
                        
                        list = entityCDC.xData;
                        i = list.length;
                        while (i--) {
                            messageData = list[i];
                            trigger(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, messageData.direction, 0, 'solid', messageData.vector);
                        }
                        
                        list = entityCDC.yData;
                        i = list.length;
                        while (i--) {
                            messageData = list[i];
                            trigger(messageData.thisShape.owner, messageData.thatShape.owner, messageData.thisShape.collisionType, messageData.thatShape.collisionType, 0, messageData.direction, 'solid', messageData.vector);
                        }
                        
                        entityCDC.recycle();
                    }
                };
            }()),
            
            checkSolidEntityCollision: function (ent, entityOrGroup) {
                var collisionDataCollection = CollisionDataContainer.setUp(),
                    step              = 0,
                    finalMovementInfo = null,
                    aabb              = null,
                    pX                = ent.previousX,
                    pY                = ent.previousY,
                    dX                = ent.x - pX,
                    dY                = ent.y - pY,
                    sW                = Infinity,
                    sH                = Infinity,
                    collisionTypes    = entityOrGroup.getCollisionTypes(),
                    i                 = 0,
                    ignoredEntities   = false,
                    min               = null;
                
                if (entityOrGroup.getSolidEntities) {
                    ignoredEntities = entityOrGroup.getSolidEntities();
                }
                
                finalMovementInfo = Vector.setUp(ent.position);

                if (dX || dY) {
                    
                    if (ent.bullet) {
                        min = Math.min;
                        
                        i = collisionTypes.length;
                        while (i--) {
                            aabb = entityOrGroup.getAABB(collisionTypes[i]);
                            sW = min(sW, aabb.width);
                            sH = min(sH, aabb.height);
                        }

                        //Stepping to catch really fast entities - this is not perfect, but should prevent the majority of fallthrough cases.
                        step = Math.ceil(Math.max(Math.abs(dX) / sW, Math.abs(dY) / sH));
                        step = min(step, 100); //Prevent memory overflow if things move exponentially far.
                        dX   = dX / step;
                        dY   = dY / step;

                        while (step--) {
                            entityOrGroup.prepareCollision(ent.previousX + dX, ent.previousY + dY);

                            finalMovementInfo = this.processCollisionStep(ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo.setVector(ent.position), dX, dY, collisionTypes);
                            
                            if ((finalMovementInfo.x === ent.previousX) && (finalMovementInfo.y === ent.previousY)) {
                                entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);
                                //No more movement so we bail!
                                break;
                            } else {
                                entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);
                            }
                        }
                    } else {
                        entityOrGroup.prepareCollision(ent.previousX + dX, ent.previousY + dY);
                        finalMovementInfo = this.processCollisionStep(ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo, dX, dY, collisionTypes);
                        entityOrGroup.relocateEntity(finalMovementInfo, collisionDataCollection);
                    }

                    if ((finalMovementInfo.x !== pX) || (finalMovementInfo.y !== pY)) {
                        this.updateAgainst(ent);
                    }
                }
                
                finalMovementInfo.recycle();
                
                return collisionDataCollection;
            },
            
            processCollisionStep: (function () {
                var sweeper       = AABB.setUp(),
                    includeEntity = function (thisEntity, aabb, otherEntity, otherAABB, ignoredEntities, sweepAABB) {
                        var i = 0;
                        
                        //Chop out all the special case entities we don't want to check against.
                        if (otherEntity === thisEntity) {
                            return false;
                        } else if (otherEntity.jumpThrough && (aabb.bottom > otherAABB.top)) {
                            return false;
                        } else if (thisEntity.jumpThrough  && (otherAABB.bottom > aabb.top)) { // This will allow platforms to hit something solid sideways if it runs into them from the side even though originally they were above the top. - DDD
                            return false;
                        } else if (ignoredEntities) {
                            i = ignoredEntities.length;
                            while (i--) {
                                if (otherEntity === ignoredEntities[i]) {
                                    return false;
                                }
                            }
                        }
                        
                        return sweepAABB.collides(otherAABB);
                    };

                return function (ent, entityOrGroup, ignoredEntities, collisionDataCollection, finalMovementInfo, entityDeltaX, entityDeltaY, collisionTypes) {
                    var i = collisionTypes.length,
                        j = 0,
                        k = 0,
                        l = 0,
                        isIncluded = includeEntity,
                        potentialCollision       = false,
                        potentialCollidingShapes = Array.setUp(),
                        pcsGroup                 = null,
                        previousAABB             = null,
                        currentAABB              = null,
                        collisionType            = null,
                        otherEntity              = null,
                        otherCollisionType       = '',
                        otherAABB                = null,
                        otherShapes              = null,
                        otherEntities            = null,
                        terrain                  = this.terrain,
                        againstGrid          = null,
                        solidCollisionMap        = entityOrGroup.getSolidCollisions(),
                        collisionSubTypes        = null,
                        sweepAABB                = sweeper;
                    
//                    if (!entityOrGroup.jumpThrough || (entityDeltaY >= 0)) { //TODO: Need to extend jumpthrough to handle different directions and forward motion - DDD
    
                    while (i--) {
                        //Sweep the full movement of each collision type
                        potentialCollidingShapes[i] = pcsGroup = Array.setUp();
                        collisionType = collisionTypes[i];
                        previousAABB = entityOrGroup.getPreviousAABB(collisionType);
                        currentAABB = entityOrGroup.getAABB(collisionType);

                        sweepAABB.set(currentAABB);
                        sweepAABB.include(previousAABB);
                        
                        collisionSubTypes = solidCollisionMap.get(collisionType);
                        againstGrid = this.getAgainstGrid(ent, sweepAABB, collisionSubTypes);
                        j = collisionSubTypes.length;
                        while (j--) {
                            otherCollisionType = collisionSubTypes[j];
                            otherEntities = againstGrid[otherCollisionType];

                            if (otherEntities) {
                                k = otherEntities.length;
                                while (k--) {
                                    otherEntity = otherEntities[k];
                                    otherAABB = otherEntity.getAABB(otherCollisionType);

                                    //Do our sweep check against the AABB of the other object and add potentially colliding shapes to our list.
                                    if (isIncluded(ent, previousAABB, otherEntity, otherAABB, ignoredEntities, sweepAABB)) {
                                        otherShapes = otherEntity.getShapes(otherCollisionType);
                                        
                                        l = otherShapes.length;
                                        while (l--) {
                                            //Push the shapes on the end!
                                            pcsGroup.push(otherShapes[l]);
                                        }
                                        potentialCollision = true;
                                    }
                                }
                                otherEntities.recycle();
                            } else if (terrain) {
                                //Do our sweep check against the tiles and add potentially colliding shapes to our list.
                                otherShapes = terrain.getTileShapes(sweepAABB, previousAABB, otherCollisionType);
                                k = otherShapes.length;
                                while (k--) {
                                    //Push the shapes on the end!
                                    pcsGroup.push(otherShapes[k]);
                                    potentialCollision = true;
                                }
                            }
                        }
                        againstGrid.recycle();
                    }

                    if (potentialCollision) {
                        finalMovementInfo = this.resolveCollisionPosition(ent, entityOrGroup, finalMovementInfo, potentialCollidingShapes, collisionDataCollection, collisionTypes, entityDeltaX, entityDeltaY);
                    }
                    
                    // Array recycling
                    potentialCollidingShapes.recycle(2);
                    
                    return finalMovementInfo;
                };
            }()),
            
            resolveCollisionPosition: function (ent, entityOrGroup, finalMovementInfo, potentialCollidingShapes, collisionDataCollection, collisionTypes, entityDeltaX, entityDeltaY) {
                var j = 0,
                    cd = null;
                
                if (entityDeltaX !== 0) {
                    j = collisionTypes.length;
                    while (j--) {
                        //Move each collision type in X to find the min X movement
                        cd = this.findMinAxisMovement(ent, entityOrGroup, collisionTypes[j], 'x', potentialCollidingShapes[j]);
                        
                        if (!cd.occurred || !collisionDataCollection.tryToAddX(cd)) {
                            cd.recycle();
                        }
                    }
                }
                
                cd = collisionDataCollection.xData[0];
                if (cd) {
                    finalMovementInfo.x = ent.previousX + cd.deltaMovement * cd.direction;
                } else {
                    finalMovementInfo.x = ent.x;
                }
                
                // This moves the previous position of everything so that the check in Y can begin.
                entityOrGroup.movePreviousX(finalMovementInfo.x);
                
                if (entityDeltaY !== 0) {
                    j = collisionTypes.length;
                    while (j--) {
                        //Move each collision type in Y to find the min Y movement
                        cd = this.findMinAxisMovement(ent, entityOrGroup, collisionTypes[j], 'y', potentialCollidingShapes[j]);
                        
                        if (!cd.occurred || !collisionDataCollection.tryToAddY(cd)) {
                            cd.recycle();
                        }
                    }
                }
                
                cd = collisionDataCollection.yData[0];
                if (cd) {
                    finalMovementInfo.y = ent.previousY + cd.deltaMovement * cd.direction;
                } else {
                    finalMovementInfo.y = ent.y;
                }
                
                return finalMovementInfo;
            },
            
            findMinAxisMovement: function (ent, entityOrGroup, collisionType, axis, potentialCollidingShapes) {
                //Loop through my shapes of this type vs the colliding shapes and do precise collision returning the shortest movement in axis direction
                var bestCD     = CollisionData.setUp(),
                    shapes     = entityOrGroup.getShapes(collisionType),
                    prevShapes = entityOrGroup.getPrevShapes(collisionType),
                    cd         = null,
                    i          = shapes.length;
                
                while (i--) {
                    cd = this.findMinShapeMovementCollision(prevShapes[i], shapes[i], axis, potentialCollidingShapes);
                    
                    if (cd.occurred && (!bestCD.occurred //if a collision occurred and we haven't already had a collision.
                        || (cd.deltaMovement < bestCD.deltaMovement))) { //if a collision occurred and the diff is smaller than our best diff.
                        bestCD.recycle();
                        bestCD = cd;
                    } else {
                        cd.recycle();
                    }
                }
                
                return bestCD;
            },
            
            /**
             * Find the earliest point at which this shape collides with one of the potential colliding shapes along this axis.
             * For example, cycles through shapes a, b, and c to find the earliest position:
             *
             *    O---->   [b]  [a]     [c]
             *
             *    Returns collision location for:
             *
             *            O[b]
             *
             */
            findMinShapeMovementCollision: (function () {
                var returnInfo = {
                        position: 0,
                        contactVector: Vector.setUp()
                    },
                    getMovementDistance = function (currentDistance, minimumDistance) {
                        var pow = Math.pow;
                        
                        return Math.sqrt(pow(minimumDistance, 2) - pow(currentDistance, 2));
                    },
                    getCorner = function (circlePos, rectanglePos, half) {
                        var diff = circlePos - rectanglePos;
                        
                        return diff - (diff / Math.abs(diff)) * half;
                    },
                    getOffsetForCircleVsAABBX = function (circle, rect, moving, direction, v) {
                        var newAxisPosition = 0,
                            aabb = rect.aABB,
                            hw = aabb.halfWidth,
                            x = circle.x,
                            y = circle.y;

                        if (y >= aabb.top && y <= aabb.bottom) {
                            return hw + circle.radius;
                        } else {
                            y = getCorner(y, rect.y, aabb.halfHeight); // reusing y.
                            newAxisPosition = hw + getMovementDistance(y, circle.radius);
                            if (moving === circle) {
                                v.x = -getCorner(x - direction * newAxisPosition, rect.x, hw) / 2;
                                y = -y;
                            } else {
                                v.x = getCorner(x, rect.x - direction * newAxisPosition, hw) / 2;
                            }
                            v.y = y;
                            v.normalize();
                            return newAxisPosition;
                        }
                    },
                    getOffsetForCircleVsAABBY = function (circle, rect, moving, direction, v) {
                        var newAxisPosition = 0,
                            aabb = rect.aABB,
                            hh = aabb.halfHeight,
                            x = circle.x,
                            y = circle.y;

                        if (x >= aabb.left && x <= aabb.right) {
                            return hh + circle.radius;
                        } else {
                            x = getCorner(x, rect.x, aabb.halfWidth); // reusing x.
                            newAxisPosition = hh + getMovementDistance(x, circle.radius);
                            if (moving === circle) {
                                x = -x;
                                v.y = -getCorner(y - direction * newAxisPosition, rect.y, hh) / 2;
                            } else {
                                v.y = getCorner(y, rect.y - direction * newAxisPosition, hh) / 2;
                            }
                            v.x = x;
                            v.normalize();
                            return newAxisPosition;
                        }
                    },
                    findAxisCollisionPosition = { // Decision tree for quicker access, optimized for mobile devices.
                        x: {
                            rectangle: {
                                rectangle: function (direction, thisShape, thatShape) {
                                    var ri = returnInfo;

                                    ri.position = thatShape.x - direction * (thatShape.aABB.halfWidth + thisShape.aABB.halfWidth);
                                    ri.contactVector.setXYZ(direction, 0);

                                    return ri;
                                },
                                circle: function (direction, thisShape, thatShape) {
                                    var ri = returnInfo;

                                    ri.position = thatShape.x - direction * getOffsetForCircleVsAABBX(thatShape, thisShape, thisShape, direction, ri.contactVector.setXYZ(direction, 0));

                                    return ri;
                                }
                            },
                            circle: {
                                rectangle: function (direction, thisShape, thatShape) {
                                    var ri = returnInfo;

                                    ri.position = thatShape.x - direction * getOffsetForCircleVsAABBX(thisShape, thatShape, thisShape, direction, ri.contactVector.setXYZ(direction, 0));

                                    return ri;
                                },
                                circle: function (direction, thisShape, thatShape) {
                                    var y = thatShape.y - thisShape.y,
                                        position = thatShape.x - direction * getMovementDistance(y, thisShape.radius + thatShape.radius),
                                        ri = returnInfo;
                                        
                                    ri.contactVector.setXYZ(thatShape.x - position, y).normalize();
                                    ri.position = position;

                                    return ri;
                                }
                            }
                        },
                        y: {
                            rectangle: {
                                rectangle: function (direction, thisShape, thatShape) {
                                    var ri = returnInfo;

                                    ri.position = thatShape.y - direction * (thatShape.aABB.halfHeight + thisShape.aABB.halfHeight);
                                    ri.contactVector.setXYZ(0, direction);
                                    
                                    return ri;
                                },
                                circle: function (direction, thisShape, thatShape) {
                                    var ri = returnInfo;

                                    ri.position = thatShape.y - direction * getOffsetForCircleVsAABBY(thatShape, thisShape, thisShape, direction, ri.contactVector.setXYZ(0, direction));

                                    return ri;
                                }
                            },
                            circle: {
                                rectangle: function (direction, thisShape, thatShape) {
                                    var ri = returnInfo;

                                    ri.position = thatShape.y - direction * getOffsetForCircleVsAABBY(thisShape, thatShape, thisShape, direction, ri.contactVector.setXYZ(0, direction));

                                    return ri;
                                },
                                circle: function (direction, thisShape, thatShape) {
                                    var x = thatShape.x - thisShape.x,
                                        position = thatShape.y - direction * getMovementDistance(x, thisShape.radius + thatShape.radius),
                                        ri = returnInfo;
                                        
                                    ri.contactVector.setXYZ(x, thatShape.y - position).normalize();
                                    ri.position = position;

                                    return ri;
                                }
                            }
                        }
                    };
                
                return function (prevShape, currentShape, axis, potentialCollidingShapes) {
                    var i = 0,
                        initialPoint    = prevShape[axis],
                        goalPoint       = currentShape[axis],
                        translatedShape = prevShape,
                        direction       = ((initialPoint < goalPoint) ? 1 : -1),
                        position        = goalPoint,
                        pcShape         = null,
                        cd              = CollisionData.setUp(),
                        collisionInfo   = null,
                        finalPosition   = goalPoint,
                        findACP         = null;
                    
                    if (initialPoint !== goalPoint) {
                        findACP = findAxisCollisionPosition[axis][translatedShape.type];
                        
                        if (axis === 'x') {
                            translatedShape.moveX(goalPoint);
                        } else if (axis === 'y') {
                            translatedShape.moveY(goalPoint);
                        }
                        
                        i = potentialCollidingShapes.length;
                        while (i--) {
                            pcShape = potentialCollidingShapes[i];
                            position = goalPoint;
                            if (translatedShape.collides(pcShape)) {
                                collisionInfo = findACP[pcShape.type](direction, translatedShape, pcShape);
                                position = collisionInfo.position;
                                if (direction > 0) {
                                    if (position < finalPosition) {
                                        if (position < initialPoint) { // Reality check: I think this is necessary due to floating point inaccuracies. - DDD
                                            position = initialPoint;
                                        }
                                        finalPosition = position;
                                        cd.set(true, direction, finalPosition, Math.abs(finalPosition - initialPoint), pcShape.aABB, currentShape, pcShape, collisionInfo.contactVector, 0);
                                    }
                                } else if (position > finalPosition) {
                                    if (position > initialPoint) { // Reality check: I think this is necessary due to floating point inaccuracies. - DDD
                                        position = initialPoint;
                                    }
                                    finalPosition = position;
                                    cd.set(true, direction, finalPosition, Math.abs(finalPosition - initialPoint), pcShape.aABB, currentShape, pcShape, collisionInfo.contactVector, 0);
                                }
                            }
                        }
                    }
                    
                    return cd;
                };
            }()),
            
            checkSoftCollisions: (function () {
                var
                    trigger = function (collision) {
                        this.triggerEvent('hit-by-' + collision.type, collision);
                    };
                
                return function () {
                    var softs = this.softEntitiesLive,
                        entity = null,
                        i = softs.length,
                        t = trigger;
                        
                    while (i--) {
                        entity = softs[i];
                        this.checkEntityForSoftCollisions(entity, t.bind(entity));
                    }
                };
            }()),
            
            checkEntityForSoftCollisions: function (ent, callback) {
                var againstGrid = null,
                    otherEntity = null,
                    message = triggerMessage,
                    i   = ent.collisionTypes.length,
                    j   = 0,
                    k   = 0,
                    l   = 0,
                    m   = 0,
                    collisionType = null,
                    softCollisionMap = null,
                    otherEntities  = null,
                    otherCollisionType = null,
                    shapes = null,
                    otherShapes = null,
                    collisionFound = false;

                message.x = 0;
                message.y = 0;

                while (i--) {
                    collisionType = ent.collisionTypes[i];
                    softCollisionMap = ent.softCollisionMap.get(collisionType);
                    againstGrid = this.getEntityAgainstGrid(ent, softCollisionMap);
                    j = softCollisionMap.length;
                    while (j--) {
                        otherCollisionType = softCollisionMap[j];
                        otherEntities = againstGrid[otherCollisionType];
                        if (otherEntities) {
                            k = otherEntities.length;
                            while (k--) {
                                otherEntity = otherEntities[k];
                                if ((otherEntity !== ent) && (ent.getAABB(collisionType).collides(otherEntity.getAABB(otherCollisionType)))) {
                                    collisionFound = false;
                                    shapes = ent.getShapes(collisionType);
                                    otherShapes = otherEntity.getShapes(otherCollisionType);
                                    l = shapes.length;
                                    while (l--) {
                                        m = otherShapes.length;
                                        while (m--) {
                                            if (shapes[l].collides(otherShapes[m])) {
                                                //TML - We're only reporting the first shape we hit even though there may be multiple that we could be hitting.
                                                message.entity  = otherEntity;
                                                message.type    = otherCollisionType;
                                                message.myType  = collisionType;
                                                message.shape   = otherShapes[m];
                                                message.hitType = 'soft';
                                                
                                                callback(message);
                                                
                                                collisionFound = true;
                                                break;
                                            }
                                        }
                                        if (collisionFound) {
                                            break;
                                        }
                                    }
                                }
                            }
                            otherEntities.recycle();
                        }
                    }
                    againstGrid.recycle();
                }
            },
            
            destroy: function () {
                var ag = this.againstGrid,
                    data = null,
                    key = '',
                    keys = null,
                    i = 0;
                
                this.groupsLive.recycle();
                this.nonColliders.recycle();
                this.allEntitiesLive.recycle();
                this.softEntitiesLive.recycle();
                this.solidEntitiesLive.recycle();
                this.relocationMessage.position.recycle();
                this.relocationMessage.recycle();
                
                for (key in ag) {
                    if (ag.hasOwnProperty(key)) {
                        data = ag[key];
                        keys = data.keys;
                        i = keys.length;
                        while (i--) {
                            data.get(keys[i]).recycle();
                        }
                        data.recycle();
                    }
                }
                ag.recycle();
                this.againstGrid = null;
            }
        },
        
        publicMethods: {
            /**
             * This method returns an object containing world entities.
             *
             * @method getWorldEntities
             * @return {Array} A list of all world collision entities.
             */
            getWorldEntities: function () {
                return this.allEntitiesLive;
            },
            
            /**
             * This method returns an entity representing the collision map of the world.
             *
             * @method getWorldTerrain
             * @return {Entity} - An entity describing the collision map of the world. This entity typically includes a `CollisionTiles` component.
             */
            getWorldTerrain: function () {
                return this.terrain;
            },
            
            /**
             * This method returns a list of collision objects describing soft collisions between an entity and a list of other entities.
             *
             * @method getEntityCollisions
             * @param entity {Entity} The entity to test against the world.
             * @return collisions {Array} This is a list of collision objects describing the soft collisions.
             */
            getEntityCollisions: function (entity) {
                var collisions = Array.setUp();
                
                this.checkEntityForSoftCollisions(entity, function (collision) {
                    collisions.push(Data.setUp(collision));
                });
                
                return collisions;
            }
        }
    });
}());

//##############################################################################
// HandlerController.js
//##############################################################################

/**
 * This component handles capturing and relaying input information to the entities that care about it. It takes mouse, keyboard, and custom input messages. State messages are sent immediately to the entities when they are received, the 'HandlerController' message is sent to demarcate ticks.
 *
 * @namespace platypus.components
 * @class HandlerController
 * @uses platypus.Component
 */
/* global platypus, window */
(function () {
    'use strict';

    var
        keyMap = { //Note: if this list is changed, be sure to update https://github.com/PBS-KIDS/Platypus/wiki/Handler-controller-key-list
            kc0: 'unknown',
            kc8: 'backspace',
            kc9: 'tab',
            kc12: 'numpad-5-shift',
            kc13: 'enter',
            kc16: 'shift',
            kc17: 'ctrl',
            kc18: 'alt',
            kc19: 'pause',
            kc20: 'caps-lock',
            kc27: 'esc',
            kc32: 'space',
            kc33: 'page-up',
            kc34: 'page-down',
            kc35: 'end',
            kc36: 'home',
            kc37: 'left-arrow',
            kc38: 'up-arrow',
            kc39: 'right-arrow',
            kc40: 'down-arrow',
            kc42: 'numpad-multiply',
            kc43: 'numpad-add',
            kc44: 'print-screen',
            kc45: 'insert',
            kc46: 'delete',
            kc47: 'numpad-division',
            kc48: '0',
            kc49: '1',
            kc50: '2',
            kc51: '3',
            kc52: '4',
            kc53: '5',
            kc54: '6',
            kc55: '7',
            kc56: '8',
            kc57: '9',
            kc59: 'semicolon',
            kc61: 'equals',
            kc65: 'a',
            kc66: 'b',
            kc67: 'c',
            kc68: 'd',
            kc69: 'e',
            kc70: 'f',
            kc71: 'g',
            kc72: 'h',
            kc73: 'i',
            kc74: 'j',
            kc75: 'k',
            kc76: 'l',
            kc77: 'm',
            kc78: 'n',
            kc79: 'o',
            kc80: 'p',
            kc81: 'q',
            kc82: 'r',
            kc83: 's',
            kc84: 't',
            kc85: 'u',
            kc86: 'v',
            kc87: 'w',
            kc88: 'x',
            kc89: 'y',
            kc90: 'z',
            kc91: 'left-windows-start',
            kc92: 'right-windows-start',
            kc93: 'windows-menu',
            kc96: 'back-quote',
            kc106: 'numpad-multiply',
            kc107: 'numpad-add',
            kc109: 'numpad-minus',
            kc110: 'numpad-period',
            kc111: 'numpad-division',
            kc112: 'f1',
            kc113: 'f2',
            kc114: 'f3',
            kc115: 'f4',
            kc116: 'f5',
            kc117: 'f6',
            kc118: 'f7',
            kc119: 'f8',
            kc120: 'f9',
            kc121: 'f10',
            kc122: 'f11',
            kc123: 'f12',
            kc144: 'num-lock',
            kc145: 'scroll-lock',
            kc186: 'semicolon',
            kc187: 'equals',
            kc188: 'comma',
            kc189: 'hyphen',
            kc190: 'period',
            kc191: 'forward-slash',
            kc192: 'back-quote',
            kc219: 'open-bracket',
            kc220: 'back-slash',
            kc221: 'close-bracket',
            kc222: 'quote'
        };

    return platypus.createComponentClass({
        
        id: 'HandlerController',
        
        constructor: function () {
            this.callbackKeyUp   = null;
            this.callbackKeyDown = null;
            
            if (platypus.game.settings.debug) { // If this is a test build, leave in the browser key combinations so debug tools can be opened as expected.
                this.callbackKeyDown = function (event) {
                    this.keyDown(event);
                }.bind(this);
                this.callbackKeyUp = function (event) {
                    this.keyUp(event);
                }.bind(this);
            } else { // Otherwise remove default browser behavior for key inputs so that they do not interfere with game-play.
                this.callbackKeyDown = function (event) {
                    this.keyDown(event);
                    event.preventDefault(); // this may be too aggressive - if problems arise, we may need to limit this to certain key combos that get in the way of game-play. Example: (event.metaKey && event.keyCode == 37) causes an accidental cmd key press to send the browser back a page while playing and hitting the left arrow button.
                }.bind(this);
                this.callbackKeyUp = function (event) {
                    this.keyUp(event);
                    event.preventDefault(); // this may be too aggressive - if problems arise, we may need to limit this to certain key combos that get in the way of game-play. Example: (event.metaKey && event.keyCode == 37) causes an accidental cmd key press to send the browser back a page while playing and hitting the left arrow button.
                }.bind(this);
            }
            
            window.addEventListener('keydown', this.callbackKeyDown, true);
            window.addEventListener('keyup',   this.callbackKeyUp,   true);
        },
        events: {
            /**
             * Sends a 'handle-controller' message to all the entities the component is handling. If an entity does not handle the message, it's removed it from the entity list.
             *
             * @method 'tick'
             * @param tick {Object} An object containing tick data.
             */
            "tick": function (tick) {

                /**
                 * Sent to entities on each tick to handle whatever they need to regarding controls.
                 *
                 * @event 'handle-controller'
                 * @param tick {Object} An object containing tick data.
                 */
                if (this.owner.triggerEventOnChildren) {
                    this.owner.triggerEventOnChildren('handle-controller', tick);
                }
            }
        },
        methods: {
            keyDown: function (event) {

                /**
                 *  Message sent to an entity when a key goes from up to down.
                 *
                 * @event 'key:[keyId]:down'
                 * @param event {DOMEvent} The DOM event that triggered the keydown event.
                 */
                if (this.owner.triggerEventOnChildren) {
                    this.owner.triggerEventOnChildren('key:' + (keyMap['kc' + event.keyCode] || ('key-code-' + event.keyCode)) + ':down', event);
                }
            },
            keyUp: function (event) {

                /**
                 * Message sent to child entities when a key goes from down to up.
                 *
                 * @event 'key:[keyId]:up'
                 * @param event {DOMEvent} The DOM event that triggered the keyup event.
                 */
                if (this.owner.triggerEventOnChildren) {
                    this.owner.triggerEventOnChildren('key:' + (keyMap['kc' + event.keyCode] || ('key-code-' + event.keyCode)) + ':up', event);
                }
            },
            destroy: function () {
                window.removeEventListener('keydown', this.callbackKeyDown);
                window.removeEventListener('keyup',   this.callbackKeyUp);
            }
        }
    });
}());

//##############################################################################
// HandlerLogic.js
//##############################################################################

/**
 * A component that handles updating logic components. Each tick it calls all the entities that accept 'handle-logic' messages. This component is usually used on an "action-layer".
 *
 * @namespace platypus.components
 * @class HandlerLogic
 * @uses platypus.Component
 **/
/* global include, platypus */
(function () {
    'use strict';

    var AABB = include('platypus.AABB'),
        addAll = function (all, active) {
            var j = all.length;
            
            active.length = 0;
            while (j--) {
                active.push(all[j]);
            }
        },
        withinBounds = function (child, camera) {
            return child.alwaysOn || (child.aabb && camera.collides(child.getAABB())) || (typeof child.x === 'undefined') || camera.containsPoint(child.x, child.y);
        },
        checkCamera = function (all, active, camera) {
            var j = all.length,
                child = null;
            
            active.length = 0;
            while (j--) {
                child = all[j];
                if (withinBounds(child, camera)) {
                    active.push(child);
                }
            }
        },
        hasLogic = function (item/*, index, arr*/) {
            return (item === 'handle-logic' || item === 'handle-post-collision-logic' || item === 'prepare-logic' || item === 'state-changed' || item === 'handle-movement');
        };

    return platypus.createComponentClass({
        id: "HandlerLogic",
        properties: {
            /**
             * Whether logic should always run on all entities or only run on entities within the visible camera area (plus the buffer amount specified by the `buffer` property).
             *
             * @property alwaysOn
             * @type Boolean
             * @default false
             * @since 0.7.1
             */
            alwaysOn: false
        },
        publicProperties: {
            /**
             * The buffer area around the camera in which entity logic is active. This property is available on the Entity as `entity.buffer`.
             *
             * @property buffer
             * @type number
             * @default camera width / 10
             */
            buffer: -1,
            
            /**
             * The length in milliseconds of a single logic step. If the framerate drops too low, logic is run for each step of this many milliseconds. This property is available on the Entity as `entity.stepLength`.
             *
             * @property stepLength
             * @type number
             * @default 5
             */
            stepLength: 5,
            
            /**
             * The maximum number of steps to take for a given tick, to prevent lag overflow.
             *
             * @property maxStepsPerTick
             * @type number
             * @default 100
             */
            maxStepsPerTick: 100,
            
            /**
             * Whether logic should occur at an alternate speed. This is useful for simulations where the game should speed up or slow down.
             *
             * @property timeMultiplier
             * @type number
             * @default 1
             * @since 0.7.1
             */
            timeMultiplier: 1
        },
        constructor: function () {
            this.entities = Array.setUp();
            this.activeEntities = Array.setUp();
            this.removals = Array.setUp();
            
            this.inLogicLoop = false;

            if (this.alwaysOn) {
                this.updateList = addAll;
                this.camera = null;
            } else {
                this.updateList = checkCamera;
                this.camera = AABB.setUp();
            }
            
            this.paused = 0;
            this.leftoverTime = 0;
            this.message = {
                delta: this.stepLength,
                tick: null,
                camera: this.camera,
                entities: this.activeEntities
            };
        },
        
        events: {
            /**
             * Called when a new entity has been added and should be considered for addition to the handler. If the entity has a 'handle-logic' message id it's added to the list of entities.
             *
             * @method 'child-entity-added'
             * @param entity {platypus.Entity} The entity that is being considered for addition to the handler.
             */
            "child-entity-added": function (entity) {
                if (entity.getMessageIds().some(hasLogic)) {
                    this.entities.push(entity);
                    
                    // Add to the active entities list so that the collision loop is aware of and can handle the addition.
                    if (this.inLogicLoop && (!this.camera || withinBounds(entity, this.camera))) {
                        this.activeEntities.push(entity);
                    }
                }
            },

            /**
             * Called when an entity should be removed from the list of logically updated entities.
             *
             * @method 'child-entity-removed'
             * @param entity {platypus.Entity} The entity to be removed from the handler.
             */
            "child-entity-removed": function (entity) {
                var j = this.entities.indexOf(entity);
                
                if (j >= 0) {
                    this.entities.greenSplice(j);
                    if (this.inLogicLoop) {
                        this.removals.push(entity);
                    }
                }
            },
            
            /**
             * When this event is triggered, `handle-logic` messages cease to be triggered on each tick.
             *
             * @method 'pause-logic'
             * @param [options] {Object}
             * @param [options.time] {number} If set, this will pause the logic for this number of milliseconds. If not set, logic is paused until an `unpause-logic` message is triggered.
             */
            "pause-logic": function (resp) {
                if (resp && resp.time) {
                    this.paused = resp.time;
                } else {
                    this.paused = -1;
                }
                if (this.owner.triggerEventOnChildren) {
                    /**
                     * Notifies children entities that logic has been paused.
                     *
                     * @event 'logic-paused'
                     * @since 0.8.4
                     */
                    this.owner.triggerEventOnChildren('logic-paused');
                }
            },
            
            /**
             * When this event is triggered, `handle-logic` messages begin firing each tick.
             *
             * @method 'unpause-logic'
             */
            "unpause-logic": function () {
                this.paused = 0;
                if (this.owner.triggerEventOnChildren) {
                    /**
                     * Notifies children entities that logic has been unpaused.
                     *
                     * @event 'logic-unpaused'
                     * @since 0.8.4
                     */
                    this.owner.triggerEventOnChildren('logic-unpaused');
                }
            },
            
            /**
             * Changes the active logic area when the camera location changes.
             *
             * @method 'camera-update'
             * @param camera {Object}
             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.
             */
            "camera-update": function (camera) {
                var buffer = this.buffer,
                    cam = this.camera,
                    vp = null;
                
                if (cam) {
                    if (buffer === -1) {
                        buffer = camera.viewport.width / 10; // sets a default buffer based on the size of the world units if the buffer was not explicitly set.
                    }
                    
                    vp = camera.viewport;
                    cam.setBounds(vp.left - buffer, vp.top - buffer, vp.right + buffer, vp.bottom + buffer);
                }
            },
            
            /**
             * Sends a 'handle-logic' message to all the entities the component is handling. If an entity does not handle the message, it's removed it from the entity list.
             *
             * @method 'tick'
             * @param tick {Object} Tick information that is passed on to children entities via "handle-logic" events.
             * @param tick.delta {number} The time passed since the last tick.
             */
            "tick": function (resp) {
                var i = 0,
                    j = 0,
                    cycles = 0,
                    entity = null,
                    msg = this.message,
                    actives = this.activeEntities,
                    removals = this.removals,
                    stepLength = this.stepLength;
                
                this.leftoverTime += (resp.delta * this.timeMultiplier);
                cycles = Math.floor(this.leftoverTime / stepLength) || 1;
        
                // This makes the frames smoother, but adds variance into the calculations
        //        msg.delta = this.leftoverTime / cycles;
        //        this.leftoverTime = 0;
                
                // This makes the frames more exact, but varying step numbers between ticks can cause movement to be jerky
        //        msg.delta = Math.min(this.leftoverTime, this.stepLength);
        //        this.leftoverTime = Math.max(this.leftoverTime - (cycles * this.stepLength), 0);
        
                // This makes the frames exact, but varying step numbers between ticks can cause movement to be jerky
                msg.delta = stepLength;
                this.leftoverTime = Math.max(this.leftoverTime - (cycles * stepLength), 0);
        
                msg.tick = resp;
                
                this.updateList(this.entities, actives, this.camera);
                
                //Prevents game lockdown when processing takes longer than time alotted.
                cycles = Math.min(cycles, this.maxStepsPerTick);
                
                while (cycles--) {
                    
                    if (this.paused > 0) {
                        this.paused -= stepLength;
                        if (this.paused < 0) {
                            this.paused = 0;
                        }
                    }
                    
                    if (!this.paused) {
                        /**
                         * This event is triggered on the top-level layer to signify a "handle-logic" event is about to be triggered on children. This is unique from the layer's "tick" event in that it occurs the same number of times as the "handle-logic" event and will not occur if HandlerLogic is paused.
                         *
                         * @event 'logic-tick'
                         * @param tick.delta {Number} The time that has passed since the last tick.
                         * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.
                         * @param tick.entities {Array} This is a list of all the logically active entities.
                         * @since 0.8.1
                         */
                        this.owner.triggerEvent('logic-tick', msg);
                    
                        if (this.owner.triggerEventOnChildren) {
                            this.owner.triggerEventOnChildren('handle-ai', msg);
                        }

                        this.inLogicLoop = true;
                        i = actives.length;
                        while (i--) {
                            entity = actives[i];
                            
                            /**
                             * This event is triggered on children entities to run anything that should occur before "handle-logic". For example, removing or adding components should happen here and not in "handle-logic".
                             *
                             * @event 'prepare-logic'
                             * @param tick {Object}
                             * @param tick.delta {Number} The time that has passed since the last tick.
                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.
                             * @param tick.entities {Array} This is a list of all the logically active entities.
                             * @since 0.6.8
                             */
                            entity.triggerEvent('prepare-logic', msg);

                            /**
                             * This event is triggered on children entities to run their logic.
                             *
                             * @event 'handle-logic'
                             * @param tick {Object}
                             * @param tick.delta {Number} The time that has passed since the last tick.
                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.
                             * @param tick.entities {Array} This is a list of all the logically active entities.
                             */
                            entity.triggerEvent('handle-logic', msg);

                            /**
                             * This event is triggered on children entities to move. This happens immediately after logic so entity logic can determine movement.
                             *
                             * @event 'handle-movement'
                             * @param tick {Object}
                             * @param tick.delta {Number} The time that has passed since the last tick.
                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.
                             * @param tick.entities {Array} This is a list of all the logically active entities.
                             * @since 0.6.8
                             */
                            entity.triggerEvent('handle-movement', msg);
                        }
                        this.inLogicLoop = false;
                        
                        // This handles removing active entities from the list before collision checking, state-changing, etc.
                        if (removals.length) {
                            i = removals.length;
                            while (i--) {
                                j = actives.indexOf(removals[i]);
                                if (j >= 0) {
                                    actives.greenSplice(j);
                                }
                            }
                            removals.length = 0;
                        }
                        
                        i = actives.length;
                        /**
                         * This event is triggered on the entity (layer) to test collisions once logic has been completed.
                         *
                         * @event 'check-collision-group'
                         * @param tick {Object}
                         * @param tick.delta {Number} The time that has passed since the last tick.
                         * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.
                         * @param tick.entities {Array} This is a list of all the logically active entities.
                         */
                        if (this.owner.triggerEvent('check-collision-group', msg)) { // If a collision group is attached, make sure collision is processed on each logic tick.
                            /**
                             * This event is triggered on entities to run logic that may depend upon collision responses.
                             *
                             * @event 'handle-post-collision-logic'
                             * @param tick {Object}
                             * @param tick.delta {Number} The time that has passed since the last tick.
                             * @param tick.camera {null|platypus.AABB} The range of the logic camera area. This is typically larger than the visible camera. This value is `null` if `alwaysOn` is set to `true` on this component.
                             * @param tick.entities {Array} This is a list of all the logically active entities.
                             */
                                
                            /**
                             * Triggered on entities when the entity's state has been changed.
                             *
                             * @event 'state-changed'
                             * @param state {Object} A list of key/value pairs representing the owner's state (this value equals `entity.state`).
                             */
                            while (i--) {
                                entity = actives[i];
                                entity.triggerEvent('handle-post-collision-logic', msg);
                                if (entity.lastState.update(entity.state)) {
                                    entity.triggerEvent('state-changed', entity.state);
                                }
                            }
                        } else {
                            while (i--) {
                                entity = actives[i];
                                if (entity.lastState.update(entity.state)) {
                                    entity.triggerEvent('state-changed', entity.state);
                                }
                            }
                        }
                    }
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.entities.recycle();
                this.activeEntities.recycle();
                this.removals.recycle();
            }
        }
    });
}());

//##############################################################################
// HandlerRender.js
//##############################################################################

/**
 * A component that handles updating the render components on entities that are rendering via PIXI. Calls 'handle-render on children entities every tick. Also initializes handlers for mouse events on the layer level.
 *
 * @namespace platypus.components
 * @class HandlerRender
 * @uses platypus.Component
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Container = include('PIXI.Container'),
        Vector = include('platypus.Vector');

    return platypus.createComponentClass({

        id: "HandlerRender",

        properties: {
            /**
             * Indicates the types of input the Container will listen for. Defaults to none.
             *
             *      "acceptInput": {
             *          "click": false, // Whether to listen for mouse/touch events
             *          "camera": false, // Whether camera movement while the mouse (or touch) is triggered should result in a mousemove event
             *          "hover": false // Whether to capture mouse movement even when there is no mouse-down.
             *      }
             *
             * @property acceptInput
             * @type Object
             * @default null
             */
            acceptInput: null

        },

        publicProperties: {

        },

        constructor: function () {
            this.container = new Container();

            this.camera = {
                x: 0,
                y: 0
            };

            // The following appends necessary information to displayed objects to allow them to receive touches and clicks
            if (this.acceptInput) {
                this.click = this.acceptInput.click;
                this.cameraMovementMovesMouse = this.acceptInput.camera;
                this.hover = this.acceptInput.hover;
                if (this.click || this.hover) {
                    this.addInputs();
                }
            }

            this.renderMessage = {
                delta: 0,
                container: this.container
            };
        },

        events: {
            /**
             * Once the entity is loaded, this component triggers "render-world" to notify other components about the entities' display container.
             *
             * @method 'load'
             */
            "load": function () {
                /**
                 * Once the entity is loaded, this component triggers "render-world" to notify other components about the entities' display container.
                 *
                 * @event 'render-world'
                 * @param data {Object}
                 * @param data.world {PIXI.Container} Contains entities to be rendered.
                 */
                this.owner.triggerEvent('render-world', {
                    world: this.container
                });
            },

            /**
             * Called when a new entity has been added to the parent and should be considered for addition to the handler. Entities are sent a reference the Container that we're rendering to, so they can add their display objects to it and the delta from the lastest tick.
             *
             * @method 'child-entity-added'
             * @param entity {platypus.Entity} The entity added to the parent.
             */
            "child-entity-added": function (entity) {
                /**
                 * Triggered on an entity added to the parent.
                 *
                 * @event 'handle-render-load'
                 * @param data {Object}
                 * @param data.delta {Number} The delta time for this tick.
                 * @param data.container {PIXI.Container} The display Container the entities display objects should be added to.
                 */
                entity.triggerEvent('handle-render-load', this.renderMessage);
            },

            /**
             * Pauses the children of this render Container. If a pause time is not provided. It remains paused until 'unpause-render' is called.
             *
             * @method 'pause-render'
             * @param [data] {Object}
             * @param data.time {Number} How long to pause.
             */
            "pause-render": function (timeData) {
                if (timeData && timeData.time) {
                    this.paused = timeData.time;
                } else {
                    this.paused = -1;
                }
                if (this.owner.triggerEventOnChildren) {
                    /**
                     * Notifies children entities that rendering updates have been paused.
                     *
                     * @event 'render-paused'
                     * @since 0.8.4
                     */
                    this.owner.triggerEventOnChildren('render-paused');
                }
            },

            /**
             * Unpauses the children of this render Container.
             *
             * @method 'unpause-render'
             */
            "unpause-render": function () {
                this.paused = 0;
                if (this.owner.triggerEventOnChildren) {
                    /**
                     * Notifies children entities that rendering updates have been unpaused.
                     *
                     * @event 'render-unpaused'
                     * @since 0.8.4
                     */
                    this.owner.triggerEventOnChildren('render-unpaused');
                }
            },

            /**
             * Sends a 'handle-render' message to all the children in the Container. The children in the Container are also paused/unpaused if needed and sorted according to their z value.
             *
             * @method 'tick'
             * @param tick {Object} An object containing tick data.
             */
            "tick": (function () {
                var sort = function (a, b) {
                    return a.z - b.z;
                };

                return function (tick) {
                    var x = 0,
                        child   = null,
                        message = this.renderMessage;

                    message.delta = tick.delta;

                    if (this.paused > 0) {
                        this.paused -= tick.delta;
                        if (this.paused <= 0) {
                            this.paused = 0;
                        }
                    }

                    if (this.owner.triggerEventOnChildren) {
                        /**
                         * Triggered every tick on the children entities.
                         *
                         * @event 'handle-render'
                         * @param data {Object}
                         * @param data.delta {Number} The delta time for this tick.
                         * @param data.container {PIXI.Container} The display Container the entities display objects should be added to.
                         */
                        this.owner.triggerEventOnChildren('handle-render', message);
                    }

                    if (this.container) {
                        x = this.container.children.length;
                        while (x--) {
                            child = this.container.children[x];

                            if (child.visible) {
                                if (child.paused && !this.paused) {
                                    child.paused = false;
                                } else if (this.paused) {
                                    child.paused = true;
                                }
                            }
                        }

                        if (this.container.reorder) {
                            this.container.reorder = false;
                            this.container.children.sort(sort);
                        }

                    }
                };
            }()),

            /**
             * Triggered every time the camera position or scale updates. This event triggers the 'mousemove' event if camera movement is set to trigger it. It also updates the internal record of the camera position.
             *
             * @method 'camera-update'
             * @param cameraData {Object} A camera data object
             * @param cameraData.viewport {Object | AABB} An AABB describing the location and size of the camera.
             */
            "camera-update": function (cameraData) {
                this.camera.x = cameraData.viewport.left;
                this.camera.y = cameraData.viewport.top;

                if (this.moveMouse) {
                    this.moveMouse();
                }
            }

        },
        methods: {
            addInputs: (function () {
                var createHandler = function (self, eventName) {
                    return function (event) {
                        var stageX = event.data.global.x,
                            stageY = event.data.global.y,
                            nativeEvent = event.data.originalEvent,
                            x = 0,
                            y = 0;

                        //TML - This is in case we do a scene change using an event and the container is destroyed.
                        if (!self.container) {
                            return;
                        }

                        x = stageX / self.container.transformMatrix.a + self.camera.x;
                        y = stageY / self.container.transformMatrix.d + self.camera.y;

                        event.target.mouseTarget = true;

                        self.owner.trigger(eventName, {
                            event: nativeEvent,
                            pixiEvent: event,
                            x: x,
                            y: y,
                            entity: self.owner
                        });

                        if (self.cameraMovementMovesMouse) {
                            if (eventName === 'pressup') {
                                event.target.mouseTarget = false;
                                self.moveMouse = null;
                                if (event.target.removeDisplayObject) {
                                    event.target.removeDisplayObject();
                                }
                            } else {
                                // This function is used to trigger a move event when the camera moves and the mouse is still triggered.
                                self.moveMouse = function () {
                                    self.owner.triggerEvent('pressmove', {
                                        event: nativeEvent,
                                        x: stageX / self.container.transformMatrix.a + self.camera.x,
                                        y: stageY / self.container.transformMatrix.d + self.camera.y,
                                        entity: self.owner
                                    });
                                };
                            }
                        }
                    };
                };

                return function () {
                    var sprite    = this.container,
                        mousedown = null,
                        mouseover = null,
                        mouseout  = null,
                        pressmove = null,
                        pressup   = null,
                        click     = null,
                        tPM = null,
                        tPU = null,
                        tMD = null,
                        pressed   = false;

                    // The following appends necessary information to displayed objects to allow them to receive touches and clicks
                    if (this.click) {
                        sprite.interactive = true;
                        
                        /**
                         * Dispatched when the 'mousedown' event occurs on the container.
                         *
                         * @event 'mousedown'
                         * @param eventData {Object}
                         * @param eventData.event {Object | DOM Event} The native DOM event from the canvas.
                         * @param eventData.pixiEvent {Object | easeljs.MouseEvent} The MouseEvent sent by PIXI.
                         * @param eventData.x {Number} The x location of the mouse.
                         * @param eventData.y {Number} The y location of the mouse.
                         * @param eventData.entity {Object} The entity that contains this component.
                         */
                        tMD = createHandler(this, 'mousedown');
                        mousedown = function (event) {
                            tMD(event);
                            pressed = true;
                        }.bind(this);
                        
                        /**
                         * Dispatched when the 'pressmove' event occurs on the container.
                         *
                         * @event 'pressmove'
                         * @param eventData {Object}
                         * @param eventData.event {Object | DOM Event} The native DOM event from the canvas.
                         * @param eventData.pixiEvent {Object | easeljs.MouseEvent} The MouseEvent sent by PIXI.
                         * @param eventData.x {Number} The x location of the mouse.
                         * @param eventData.y {Number} The y location of the mouse.
                         * @param eventData.entity {Object} The entity that contains this component.
                         */
                        tPM = createHandler(this, 'pressmove');
                        pressmove = function (event) {
                            if (pressed) {
                                tPM(event);
                            }
                        }.bind(this);
                        
                        /**
                         * Dispatched when the 'pressup' event occurs on the container.
                         *
                         * @event 'pressup'
                         * @param eventData {Object}
                         * @param eventData.event {Object | DOM Event} The native DOM event from the canvas.
                         * @param eventData.pixiEvent {Object | easeljs.MouseEvent} The MouseEvent sent by PIXI.
                         * @param eventData.x {Number} The x location of the mouse.
                         * @param eventData.y {Number} The y location of the mouse.
                         * @param eventData.entity {Object} The entity that contains this component.
                         */
                        tPU = createHandler(this, 'pressup');
                        pressup   = function (event) {
                            tPU(event);
                            pressed = false;
                        }.bind(this);
                        
                        /**
                         * Dispatched when the 'click' event occurs on the container.
                         *
                         * @event 'click'
                         * @param eventData {Object}
                         * @param eventData.event {Object | DOM Event} The native DOM event from the canvas.
                         * @param eventData.pixiEvent {Object | easeljs.MouseEvent} The MouseEvent sent by PIXI.
                         * @param eventData.x {Number} The x location of the mouse.
                         * @param eventData.y {Number} The y location of the mouse.
                         * @param eventData.entity {Object} The entity that contains this component.
                         */
                        click     = createHandler(this, 'click');

                        sprite.addListener('mousedown',       mousedown);
                        sprite.addListener('touchstart',      mousedown);
                        sprite.addListener('mouseup',         pressup);
                        sprite.addListener('touchend',        pressup);
                        sprite.addListener('mouseupoutside',  pressup);
                        sprite.addListener('touchendoutside', pressup);
                        sprite.addListener('mousemove',       pressmove);
                        sprite.addListener('touchmove',       pressmove);
                        sprite.addListener('click',           click);
                        sprite.addListener('tap',             click);
                    }
                    if (this.hover) {
                        sprite.interactive = true;
                        
                        /**
                         * Dispatched when the 'mouseover' event occurs on the container.
                         *
                         * @event 'mouseover'
                         * @param eventData {Object}
                         * @param eventData.event {Object | DOM Event} The native DOM event from the canvas.
                         * @param eventData.pixiEvent {Object | easeljs.MouseEvent} The MouseEvent sent by PIXI.
                         * @param eventData.x {Number} The x location of the mouse.
                         * @param eventData.y {Number} The y location of the mouse.
                         * @param eventData.entity {Object} The entity that contains this component.
                         */
                        mouseover = createHandler(this, 'mouseover');
                        /**
                         * Dispatched when the 'mouseout' event occurs on the container.
                         *
                         * @event 'mouseout'
                         * @param eventData {Object}
                         * @param eventData.event {Object | DOM Event} The native DOM event from the canvas.
                         * @param eventData.pixiEvent {Object | easeljs.MouseEvent} The MouseEvent sent by PIXI.
                         * @param eventData.x {Number} The x location of the mouse.
                         * @param eventData.y {Number} The y location of the mouse.
                         * @param eventData.entity {Object} The entity that contains this component.
                         */
                        mouseout  = createHandler(this, 'mouseout');

                        sprite.addListener('mouseover', mouseover);
                        sprite.addListener('mouseout',  mouseout);
                    }

                    this.removeInputListeners = function () {
                        if (this.click) {
                            sprite.removeListener('mousedown',       mousedown);
                            sprite.removeListener('touchstart',      mousedown);
                            sprite.removeListener('mouseup',         pressup);
                            sprite.removeListener('touchend',        pressup);
                            sprite.removeListener('mouseupoutside',  pressup);
                            sprite.removeListener('touchendoutside', pressup);
                            sprite.removeListener('mousemove',       pressmove);
                            sprite.removeListener('touchmove',       pressmove);
                            sprite.removeListener('click',           click);
                            sprite.removeListener('tap',             click);
                        }
                        if (this.hover) {
                            sprite.removeListener('mouseover', mouseover);
                            sprite.removeListener('mouseout',  mouseout);
                        }
                        this.removeInputListeners = null;
                    };
                };
            }()),

            destroy: function () {
                if (this.container.mouseTarget) {
                    this.container.visible = false;
                    this.container.removeDisplayObject = function () {
                        this.container = null;
                    }.bind(this);
                } else {
                    this.container = null;
                }
            }
        },

        publicMethods: {
            windowToWorld: function (windowVector, withOffset, vector) {
                var worldVector = vector || Vector.setUp();
                
                worldVector.x = windowVector.x * this.worldPerWindowUnitWidth;
                worldVector.y = windowVector.y * this.worldPerWindowUnitHeight;
                
                if (withOffset !== false) {
                    worldVector.x -= this.viewport.x * this.worldPerWindowUnitWidth;
                    worldVector.y -= this.viewport.y * this.worldPerWindowUnitHeight;
                }

                return worldVector;
            },
            
            worldToWindow: function (worldVector, withOffset, vector) {
                var windowVector = vector || Vector.setUp();

                windowVector.x = worldVector.x * this.windowPerWorldUnitWidth;
                windowVector.y = worldVector.y * this.windowPerWorldUnitHeight;
                
                if (withOffset !== false) {
                    windowVector.x += this.viewport.x;
                    windowVector.y += this.viewport.y;
                }

                return windowVector;
            }
        }
    });
}());

//##############################################################################
// Interactive.js
//##############################################################################

/**
 * This component accepts touches and clicks on the entity. It is typically automatically added by a render component that requires interactive functionality.
 *
 * @class Interactive
 * @uses platypus.Component
 * @since 0.9.0
 */
/*global include, platypus */
(function () {
    'use strict';

    var AABB = include('platypus.AABB'),
        Circle = include('PIXI.Circle'),
        Data = include('platypus.Data'),
        Rectangle = include('PIXI.Rectangle');
    
    return platypus.createComponentClass({
        id: 'Interactive',

        properties: {
            /**
             * Sets the container that represents the interactive area.
             *
             * @property container
             * @type PIXI.Container
             * @default null
             */
            "container": null,

            /**
             * Sets the hit area for interactive responses by describing the dimensions of a clickable rectangle:
             *
             *     "hitArea": {
             *         "x": 10,
             *         "y": 10,
             *         "width": 40,
             *         "height": 40
             *     }
             *
             * A string can also be used to create more complex shapes via the PIXI graphics API like:
             *
             *     "hitArea": "r(10,20,40,40).dc(30,10,12)"
             *
             * Defaults to the container if not specified or, if simply set to `true`, a rectangle using the entity's dimensions.
             *
             * @property hitArea
             * @type Object|String|Boolean
             * @default null
             */
            "hitArea": null,

            /**
             * Sets whether the entity should respond to mouse hovering.
             *
             * @property hover
             * @type Boolean
             * @default false
             */
            "hover": false
        },
        
        publicProperties: {
            /**
             * Determines whether hovering over the sprite should alter the cursor.
             *
             * @property buttonMode
             * @type Boolean
             * @default false
             */
            buttonMode: false
        },
        
        constructor: function () {
            this.pressed = false;
            this.camera = AABB.setUp();
            if (this.hitArea) {
                this.container.hitArea = this.setHitArea(this.hitArea);
            }
        },

        events: {
            /**
             * Listens for this event to determine whether this sprite is visible.
             *
             * @method 'camera-update'
             * @param camera.viewport {platypus.AABB} Camera position and size.
             */
            "camera-update": function (camera) {
                this.camera.set(camera.viewport);
            },

            /**
             * Listens to this event to update whether the interactive element should be in button mode.
             *
             * @method 'handle-render'
             */
            "handle-render": function () {
                if (this.buttonMode !== this.container.buttonMode) {
                    this.container.buttonMode = this.buttonMode;
                }
            },

            /**
             * This event dispatches a PIXI.Event on this component's PIXI.Sprite. Useful for rerouting mouse/keyboard events.
             *
             * @method 'dispatch-event'
             * @param event {Object | PIXI.Event} The event to dispatch.
             */
            "dispatch-event": function (event) {
                this.sprite.dispatchEvent(this.sprite, event.event, event.data);
            },
            
            /**
             * Adds input event listeners to the sprite, enabling input.
             *
             * @method 'input-on'
             */
            "input-on": function () {
                if (!this.removeInputListeners) {
                    this.addInputs();
                }
            },
            
            /**
             * Removes the input event listeners on the sprite, disabling input.
             *
             * @method 'input-off'
             */
            "input-off": function () {
                if (this.removeInputListeners) {
                    this.removeInputListeners();
                }
            }
        },
        
        methods: {
            addInputs: (function () {
                var
                    trigger = function (eventName, event) {
                        var camera = this.camera,
                            container = this.container,
                            msg = null,
                            matrix = null;
                        
                        if (
                            !container || //TML - This is in case we do a scene change using an event and the container is destroyed.
                            !event.data.originalEvent // This is a workaround for a bug in Pixi 3 where phantom hover events are triggered. - DDD 7/20/16
                            ) {
                            return;
                        }

                        matrix = container.parent.transformMatrix;
                        msg = Data.setUp(
                            "event", event.data.originalEvent,
                            "pixiEvent", event,
                            "x", event.data.global.x / matrix.a + camera.left,
                            "y", event.data.global.y / matrix.d + camera.top,
                            "entity", this.owner
                        );

                        this.owner.trigger(eventName, msg);
                        msg.recycle();
                    },
                    triggerMousedown = function (eventName, event) {
                        if (!this.pressed) {
                            trigger.call(this, eventName, event);
                            event.target.mouseTarget = true;
                            this.pressed = true;
                        }
                    },
                    triggerPressmove = function (eventName, altEventName, event) {
                        if (this.pressed) {
                            trigger.call(this, eventName, event);
                            event.target.mouseTarget = true;
                        } else {
                            trigger.call(this, altEventName, event);
                        }
                    },
                    triggerPressup = function (eventName, event) {
                        if (this.pressed) {
                            trigger.call(this, eventName, event);
                            event.target.mouseTarget = false;
                            this.pressed = false;
                            
                            if (event.target.removeDisplayObject) {
                                event.target.removeDisplayObject();
                            }
                        }
                    },
                    removeInputListeners = function (sprite, mousedown, pressup, pressmove, click, mouseover, mouseout) {
                        sprite.removeListener('mousedown',       mousedown);
                        sprite.removeListener('touchstart',      mousedown);
                        sprite.removeListener('mouseup',         pressup);
                        sprite.removeListener('touchend',        pressup);
                        sprite.removeListener('mouseupoutside',  pressup);
                        sprite.removeListener('touchendoutside', pressup);
                        sprite.removeListener('mousemove',       pressmove);
                        sprite.removeListener('touchmove',       pressmove);
                        sprite.removeListener('click',           click);
                        sprite.removeListener('tap',             click);

                        if (this.hover) {
                            sprite.removeListener('mouseover', mouseover);
                            sprite.removeListener('mouseout',  mouseout);
                        }
                        sprite.interactive = false;
                        this.removeInputListeners = null;
                    };

                return function () {
                    var sprite    = this.container,
                        mousedown = null,
                        mouseover = null,
                        mouseout  = null,
                        pressmove = null,
                        pressup   = null,
                        click     = null;
                    
                    // The following appends necessary information to displayed objects to allow them to receive touches and clicks
                    sprite.interactive = true;
                    
                    mousedown = triggerMousedown.bind(this, 'mousedown');
                    pressmove = triggerPressmove.bind(this, 'pressmove', 'mousemove');
                    pressup   = triggerPressup.bind(this, 'pressup');
                    click     = trigger.bind(this, 'click');
                    
                    sprite.addListener('mousedown',       mousedown);
                    sprite.addListener('touchstart',      mousedown);
                    sprite.addListener('mouseup',         pressup);
                    sprite.addListener('touchend',        pressup);
                    sprite.addListener('mouseupoutside',  pressup);
                    sprite.addListener('touchendoutside', pressup);
                    sprite.addListener('mousemove',       pressmove);
                    sprite.addListener('touchmove',       pressmove);
                    sprite.addListener('click',           click);
                    sprite.addListener('tap',             click);

                    if (this.hover) {
                        mouseover = trigger.bind(this, 'mouseover');
                        mouseout  = trigger.bind(this, 'mouseout');

                        sprite.addListener('mouseover', mouseover);
                        sprite.addListener('mouseout',  mouseout);
                    }

                    this.removeInputListeners = removeInputListeners.bind(this, sprite, mousedown, pressup, pressmove, click, mouseover, mouseout);
                };
            }()),

            setHitArea: (function () {
                var savedHitAreas = {}; //So generated hitAreas are reused across identical entities.
                
                return function (shape) {
                    var ha  = null,
                        sav = '';
                    
                    sav = JSON.stringify(shape);
                    
                    ha = savedHitAreas[sav];

                    if (!ha) {
                        if (shape.radius) {
                            ha = new Circle(shape.x || 0, shape.y || 0, shape.radius);
                        } else {
                            ha = new Rectangle(shape.x || 0, shape.y || 0, shape.width || this.owner.width || 0, shape.height || this.owner.height || 0);
                        }
                        
                        savedHitAreas[sav] = ha;
                    }
                    
                    return ha;
                };
            }()),

            destroy: (function () {
                var
                    removeAfterMouseUp = function () {
                        this.container.parent.removeChild(this.container);
                        this.container = null;
                    };

                return function () {
                    if (this.removeInputListeners) {
                        this.removeInputListeners();
                    }

                    this.camera.recycle();
                    
                    // This handles removal after the mouseup event to prevent weird input behaviors. If it's not currently a mouse target, we let the render component handle its removal from the parent container.
                    if (this.container.mouseTarget && this.container.parent) {
                        this.container.visible = false;
                        this.container.removeDisplayObject = removeAfterMouseUp.bind(this);
                    }
                };
            }())
        },
        
        publicMethods: {
            
        }
    });
}());

//##############################################################################
// LevelBuilder.js
//##############################################################################

/**
 * This component works in tandem with 'TiledLoader by taking several Tiled maps and combining them before `TiledLoader` processes them. Tiled maps must use the same tilesets for this to function correctly.
 *
 * Note: Set "manuallyLoad" to `true` in the `TiledLoader` component JSON definition so that it will wait for this component's "load-level" call.
 *
 * @namespace platypus.components
 * @class LevelBuilder
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    var
        mergeData = function (levelData, levelMergeAxisLength, segmentData, segmentMergeAxisLength, nonMergeAxisLength, mergeAxis) {
            var x        = 0,
                y        = 0,
                z        = 0,
                combined = levelData.greenSlice();

            if (mergeAxis === 'horizontal') {
                for (y = nonMergeAxisLength - 1; y >= 0; y--) {
                    for (x = y * segmentMergeAxisLength, z = 0; x < (y + 1) * segmentMergeAxisLength; x++, z++) {
                        combined.splice(((y + 1) * levelMergeAxisLength) + z, 0, segmentData[x]);
                    }
                }
                return combined;
            } else if (mergeAxis === 'vertical') {
                return levelData.concat(segmentData);
            }
            
            return null;
        },
        mergeObjects  = function (obj1s, obj2s, mergeAxisLength, mergeAxis) {
            var i    = 0,
                j    = '',
                list = obj1s.greenSlice(),
                obj  = null;

            for (i = 0; i < obj2s.length; i++) {
                obj = {};
                for (j in obj2s[i]) {
                    if (obj2s[i].hasOwnProperty(j)) {
                        obj[j] = obj2s[i][j];
                    }
                }
                if (mergeAxis === 'horizontal') {
                    obj.x += mergeAxisLength;
                } else if (mergeAxis === 'vertical') {
                    obj.y += mergeAxisLength;
                }
                list.push(obj);
            }
            return list;
        },
        mergeSegment  = function (level, segment, mergeAxis, decoder) {
            var i = 0,
                j = '';

            if (!level.tilewidth && !level.tileheight) {
                //set level tile size data if it's not already set.
                level.tilewidth  = segment.tilewidth;
                level.tileheight = segment.tileheight;
            } else if (level.tilewidth !== segment.tilewidth || level.tileheight !== segment.tileheight) {
                platypus.debug.warn('Tiled-Loader: Your map has segments with different tile sizes. All tile sizes must match. Segment: ' + segment);
            }

            if (mergeAxis === 'horizontal') {
                if (level.height === 0) {
                    level.height = segment.height;
                } else if (level.height !== segment.height) {
                    platypus.debug.warn('Tiled-Loader: You are trying to merge segments with different heights. All segments need to have the same height. Level: ' + level + ' Segment: ' + segment);
                }
            } else if (mergeAxis === 'vertical') {
                if (level.width === 0) {
                    level.width = segment.width;
                } else if (level.width !== segment.width) {
                    platypus.debug.warn('Tiled-Loader: You are trying to merge segments with different widths. All segments need to have the same width. Level: ' + level + ' Segment: ' + segment);
                }
            }

            for (i = 0; i < segment.layers.length; i++) {
                if (!level.layers[i]) {
                    //if the level doesn't have a layer yet, we're creating it and then copying it from the segment.
                    decoder(segment.layers[i]);
                    level.layers[i] = {};
                    for (j in segment.layers[i]) {
                        if (segment.layers[i].hasOwnProperty(j)) {
                            level.layers[i][j] = segment.layers[i][j];
                        }
                    }
                } else if (level.layers[i].type === segment.layers[i].type) {
                    //if the level does have a layer, we're appending the new data to it.
                    if (level.layers[i].data && segment.layers[i].data) {
                        // Make sure we're not trying to merge compressed levels.
                        decoder(segment.layers[i]);
                        
                        if (mergeAxis === 'horizontal') {
                            level.layers[i].data = mergeData(level.layers[i].data, level.width, segment.layers[i].data, segment.width, level.height, mergeAxis);
                            level.layers[i].width += segment.width;
                        } else if (mergeAxis === 'vertical') {
                            level.layers[i].data = mergeData(level.layers[i].data, level.height, segment.layers[i].data, segment.height, level.width, mergeAxis);
                            level.layers[i].height += segment.height;
                        }
                    } else if (level.layers[i].objects && segment.layers[i].objects) {
                        if (mergeAxis === 'horizontal') {
                            level.layers[i].objects = mergeObjects(level.layers[i].objects, segment.layers[i].objects, level.width * level.tilewidth, mergeAxis);
                        } else if (mergeAxis === 'vertical') {
                            level.layers[i].objects = mergeObjects(level.layers[i].objects, segment.layers[i].objects, level.height * level.tileheight, mergeAxis);
                        }
                    }
                } else {
                    platypus.debug.warn('Tiled-Loader: The layers in your level segments do not match. Level: ' + level + ' Segment: ' + segment);
                }
            }

            if (mergeAxis === 'horizontal') {
                level.width += segment.width;
            } else if (mergeAxis === 'vertical') {
                level.height += segment.height;
            }

            //Go through all the STUFF in segment and copy it to the level if it's not already there.
            for (j in segment) {
                if (segment.hasOwnProperty(j) && !level[j]) {
                    level[j] = segment[j];
                }
            }
        },
        mergeLevels = function (levelSegments, decoder) {
            var i = 0,
                j = 0,
                levelDefinitions = platypus.game.settings.levels,
                row = {
                    height: 0,
                    width: 0,
                    layers: []
                },
                level = {
                    height: 0,
                    width: 0,
                    layers: []
                },
                segmentsWide = levelSegments[i].length;

            for (i = 0; i < levelSegments.length; i++) {
                if (segmentsWide !== levelSegments[i].length) {
                    platypus.debug.warn('Tiled-Loader: Your map is not square. Maps must have an equal number of segments in every row.');
                }
                row = {
                    height: 0,
                    width: 0,
                    layers: []
                };
                for (j = 0; j < levelSegments[i].length; j++) {
                    //Merge horizontally
                    if (typeof levelSegments[i][j] === 'string') {
                        mergeSegment(row, levelDefinitions[levelSegments[i][j]], 'horizontal', decoder);
                    } else {
                        mergeSegment(row, levelSegments[i][j], 'horizontal', decoder);
                    }
                }
                //Then merge vertically
                mergeSegment(level, row, 'vertical', decoder);
            }
            return level;
        };

    return platypus.createComponentClass({
        id: 'LevelBuilder',
        
        properties: {
            /**
             * If true, no single map piece is used twice in the creation of the combined map.
             *
             * @property useUniques
             * @type Boolean
             * @default true
             */
            useUniques: true,
            /**
             * A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.
             *
             *      "levelTemplate": [ ["start", "forest"], ["forest", "end"] ]
             *
             * @property levelTemplate
             * @type Array
             * @default null
             */
            levelTemplate: null,
            /**
             * This is an object of key/value pairs listing the pieces that map to an id in the level template. The value can be specified as a string or array. A piece will be randomly chosen from an array when that idea is used. If levelPieces is not defined, ids in the template map directly to level names.
             *
             *      "levelPieces": {
             *          "start"  : "start-map",
             *          "end"      : "end-map",
             *          "forest" : ["forest-1", "forest-2", "forest-3"]
             *      }
             *
             * @property levelPieces
             * @type Object
             * @default null
             */
            levelPieces: null
        },

        publicProperties: {
        },
        
        constructor: function () {
            this.levelMessage = {level: null, persistentData: null};
        },

        events: {// These are messages that this component listens for

            /**
             * When the scene has loaded, LevelBuilder compiles the level based on the template and pieces and sends it to the TiledLoader.
             *
             * @method 'scene-loaded'
             * @param persistentData {Object} The persistent data from the previous scene.
             */
            "scene-loaded": function (persistentData) {
                var templateRow  = null,
                    piecesToCopy = null,
                    x            = '',
                    y            = 0,
                    i            = 0,
                    j            = 0;
                
                this.levelMessage.persistentData = persistentData;

                this.levelTemplate = persistentData.levelTemplate || this.levelTemplate;
                this.useUniques = persistentData.useUniques || this.useUniques;
                piecesToCopy = persistentData.levelPieces || this.levelPieces;
                this.levelPieces = {};
                if (piecesToCopy) {
                    for (x in piecesToCopy) {
                        if (piecesToCopy.hasOwnProperty(x)) {
                            if (typeof piecesToCopy[x] === "string") {
                                this.levelPieces[x] = piecesToCopy[x];
                            } else if (piecesToCopy[x].length) {
                                this.levelPieces[x] = [];
                                for (y = 0; y < piecesToCopy[x].length; y++) {
                                    this.levelPieces[x].push(piecesToCopy[x][y]);
                                }
                            } else {
                                throw ('Level Builder: Level pieces of incorrect type: ' + piecesToCopy[x]);
                            }
                        }
                    }
                }

                if (this.levelTemplate) {
                    if (this.levelTemplate) {
                        this.levelMessage.level = [];
                        for (i = 0; i < this.levelTemplate.length; i++) {
                            templateRow = this.levelTemplate[i];
                            if (typeof templateRow === "string") {
                                this.levelMessage.level[i] = this.getLevelPiece(templateRow);
                            } else if (templateRow.length) {
                                this.levelMessage.level[i] = [];
                                for (j = 0; j < templateRow.length; j++) {
                                    this.levelMessage.level[i][j] = this.getLevelPiece(templateRow[j]);
                                }
                            } else {
                                throw ('Level Builder: Template row is neither a string or array. What is it?');
                            }
                        }
                    } else {
                        throw ('Level Builder: Template is not defined');
                    }
                } else {
                    throw ('Level Builder: There is no level template.');
                }
                
                if (this.levelMessage.level) {
                    this.levelMessage.level = mergeLevels(this.levelMessage.level, this.owner.decodeLayer);
                    /**
                     * Dispatched when the scene has loaded and the level has been composited so TileLoader can begin loading the level.
                     *
                     * @event 'load-level'
                     * @param data {Object}
                     * @param data.level {Object} An object describing the level dimensions, tiles, and entities.
                     * @param data.persistentData {Object} The persistent data passed from the last scene. We add levelBuilder data to it to pass on.
                     * @param data.persistentData.levelTemplate {Object} A 1D or 2D array of level piece ids. The template defines how the pieces will be arranged and which pieces can be used where. The template must be rectangular in dimensions.
                     * @param data.persistentData.levelPieces {Object} An object of key/value pairs listing the pieces that map to an id in the level template.
                     * @param data.persistentData.useUniques {Boolean} If true, no single map piece is used twice in the creation of the combined map.
                     */
                    this.owner.triggerEvent('load-level', this.levelMessage);
                }
            }
        },
        
        methods: {// These are methods that are called by this component.
            getLevelPiece: function (type) {
                var pieces = this.levelPieces[type] || type,
                    temp   = null,
                    random = 0;
                
                if (pieces) {
                    if (typeof pieces === "string") {
                        if (this.useUniques) {
                            temp = pieces;
                            this.levelPieces[type] = null;
                            return temp;
                        } else {
                            return pieces;
                        }
                    } else if (pieces.length) {
                        random = Math.floor(Math.random() * pieces.length);
                        if (this.useUniques) {
                            return this.levelPieces[type].greenSplice(random);
                        } else {
                            return pieces[random];
                        }
                    } else {
                        throw ('Level Builder: There are no MORE level pieces of type: ' + type);
                    }
                } else {
                    throw ('Level Builder: There are no level pieces of type: ' + type);
                }
            },
            destroy: function () {
                this.levelMessage.level = null;
                this.levelMessage.persistentData = null;
                this.levelMessage = null;
            }
        },
        
        publicMethods: {
            mergeLevels: function (levels) {
                return mergeLevels(levels, this.owner.decodeLayer);
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var i = 0,
                arr = null,
                assets = Array.setUp(),
                key = '',
                levels = null;
            
            if (def && def.levelPieces) {
                levels = def.levelPieces;
            } else if (props && props.levelPieces) {
                levels = props.levelPieces;
            } else if (defaultProps && defaultProps.levelPieces) {
                levels = defaultProps.levelPieces;
            }
            
            if (levels) {
                for (key in levels) {
                    if (levels.hasOwnProperty(key)) {
                        // Offload to TiledLoader since it has level-parsing handling
                        if (Array.isArray(levels[key])) {
                            for (i = 0; i < levels[key].length; i++) {
                                arr = platypus.components.TiledLoader.getAssetList({
                                    level: levels[key][i]
                                }, props, defaultProps);
                                assets.union(arr);
                                arr.recycle();
                            }
                        } else {
                            arr = platypus.components.TiledLoader.getAssetList({
                                level: levels[key]
                            }, props, defaultProps);
                            assets.union(arr);
                            arr.recycle();
                        }
                    }
                }
            }
            
            return assets;
        }
    });
}());

//##############################################################################
// LogicAngularMovement.js
//##############################################################################

/**
 * This component moves the entity in the direction of an internally stored angle value. When moving, the entity constantly accelerates the entity in a direction up to a max velocity.
 *
 * @namespace platypus.components
 * @class LogicAngularMovement
 * @uses platypus.Component
 */

/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        
        id: 'LogicAngularMovement',
        
        properties: {
            /**
             * The max velocity.
             *
             * @property maxVelocity
             * @type Number
             * @default 3
             */
            maxVelocity: 3,

            /**
             * The rate of acceleration.
             *
             * @property acceleration
             * @type Number
             * @default 0.01
             */
            acceleration: 0.01,

            /**
             * The offset between the rotation value of the entity and the rotation of the art.
             *
             * @property visualOffset
             * @type Number
             * @default 0
             */
            visualOffset: 0,

            /**
             * The starting heading at which the entity will accelerate. In radians.
             *
             * @property startAngle
             * @type Number
             * @default 0
             */
            startAngle: 0
        },

        publicProperties: {

        },

        constructor: function () {
            this.angle     = this.startAngle;
            this.v         = Array.setUp(0, 0);
            this.moving    = false;
            this.piOverTwo = Math.PI / 2;
            this.owner.rotation = this.owner.rotation || this.visualOffset;
        },

        events: {

            /**
             * Updates the position, velocity, and rotation of the entity
             *
             * @method 'handle-logic'
             * @param tick {Object} The tick data.
             */
            "handle-logic": function (tick) {
                var PI  = Math.PI,
                    sin = Math.sin,
                    cos = Math.cos,
                    min = Math.min,
                    max = Math.max,
                    delta        = tick.delta,
                    currentAngle = 0;
                
                if (this.moving) {
                    this.v[0] += this.acceleration * cos(this.angle) * delta;
                    this.v[1] += this.acceleration * sin(this.angle) * delta;
                    if (this.v[0] === 0) {
                        if (this.v[1] > 0) {
                            currentAngle = this.piOverTwo;
                        } else if (this.v[1] < 0) {
                            currentAngle = -this.piOverTwo;
                        } else {
                            currentAngle = this.angle;
                        }
                    } else {
                        currentAngle = Math.atan(this.v[1] / this.v[0]);
                        if (this.v[0] < 0) {
                            currentAngle = PI + currentAngle;
                        }
                    }
                    if (this.v[0] >= 0) {
                        this.v[0] = min(this.v[0], this.maxVelocity * cos(currentAngle));
                    } else {
                        this.v[0] = max(this.v[0], this.maxVelocity * cos(currentAngle));
                    }
                    if (this.v[1] >= 0) {
                        this.v[1] = min(this.v[1], this.maxVelocity * sin(currentAngle));
                    } else {
                        this.v[1] = max(this.v[1], this.maxVelocity * sin(currentAngle));
                    }
                    
                    this.owner.x += this.v[0];
                    this.owner.y += this.v[1];

                    this.owner.rotation = (currentAngle * (180 / PI)) + this.visualOffset;
                }
            },
            /**
             * Sets the internal heading angle in the component.
             *
             * @method 'set-angle'
             * @param angle {Number} The value you want to set the angle to.
             */
            "set-angle": function (angle) {
                this.angle = angle;
            },
            /**
             * Start the entity accelerating toward the heading angle.
             *
             * @method 'move'
             */
            "move": function () {
                this.moving = true;
            },
            /**
             * Stops the movement toward the heading angle.
             *
             * @method 'stop'
             */
            "stop": function () {
                this.moving = false;
                this.v[0] = 0;
                this.v[1] = 0;
            },
            /**
             * Set the max velocity.
             *
             * @method 'set-max-velocity'
             * @param newMaxV {Number} The max velocity value.
             */
            "set-max-velocity": function (newMaxV) {
                this.maxVelocity = newMaxV;
            }
        },
        
        methods: {
            destroy: function () {
                this.v.recycle();
            }
        }
    });
}());

//##############################################################################
// LogicAttachment.js
//##############################################################################

/**
 * Creates an entity and connects it with the owner entity. This is useful for entities that have a one-to-one relationship with a given entity and must move as if connected to the host entity.
 *
 * @namespace platypus.components
 * @class LogicAttachment
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';

    var Entity = include('platypus.Entity'),
        linkId = 0;

    return platypus.createComponentClass({

        id: 'LogicAttachment',

        properties: {
            /**
             * An owner state, set to true when the attachment is attached. Meant to be read by other components or used in rendering.
             *
             * @property attachState
             * @type String
             * @default 'attached'
             */
            attachState: 'attached',
            /**
             * The type of the entity to be attached.
             *
             * @property attachment
             * @type String
             * @default ''
             */
            attachment: '',

            /**
             * The offset of the attached entity in x from the attachee.
             *
             * @property offsetX
             * @type Number
             * @default 0
             */
            offsetX: 0,
            /**
             * The offset of the attached entity in y from the attachee.
             *
             * @property offsetY
             * @type Number
             * @default 0
             */
            offsetY: 0,
            /**
             * The offset of the attached entity in z from the attachee.
             *
             * @property offsetZ
             * @type Number
             * @default 0
             */
            offsetZ: 0.01
        },

        publicProperties: {

        },

        constructor: function () {
            this.state = this.owner.state;

            if (!this.owner.linkId) {
                this.owner.linkId = 'attachment-link-' + linkId;
                linkId += 1;
            }

            this.state.set(this.attachState, false);
            this.attachmentPosition = {
                x: 0,
                y: 0,
                z: 0,
                dx: 0,
                dy: 0,
                linkId: this.owner.linkId
            };
            this.attachmentProperties = {
                type: this.attachment,
                properties: this.attachmentPosition
            };

            this.attachment = null;
            this.isAttached = false;
        },

        events: {// These are messages that this component listens for

            /**
             * On receiving this message, updates the attached entity's position.
             *
             * @method 'handle-logic'
             */
            "handle-logic": function () {
                var offset = 0,
                    state  = this.state;

                if (this.isAttached) {
                    if (!this.attachment) {
                        this.attachmentPosition.x = this.owner.x;
                        this.attachmentPosition.y = this.owner.y;
                        this.attachmentPosition.z = this.owner.z;
                        this.attachment = this.owner.parent.addEntity(this.attachmentProperties);
                    }
                    
                    if (this.attachment.destroyed) {
                        this.owner.parent.removeEntity(this.attachment);
                        this.attachment = null;
                        this.isAttached = false;
                    } else {
                        this.attachment.x = this.owner.x;
                        offset = this.offsetX;
                        if (state.get('left')) { //TODO: Base this on object orientation. - DDD 3/2/2016
                            offset *= -1;
                            this.attachment.rotation = 180;
                        } else if (state.get('right')) {
                            this.attachment.rotation = 0;
                        }
                        this.attachment.x += offset;

                        this.attachment.y = this.owner.y;
                        offset = this.offsetY;
                        if (state.get('top')) {
                            offset *= -1;
                            this.attachment.rotation = 90;
                        } else if (state.get('bottom')) {
                            this.attachment.rotation = -90;
                        }
                        this.attachment.y += offset;

                        this.attachment.z = this.owner.z;
                        this.attachment.z += this.offsetZ;
                    }
                } else if (this.attachment) {
                    this.owner.parent.removeEntity(this.attachment);
                    this.attachment = null;
                }
                
                state.set(this.attachState, this.isAttached);
            },

            /**
             * Creates and attaches the entity. The input value makes it possible to attach the entity on user input.
             *
             * @method 'attach'
             * @param input {Object} An input object.
             * @param input.pressed {Boolean} If set to true, the entity is created and attached.
             */
            "attach": function (input) {
                this.isAttached = !input || (input.pressed !== false);
            },
            /**
             * Detaches and removes the entity.
             *
             * @method 'detach'
             */
            "detach": function () {
                this.isAttached = false;
            }
        },

        methods: {
            destroy: function () {
                this.state.set(this.attachState, false);
                if (this.attachment) {
                    this.owner.parent.removeEntity(this.attachment);
                    this.attachment = null;
                }
                this.isAttached = false;
                this.state = null;
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var attachment = def.attachment || props.attachment || defaultProps.attachment;
            
            if (attachment) {
                return Entity.getAssetList({
                    type: attachment
                });
            }
            
            return Array.setUp();
        }
    });
}());

//##############################################################################
// LogicButton.js
//##############################################################################

/**
# COMPONENT **LogicButton**
This component handles the pressed/released state of a button according to input. It can be set as a toggle button or a simple press-and-release button.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its state.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component updates its current state and broadcasts its logical state to the entity.
- **pressed** - on receiving this message, the state of the button is set to "pressed".
- **released** - on receiving this message, the state of the button is set to "released".
- **mousedown** - on receiving this message, the state of the button is set to "pressed". Note that this component will not listen for "mousedown" if the component is in toggle mode.
- **mouseup** - on receiving this message, the state of the button is set to "released" unless in toggle mode, in which case it toggles between "pressed" and "released".

### Local Broadcasts:
- **state-changed** - this component will trigger this message with both "pressed" and "released" properties denoting its state. Both of these work in tandem and never equal each other.
  - @param message.pressed (boolean) - whether the button is in a pressed state.
  - @param message.released (boolean) - whether the button is in a released state.

## JSON Definition:
    {
      "type": "LogicButton",
      
      "toggle": true,
      // Optional. Determines whether this button should behave as a toggle. Defaults to "false".
      
      "state": "pressed"
      // Optional. Specifies starting state of button; typically only useful for toggle buttons. Defaults to "released".
    }
*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'LogicButton',
        constructor: function (definition) {
            this.state = this.owner.state;
            this.toggle = !!definition.toggle;

            if (definition.state === 'pressed') {
                this.state.set('released', false);
                this.state.set('pressed', true);
            } else {
                this.state.set('released', true);
                this.state.set('pressed', false);
            }
        },
        events: {
            "mousedown": function (event) {
                if (!platypus.supports.mobile || (event.event.type === 'touchstart')) {
                    if (!this.toggle) {
                        this.updateState('pressed');
                    }
                }
            },
            "pressup": function (event) {
                if (!platypus.supports.mobile || (event.event.type === 'touchend') || (event.event.type === 'touchcancel')) {
                    if (this.toggle) {
                        if (this.state.get('pressed')) {
                            this.updateState('released');
                        } else {
                            this.updateState('pressed');
                        }
                    } else {
                        this.updateState('released');
                    }
                }
            },
            "handle-logic": function () {
                //TODO: This is only here so that the "state-changed" message is triggered by the Entity for other components needing it.
            }
        },
        
        methods: {
            updateState: function (state) {
                var thisState = this.state;
                
                if (thisState.get('released') && (state === 'pressed')) {
                    thisState.set('pressed', true);
                    thisState.set('released', false);
                } else if (thisState.get('pressed') && (state === 'released')) {
                    thisState.set('pressed', false);
                    thisState.set('released', true);
                }

                this.owner.triggerEvent(state, thisState);
            }
        }
    });
}());

//##############################################################################
// LogicCanvasButton.js
//##############################################################################

/**
 * Provides button functionality for a RenderSprite component.
 *
 * @namespace platypus.components
 * @class LogicCanvasButton
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';
    
    return platypus.createComponentClass({

        id: 'LogicCanvasButton',

        properties: {
            /**
             * The event to trigger when pressed.
             *
             * @property onPress
             * @type String
             * @default ""
             */
            "onPress": "",

            /**
             * The event to trigger when released.
             *
             * @property onRelease
             * @type String
             * @default ""
             */
            "onRelease": "",

            /**
             * The event to trigger when cancelled.
             *
             * @property onCancel
             * @type String
             * @default ""
             */
            "onCancel": "",

            /**
             * The event to trigger when the user mouses over the button
             *
             * @property hoverAudio
             * @type String or an Array of Strings and Message Objects
             * @default ""
             * @since 0.9.0
             */
            "onHover": "",

            /**
             * Whether this button's actions should be limited to the initial press/release.
             *
             * @property useOnce
             * @type Boolean
             * @default false
             */
            "useOnce": false,

            /**
             * Whether this button should start disabled.
             *
             * @property disabled
             * @type Boolean
             * @default false
             */
            "disabled": false
        },

        publicProperties: {
            /**
             * This sets the distance in world units from the bottom of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.bottom`.
             *
             * @property bottom
             * @type Number
             * @default null
             * @since 0.9.0
             */
            "bottom": null,

            /**
             * This sets the distance in world units from the left of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.left`.
             *
             * @property bottom
             * @type Number
             * @default null
             * @since 0.9.0
             */
            "left": null,

            /**
             * This sets the distance in world units from the right of the camera's world viewport. If set, it will override the entity's x coordinate. This property is accessible on the entity as `entity.right`.
             *
             * @property bottom
             * @type Number
             * @default null
             * @since 0.9.0
             */
            "right": null,

            /**
             * This sets the distance in world units from the top of the camera's world viewport. If set, it will override the entity's y coordinate. This property is accessible on the entity as `entity.top`.
             *
             * @property bottom
             * @type Number
             * @default null
             * @since 0.9.0
             */
            "top": null
        },

        constructor: function () {
            var state = this.owner.state;
            
            this.state = state;
            state.set('disabled', this.disabled);
            state.set('down', false);
            state.set('highlighted', false);
            this.owner.buttonMode = !this.disabled;
            this.cancelled = false;
            this.usedPress = false;
            this.usedRelease = false;
            this.last = null;
        },

        events: {
            /**
             * This component listens for camera updates to reposition the entity if its bottom, left, right, or top properties have been set.
             *
             * @method 'camera-update'
             * @param camera {platypus.Data} Camera update information
             * @param camera.viewport {platypus.AABB} The bounding box describing the camera viewport location in the world.
             * @since 0.9.0
             */
            "camera-update": function (camera) {
                var bottom = this.bottom,
                    left = this.left,
                    right = this.right,
                    top = this.top,
                    vp = camera.viewport;

                if (typeof left === 'number') {
                    this.owner.x = vp.left + left;
                } else if (typeof right === 'number') {
                    this.owner.x = vp.right - right;
                }

                if (typeof top === 'number') {
                    this.owner.y = vp.top + top;
                } else if (typeof bottom === 'number') {
                    this.owner.y = vp.bottom - bottom;
                }
            },

            /**
             * Handles `disabled` state changes.
             *
             * @method 'handle-logic'
             */
            "handle-logic": function () {
                var eq = (this.disabled === this.state.get('disabled'));
                
                if (this.last !== eq) {
                    this.last = eq;
                }
            },

            /**
             * Triggers events per the component's definition when a press is made.
             *
             * @method 'mousedown'
             */
            "mousedown": function (eventData) {
                this.state.set('down', true);
                if (!this.state.get('disabled') && !(this.useOnce && this.usedPress)) {
                    if (this.onPress) {
                        this.owner.trigger(this.onPress);
                        this.usedPress = true; //Doing this prevents the Release/Cancel calls from occurring. Need to find a way to let the up and down both call for one use buttons.
                    }
                    eventData.pixiEvent.stopPropagation();
                }
            },

            /**
             * Triggers events per the component's definition when a press is released.
             *
             * @method 'pressup'
             */
            "pressup": function (eventData) {
                if (!this.state.get('disabled') && !(this.useOnce && this.usedRelease)) {
                    if (this.cancelled) {
                        if (this.onCancel) {
                            this.owner.trigger(this.onCancel);
                            this.usedRelease = true;
                        }
                    } else if (this.onRelease) {
                        this.owner.trigger(this.onRelease);
                        this.usedRelease = true;
                    }
                    eventData.pixiEvent.stopPropagation();
                }

                this.state.set('down', false);
                this.cancelled = false;
            },

            /**
             * If a press moves over the button, it's not cancelled.
             *
             * @method 'mouseover'
             */
            "mouseover": function () {
                if (this.onHover) {
                    this.owner.trigger(this.onHover);
                }
                if (this.state.get('down')) {
                    this.cancelled = false;
                }
            },

            /**
             * If a press moves off of the button, it's cancelled.
             *
             * @method 'mouseout'
             */
            "mouseout": function () {
                if (this.state.get('down')) {
                    this.cancelled = true;
                }
            },
            
            /**
             * Disables the entity.
             *
             * @method 'disable'
             */
            "disable": function () {
                this.state.set('disabled', true);
                this.owner.buttonMode = false;
            },
            
            /**
             * Enables the entity.
             *
             * @method 'enable'
             */
            "enable": function () {
                this.state.set('disabled', false);
                this.owner.buttonMode = true;
            },

            /**
             * Toggles whether the entity is disabled.
             *
             * @method 'toggle-disabled'
             */
            "toggle-disabled": function () {
                var value = this.state.get('disabled');
                
                this.owner.buttonMode = value;
                this.state.set('disabled', !value);
            },
            
            /**
             * Sets the entity's highlighted state to `true`.
             *
             * @method 'highlight'
             * @since 0.8.6
             */
            "highlight": function () {
                this.state.set('highlighted', true);
            },
            
            /**
             * Sets the entity's highlighted state to `false`.
             *
             * @method 'unhighlight'
             * @since 0.8.6
             */
            "unhighlight": function () {
                this.state.set('highlighted', false);
            },
            
            /**
             * Toggles the entity's highlighted state.
             *
             * @method 'toggle-highlight'
             * @since 0.8.6
             */
            "toggle-highlight": function () {
                this.state.set('highlighted', !this.state.get('highlighted'));
            }
        },
        
        methods: {
            destroy: function () {
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// LogicCarrier.js
//##############################################################################

/**
# COMPONENT **LogicCarrier**
This component allows this entity carry other entities with which it collides. Entities that this component should carry need to have a [[Logic-Portable]] component attached to notify this entity that they are portable.

## Dependencies:
- [[Collision-Group]] - This component will attach a [[Collision-Group]] to this entity if it does not already have this component. `LogicCarrier` uses a collision group to resolve its portable peers' collisions with itself before other world collisions are handled.
- [[Logic-Portable]] (on portable peer entity) - This component listens for 'carry-me' and 'release-me', commonly triggered by [[Logic-Portable]] on a colliding peer entity.

## Messages

### Listens for:
- **load** - On receiving this message, the component ensures that it has a peer collision group component, and adds one if not.
- **carry-me** - On receiving this message, the component triggers `add-collision-entity` on the entity to add the peer entity to its collision group.
  - @param message.entity ([[Entity]]) - Required. The peer entity requesting to be carried.
- **release-me** - On receiving this message, the component triggers `remove-collision-entity` on the entity to remove the peer entity from its collision group.
  - @param message.entity ([[Entity]]) - Required. The peer entity requesting to be released.

### Local Broadcasts
- **add-collision-entity** - On receiving a `carry-me` message, this component triggers this message to add the portable peer to the collision group.
  - @param message ([[Entity]]) - The entity being added to the collision group.
- **remove-collision-entity** - On receiving a `release-me` message, this component triggers this message to remove the portable peer to the collision group.
  - @param message ([[Entity]]) - The entity being removed from the collision group.

## JSON Definition:
    {
      "type": "LogicCarrier"
      // This component has no customizable properties.
    }
    
Requires: ["CollisionGroup"]
*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'LogicCarrier',
        constructor: function () {},
        events: {
            "load": function () {
                if (!this.owner.triggerEvent('add-collision-entity', this.owner)) {
                    // This message wasn't handled, so add a CollisionGroup component and try again!
                    this.owner.addComponent(new platypus.components.CollisionGroup(this.owner, {}));
                    this.owner.triggerEvent('add-collision-entity', this.owner);
                }
            },
            "carry-me": function (resp) {
                this.owner.triggerEvent('add-collision-entity', resp.entity);
            },
            "release-me": function (resp) {
                this.owner.triggerEvent('remove-collision-entity', resp.entity);
            }
        }
    });
}());

//##############################################################################
// LogicDelayMessage.js
//##############################################################################

/**
# COMPONENT **LogicDelayMessage**
This component allows certain messages to trigger new messages at a later time. This is useful for any sort of delayed reaction to events.

## Dependencies
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component checks the running counts on its delayed messages to determine whether to trigger any.
  - @param message.delta - To determine whether to trigger messages, the component keeps a running count of tick lengths.
- **[input messages]** - This component listens for messages as determined by the JSON settings.

### Local Broadcasts:
- **[output messages]** - This component triggers output messages as determined by the JSON settings.

## JSON Definition
    {
      "type": "LogicDelayMessage",
      
      "events": {
      // Required: This is a list of event objects that should be listened for, and the messages that they should trigger at some time in the future.
      
        "saw-clown": {
        // This component will use the following to determine when and what to send on hearing the "saw-clown" event.
        
          "event": "laugh",
          // This component will trigger "laugh"
          
          "message": {"feeling": "happy", "sincerity": "85%"}
          // This can be a value or object to pass as the message content with the "laugh" event.
          
          "delay": 1500,
          // This is the delay in milliseconds before which the new message should be triggered.
          
          "singleInstance": true,
          // This determines whether more "saw-clown" events triggered during the delayed response period should be treated as new messages to be triggered or whether the initial instance prevents additional instances from occurring.
          
          "repeat": true,
          // This sets whether the event should continue to trigger every "delay" amount of time until "cancelEvent" is called. Defaults to `false`.
          
          "cancelEvent": "dropped-popcorn"
          // If set, on receiving this event, the component will not trigger the "laugh" event after all if it's currently planning to.
        },
        
        // Multiple delay messages can be set up on this component.
        "move-right":{
          "event": "look-left",
          "delay": 7000
        }
      
      }
    }
    
    NOTE: Deprecated as of 0.8.7 in favor of the new Timeline Component
*/
/* global platypus */
(function () {
    'use strict';

    var createMessage = function (event) {
            var includeMessage = function (event, message) {
                if (message && !event.message) {
                    return {
                        event: event.event,
                        message: message,
                        delay: event.delay,
                        repeat: event.repeat
                    };
                } else {
                    return event;
                }
            };
            if (event.singleInstance) {
                return function (message) {
                    var i = 0,
                        add = true;

                    for (i = 0; i < this.queue.length; i++) {
                        if (this.queue[i].event === event.event) {
                            add = false;
                        }
                    }

                    if (add) {
                        this.queue.push(includeMessage(event, message));
                        this.queueTimes.push(event.delay);
                    }
                };
            } else {
                return function (message) {
                    this.queue.push(includeMessage(event, message));
                    this.queueTimes.push(event.delay);
                };
            }
        },
        createCancellation = function (cancelEvent) {
            return function () {
                var i = 0;

                for (i = this.queue.length - 1; i > -1; i--) {
                    if (this.queue[i] === cancelEvent) {
                        this.queueTimes.greenSplice(i);
                        this.queue.greenSplice(i);
                    }
                }
            };
        };

    return platypus.createComponentClass({
        id: 'LogicDelayMessage',
        
        constructor: function (definition) {
            var event = '';
            
            this.queueTimes = Array.setUp();
            this.queue = Array.setUp();
            
            if (definition.events) {
                for (event in definition.events) {
                    if (definition.events.hasOwnProperty(event)) {
                        this.addEventListener(event, createMessage(definition.events[event]));

                        if (definition.events[event].cancelEvent) {
                            this.addEventListener(definition.events[event].cancelEvent, createCancellation(definition.events[event]));
                        }
                    }
                }
            }
        },

        events: {// These are messages that this component listens for
            "handle-logic": function (resp) {
                var i = this.queue.length;
                
                while (i--) {
                    this.queueTimes[i] -= resp.delta;
                    
                    if (this.queueTimes[i] <= 0) {
                        this.owner.trigger(this.queue[i].event, this.queue[i].message);
                        
                        if (this.queue[i]) { // Have to check this in case the delayed event matches the cancellation event which would cause this queued message to already be removed.
                            if (this.queue[i].repeat) {
                                this.queueTimes[i] += this.queue[i].delay;
                            } else {
                                this.queueTimes.greenSplice(i);
                                this.queue.greenSplice(i);
                            }
                        }
                    }
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.queueTimes.recycle();
                this.queue.recycle();
            }
        }
    });
}());

//##############################################################################
// LogicDestroyMe.js
//##############################################################################

/**
 * This component allows an entity to be removed from the stage when "destroy-me" is triggered.
 *
 * @namespace platypus.components
 * @class LogicDestroyMe
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';
    
    return platypus.createComponentClass({
        id: 'LogicDestroyMe',
        
        properties: {
            /**
             * Time in milliseconds after the "destroy-me" message is heard before entity should be removed.
             *
             * @property delay
             * @type number
             * @default 0
             */
            delay: 0,

            /**
             * Whether this entity has been destroyed. Typically `false` until a "destroy-me" event has been triggered.
             *
             * @property destroyed
             * @type boolean
             * @default false
             */
            destroyed: false
        },
        
        events: {// These are messages that this component listens for

            /**
             * On a `tick` logic message, the component checks whether it should be removed or not.
             *
             * @method 'prepare-logic'
             * @param message.delta {number} To measure the delay before removal, the component keeps a running count of step lengths.
             */
            "prepare-logic": function (tick) {
                var dT = tick.delta;
                
                if (this.destroyed && !this.owner.state.get('paused')) {
                    this.delay -= dT;
                    if (this.delay <= 0) {
                        this.owner.parent.removeEntity(this.owner);
                    }
                }
            },
            
            /**
             * This component will set the entity up for removal on receiving this message.
             *
             * @method 'destroy-me'
             */
            "destroy-me": function () {
                this.destroyed = true;
            }
                   
        }
    });
}());

//##############################################################################
// LogicDirectionalMovement.js
//##############################################################################

/**
 * This component changes the [Motion](platypus.components.Motion.html) of an entity according to its current speed and heading. It accepts directional messages that can stand alone, or come from a mapped controller, in which case it checks the `pressed` value of the message before changing its course.
 *
 * @namespace platypus.components
 * @class LogicDirectionalMovement
 * @uses platypus.Component
 */
/* global platypus */
(function () {
    'use strict';
    
    var processDirection = function (direction) {
            return function (state) {
                this[direction] = !state || (state.pressed !== false);
            };
        },
        doNothing = function () {},
        rotate = {
            x: function (heading, lastHeading) {
                if (heading !== lastHeading) {
                    if (((heading > 180) && (lastHeading <= 180)) || ((heading <= 180) && (lastHeading > 180))) {
                        this.owner.triggerEvent('transform', 'vertical');
                    }
                }
            },
            y: function (heading, lastHeading) {
                if (heading !== lastHeading) {
                    if (((heading > 90 && heading <= 270) && (lastHeading <= 90 || lastHeading > 270)) || ((heading <= 90 || heading > 270) && (lastHeading > 90 && lastHeading <= 270))) {
                        this.owner.triggerEvent('transform', 'horizontal');
                    }
                }
            },
            z: function (heading, lastHeading) {
                if (heading !== lastHeading) {
                    this.owner.triggerEvent('replace-transform', 'rotate-' + heading);
                }
            }
        };
    
    return platypus.createComponentClass({
        id: 'LogicDirectionalMovement',
        
        properties: {
            /**
             * Defines the axis around which the entity should be transformed. Defaults to "y" for platforming behavior. Use "z" for top-down behavior.
             *
             * @property axis
             * @type String
             * @default "y"
             */
            axis: 'y',

            /**
             * Defines the distance in world units that the entity should be moved per millisecond.
             *
             * @property speed
             * @type Number
             * @default 0.3
             */
            speed: 0.3
        },
        
        constructor: function () {
            var state = this.state = this.owner.state;
            
            if (typeof this.speed === 'number') {
                this.speed = [this.speed, 0, 0];
            }
            this.initialVector = platypus.Vector.setUp(this.speed);
            this.reorient = rotate[this.axis];
            if (!this.reorient) {
                this.reorient = doNothing;
            }
            
            this.moving = state.set('moving', false);
            this.left   = state.set('left', false);
            this.right  = state.set('right', false);
            this.up     = state.set('up', false);
            this.down   = state.set('down', false);

            this.upLeft = false;
            this.upRight = false;
            this.downLeft = false;
            this.downRight = false;
            
            this.heading = 0;
            this.owner.heading = this.owner.heading || 0;
        },
        events: {
            /**
             * This method checks to make sure there is a `Mover` component attached and sets up initial heading.
             *
             * @method 'component-added'
             */
            "component-added": function (component) {
                if (component === this) {
                    if (!this.owner.addMover) {
                        platypus.debug.warn('The "LogicDirectionalMovement" component requires a "Mover" component to function correctly.');
                        return;
                    }

                    this.direction = this.owner.addMover({
                        velocity: this.speed,
                        drag: 0,
                        friction: 0,
                        stopOnCollision: false,
                        orient: false,
                        aliases: {
                            "moving": "control-velocity"
                        }
                    }).velocity;
                    
                    if (this.owner.heading !== this.heading) {
                        this.direction.setVector(this.initialVector).rotate((this.owner.heading / 180) * Math.PI);
                        this.heading = this.owner.heading;
                    }
                    
                    this.owner.triggerEvent('moving', this.moving);
                }
            },
            
            /**
             * On receiving this message, the component updates its direction of motion according to its current state.
             *
             * @method 'handle-logic'
             */
            "handle-logic": function () {
                var state = this.state,
                    up        = this.up        || this.upLeft || this.downLeft,
                    upLeft    = this.upLeft    || (this.up   && this.left),
                    left      = this.left      || this.upLeft || this.downLeft,
                    downLeft  = this.downLeft  || (this.down && this.left),
                    down      = this.down      || this.downLeft || this.downRight,
                    downRight = this.downRight || (this.down && this.right),
                    right     = this.right     || this.upRight || this.downRight,
                    upRight   = this.upRight   || (this.up   && this.right);
                
                if ((left && right) || (up && down)) {
                    this.moving = false;
                } else if (upLeft) {
                    this.moving = true;
                    this.heading = 225;
                } else if (upRight) {
                    this.moving = true;
                    this.heading = 315;
                } else if (downLeft) {
                    this.moving = true;
                    this.heading = 135;
                } else if (downRight) {
                    this.moving = true;
                    this.heading = 45;
                } else if (left) {
                    this.moving = true;
                    this.heading = 180;
                } else if (right) {
                    this.moving = true;
                    this.heading = 0;
                } else if (up) {
                    this.moving = true;
                    this.heading = 270;
                } else if (down) {
                    this.moving = true;
                    this.heading = 90;
                } else {
                    this.moving = false;
                    
                    // This is to retain the entity's direction even if there is no movement. There's probably a better way to do this since this is a bit of a retrofit. - DDD
                    switch (this.heading) {
                    case 270:
                        up = true;
                        break;
                    case 90:
                        down = true;
                        break;
                    case 180:
                        left = true;
                        break;
                    case 225:
                        up = true;
                        left = true;
                        break;
                    case 315:
                        up = true;
                        right = true;
                        break;
                    case 135:
                        down = true;
                        left = true;
                        break;
                    case 45:
                        down = true;
                        right = true;
                        break;
                    case 0:
                    default:
                        right = true;
                        break;
                    }
                }
                
                if (this.owner.heading !== this.heading) {
                    this.direction.setVector(this.initialVector).rotate((this.heading / 180) * Math.PI);
                    this.reorient(this.heading, this.owner.heading);
                    this.owner.heading = this.heading;
                }
                
                //TODO: possibly remove the separation of this.state.direction and this.direction to just use state?
                if (state.get('moving') !== this.moving) {
                    this.owner.triggerEvent('moving', this.moving);
                    state.set('moving', this.moving);
                }

                state.set('up', up);
                state.set('right', right);
                state.set('down', down);
                state.set('left', left);
            },

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-down'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-down": processDirection('down'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-south'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-south": processDirection('down'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-down-left'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-down-left": processDirection('downLeft'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-southwest'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-southwest": processDirection('downLeft'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-left'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-left": processDirection('left'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-west'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-west": processDirection('left'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-up-left'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-up-left": processDirection('upLeft'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-northwest'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-northwest": processDirection('upLeft'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-up'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-up": processDirection('up'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-north'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-north": processDirection('up'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-up-right'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-up-right": processDirection('upRight'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-northeast'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-northeast": processDirection('upRight'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-right'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-right": processDirection('right'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-east'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-east": processDirection('right'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-down-right'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-down-right": processDirection('downRight'),

            /**
             * On receiving this message, this component updates its heading accordingly.
             *
             * @method 'go-southeast'
             * @param [message.pressed] {Boolean} If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new heading. This allows triggering `up` and `left` in sequence to cause `up-left` movement on the entity.
             */
            "go-southeast": processDirection('downRight'),
            
            /**
             * Stops motion in all directions until movement messages are again received.
             *
             * @method 'stop'
             * @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: a value of false will not stop the entity.
             */
            "stop": function (state) {
                if (!state || (state.pressed !== false)) {
                    this.left = false;
                    this.right = false;
                    this.up = false;
                    this.down = false;
                    this.upLeft = false;
                    this.upRight = false;
                    this.downLeft = false;
                    this.downRight = false;
                }
            },
            
            /**
             * Set the direction the entity should face while stopped.
             *
             * @method 'face'
             * @param direction {String} A value such as "north" or "left" to point the entity in a particular direction.
             */
            "face": (function () {
                var headings = {
                    up: 270,
                    north: 270,
                    down: 90,
                    south: 90,
                    left: 180,
                    west: 180,
                    right: 0,
                    east: 0,
                    "up-left": 225,
                    northwest: 225,
                    "up-right": 315,
                    northeast: 315,
                    "down-left": 135,
                    southwest: 135,
                    "down-right": 45,
                    southeast: 45
                };
                
                return function (direction) {
                    this.heading = headings[direction] || 0;
                };
            }()),
            
            /**
             * Changes the velocity of the Entity when in motion.
             *
             * @method 'accelerate'
             * @param velocity {Number|platypus.Vector} The magnitude or Vector to multiply the current velocity by.
             */
            "accelerate": function (velocity) {
                this.initialVector.normalize().multiply(velocity);
                this.direction.normalize().multiply(velocity);
            }
        },
        
        methods: {
            destroy: function () {
                this.initialVector.recycle();
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// LogicDragDrop.js
//##############################################################################

/**
# COMPONENT **LogicDragDrop**
A component that allows an object to be dragged and dropped. Can use collision to prevent dropping the objects in certain locations.
NOTE: HandlerRender and the RenderSprite used by this entity need to have their 'touch' or 'click' inputs set to true.

## Dependencies
- [[HandlerLogic]] - Listens for the handle-logic and handle-post-collision-logic calls.
- [[RenderSprite]] - Listens for 'mouseup', 'mousedown', and 'pressmove' calls.

## Messages

### Listens for:
- **handle-logic** - Updates the object's location on the handle-logic tick.
  - @param resp (object) - The tick coming from the scene.
- **handle-post-collision-logic** - Resolves whether the object state after we check if there are any collisions. If the object was dropped and can be dropped, it is.
  - @param resp (object) - The tick coming from the scene.
- **mousedown** - The mousedown event passed from the render component. Fired when we're grabbing the object. Starts the drag.
  - @param eventData (object) - The event data.
- **mouseup** - The mouseup event passed from the render component. Fired when we're trying to drop the object.
  - @param eventData (object) - The event data.
- **pressmove** - The pressmove event passed from the render component. Tells us when we're dragging the object.
  - @param eventData (object) - The event data.
- **no-drop** - The message passed from the collision system letting us know the object is currently in a location that it cannot be dropped.
  - @param collisionData (object) - The event data.
  
## JSON Definition
    {
        "type": "LogicDragDrop"
    }
*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'LogicDragDrop',
        
        properties: {
            /**
             * Sets the z-order of the item while being dragged.
             *
             * @property dragZ
             * @type Number
             * @default 10000
             * @since 0.8.3
             */
            dragZ: 10000,
            
            /**
             * Sets whether a click-move should start the dragging behavior in addition to click-drag. This value is ignored for mobile devices.
             *
             * @property stickyClick
             * @type Boolean
             * @default false
             * @since 0.8.3
             */
            stickyClick: false
        },
        
        constructor: function () {
            this.nextX = this.owner.x;
            this.nextY = this.owner.y;
            this.lastZ = this.owner.z;
            this.grabOffsetX = 0;
            this.grabOffsetY = 0;
            this.state = this.owner.state;
            this.state.set('dragging', false);
            this.state.set('noDrop', false);
            this.tryDrop = false;
            this.hitSomething = false;
            this.hasCollision = false;
            
            if (platypus.supports.mobile) {
                this.stickyClick = false;
            }
        },

        events: {// These are messages that this component listens for
            "component-added": function (component) {
                if (component.type === 'CollisionBasic') {
                    this.hasCollision = true;
                }
            },
            
            "handle-logic": function () {
                if (this.state.get('dragging')) {
                    this.owner.x = this.nextX;
                    this.owner.y = this.nextY;
                    this.owner.triggerEvent('hovering');
                }
                
                this.state.set('noDrop', false);
            },

            "handle-post-collision-logic": function () {
                if (this.tryDrop) {
                    this.tryDrop = false;
                    if (this.hitSomething) {
                        this.dropFailed = false;
                        this.state.set('noDrop', true);
                        this.state.set('dragging', true);
                        this.owner.dragMode = true;
                    } else {
                        this.state.set('noDrop', false);
                        this.state.set('dragging', false);
                        this.owner.dragMode = false;
                    }
                } else if (this.hitSomething) {
                    this.state.set('noDrop', true);
                }
                this.hitSomething = false;
            },
            "mousedown": function (eventData) {
                if (this.sticking) {
                    this.sticking = false;
                    this.release();
                } else {
                    this.nextX = this.owner.x;
                    this.nextY = this.owner.y;
                    this.lastZ = this.owner.z;
                    this.grabOffsetX = eventData.x - this.owner.x;
                    this.grabOffsetY = eventData.y - this.owner.y;
                    this.owner.z = this.dragZ;
                    this.state.set('dragging', true);
                    this.owner.dragMode = true;
                    this.sticking = this.stickyClick;
                }
                
                eventData.pixiEvent.stopPropagation();
            },
            "pressup": function (eventData) {
                if (!this.sticking) {
                    this.release();
                }
                
                eventData.pixiEvent.stopPropagation();
            },
            "mousemove": function (eventData) {
                if (this.sticking) {
                    this.nextX = eventData.x - this.grabOffsetX;
                    this.nextY = eventData.y - this.grabOffsetY;
                    
                    eventData.event.preventDefault();
                    eventData.pixiEvent.stopPropagation();
                }
            },
            "pressmove": function (eventData) {
                this.nextX = eventData.x - this.grabOffsetX;
                this.nextY = eventData.y - this.grabOffsetY;
                if (this.nextX !== this.owner.x || this.nextY !== this.owner.y) {
                    this.sticking = false;
                }
                
                eventData.event.preventDefault();
                eventData.pixiEvent.stopPropagation();
            },
            "no-drop": function () {
                this.hitSomething = true;
            }
        },
        
        methods: {// These are methods that are called by this component.
            release: function () {
                if (this.hasCollision) {
                    this.tryDrop = true;
                } else {
                    this.state.set('noDrop', false);
                    this.state.set('dragging', false);
                    this.owner.dragMode = false;
                    this.owner.z = this.lastZ;
                }
            },
            
            destroy: function () {
                this.state.set('dragging', false);
                this.owner.dragMode = false;
                this.state.set('noDrop', false);
                this.state = null;
                this.owner.z = this.lastZ;
            }
        }
    });
}());

//##############################################################################
// LogicImpactLaunch.js
//##############################################################################

/**
# COMPONENT **LogicImpactLaunch**
This component will cause the entity to move in a certain direction on colliding with another entity.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.
- **impact-launch** - On receiving this message, the component causes the entity's position to change according to the preset behavior.
  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.
  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.
- **hit-solid** - On receiving this message, the component discontinues its impact-launch behavior.
  - @param collisionInfo.y (number) - Either 1,0, or -1. If colliding below, impact-launch behavior ceases.

## JSON Definition:
    {
      "type": "LogicImpactLaunch",
      
      "state": "launching",
      // Optional: This sets the state of the entity while it's being launched. Defaults to "stunned".
      
      "accelerationX": 5,
      "accelerationY": 5,
      // Optional: acceleration entity should have in world units while being launched. Defaults to -0.2 for x and -0.6 for y.
      
      "flipX": true,
      "flipY": true
      // Optional: whether the directions of acceleration should flip according to the direction of the collision. Defaults to false for y and true for x.
    }

*/
/* global include, platypus */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector');

    return platypus.createComponentClass({
        id: 'LogicImpactLaunch',
        
        properties: {
            accelerationX: -0.3,
            accelerationY: -0.8,
            flipX: true,
            flipY: false
        },
        
        constructor: function (definition) {
            this.stunState = definition.state || "stunned";
            
            this.flipX = this.flipX ? -1 : 1;
            this.flipY = this.flipY ? -1 : 1;

            this.justJumped = false;
            this.stunned = false;
            
            this.state = this.owner.state;
            this.state.set('impact', false);
            this.state.set(this.stunState, false);
        },
        
        events: {
            "component-added": function (component) {
                if (component === this) {
                    if (!this.owner.addMover) {
                        platypus.debug.warn('The "LogicDirectionalMovement" component requires a "Mover" component to function correctly.');
                        return;
                    }

                    this.direction = this.owner.addMover({
                        velocity: [0, 0, 0],
                        orient: false
                    }).velocity;
                    this.vector = Vector.setUp();
                }
            },

            "handle-logic": function () {
                this.state.set('impact', this.justJumped);
                this.state.set(this.stunState, this.stunned);

                if (this.justJumped) {
                    this.direction.setVector(this.vector);
                    this.justJumped = false;
                    this.stunned = true;
                }
            },
            
            "impact-launch": function (collisionInfo) {
                var dx = collisionInfo.x,
                    dy = collisionInfo.y;
                
                if (collisionInfo.entity) {
                    dx = collisionInfo.entity.x - this.owner.x;
                    dy = collisionInfo.entity.y - this.owner.y;
                }

                if (!this.stunned) {
                    this.justJumped = true;
                    if (dx >= 0) {
                        this.vector.x = this.accelerationX;
                    } else if (dx < 0) {
                        this.vector.x = this.accelerationX * this.flipX;
                    }
                    if (dy >= 0) {
                        this.vector.y = this.accelerationY;
                    } else if (dy < 0) {
                        this.vector.y = this.accelerationY * this.flipY;
                    }
                }
            },
            
            "hit-solid": function (collisionInfo) {
                if (this.stunned && (collisionInfo.y > 0)) {
                    this.direction.x = 0;
                    this.direction.y = 0;
                    this.stunned = false;
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.vector.recycle();
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// LogicPacingPlatform.js
//##############################################################################

/**
# COMPONENT **LogicPacingPlatform**
This component changes the (x, y) position of an object according to its speed and heading and alternates back and forth. This is useful for in-place moving platforms.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.
  - @param message.delta - To determine how far to move the entity, the component checks the length of the tick.

## JSON Definition:
    {
      "type": "LogicDirectionalMovement",
      
      "angle": 3.14,
      // Optional. Defines the angle of movement in radians. Defaults to 0 (horizontal, starts moving right).
      
      "distance": 440,
      // Optional. Declares distance in world units that the entity should move back and forth across. Defaults to 128.
      
      "period": 6000,
      // Optional. Sets the time in milliseconds that the entity should take to make a complete movement cycle. Defaults to 4 seconds (4000).
      
      "startPos": 0
      // Optional. Position in the cycle that the movement should begin. Defaults in the middle at 0; PI/2 and -PI/2 will put you at the extremes.
    }
*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        
        id: 'LogicPacingPlatform',
        
        constructor: function (definition) {
            this.ang      = this.owner.angle      || definition.angle     || 0; //PI/2 makes it go down first
            this.dist     = this.owner.distance || definition.distance || 128; //Distance in pixels
            this.dX       = this.dist * Math.cos(this.ang);
            this.dY       = this.dist * Math.sin(this.ang);
            this.period   = this.owner.period    || definition.period     || 4000;
            this.time     = 0;
            this.startPos = this.owner.startPos || definition.startPos || 0; //PI/2 and -PI/2 will put you at the extremes
            this.offset   = 0;
            this.originX  = this.owner.x;
            this.originY  = this.owner.y;
        },

        events: {// These are messages that this component listens for
            "handle-logic": function (update) {
                var period = this.period,
                    delta = update.delta;
                
                this.time += delta;
                if (this.time > period) {
                    this.time = this.time % period;
                }
                this.offset = (this.time / period) * (2 * Math.PI);
                
                this.owner.x = this.originX + Math.sin(this.offset + this.startPos) * this.dX;
                this.owner.y = this.originY + Math.sin(this.offset + this.startPos) * this.dY;
            }
        }
    });
}());

//##############################################################################
// LogicPortable.js
//##############################################################################

/**
# COMPONENT **LogicPortable**
This component allows this entity to be carried by other entities with which it collides. Entities that should carry this entity need to have a [[Logic-Carrier]] component attached.

## Dependencies:
- [[HandlerLogic]] (on parent entity) - This component listens for 'handle-logic' messages to determine whether it should be carried or released each game step.
- [[LogicCarrier]] (on peer entity) - This component triggers 'carry-me' and 'release-me' message, listened for by [[Logic-Carrier]] to handle carrying this entity.

## Messages

### Listens for:
- **handle-logic** - On receiving this message, this component triggers 'carry-me' or 'release-me' if its connection to a carrying entity has changed.
- **hit-solid** - On receiving this message, this component determines whether it is hitting its carrier or another entity. If it is hitting a new carrier, it will broadcast 'carry-me' on the next game step.
  - @param message.entity ([[Entity]]) - The entity with which the collision occurred.
  - @param message.x (number) - -1, 0, or 1 indicating on which side of this entity the collision occurred: left, neither, or right respectively.
  - @param message.y (number) - -1, 0, or 1 indicating on which side of this entity the collision occurred: top, neither, or bottom respectively.

### Peer Broadcasts
- **carry-me** - This message is triggered on a potential carrying peer, notifying the peer that this entity is portable.
  - @param message.entity ([[Entity]]) - This entity, requesting to be carried.
- **release-me** - This message is triggered on the current carrier, notifying them to release this entity.
  - @param message.entity ([[Entity]]) - This entity, requesting to be released.

## JSON Definition:
    {
      "type": "LogicPortable",

      "portableDirections": {down: true}
      // This is an object specifying the directions that this portable entity can be carried on. Default is {down:true}, but "up", "down", "left", and/or "right" can be specified as object properties set to `true`.
    }
*/
/* global platypus */
(function () {
    'use strict';
    
    var
        defaultOrientation = {
            down: true //default is false, 'true' means as soon as carrier is connected downward
        };

    return platypus.createComponentClass({
        id: 'LogicPortable',
        constructor: function (definition) {
            this.portableDirections = definition.portableDirections || defaultOrientation;
    
            this.carrier      = this.lastCarrier = null;
            this.message      = {
                entity: this.owner
            };
        },
        events: {
            "handle-logic": function () {
                var msg = this.message;
                
                if (this.carrierConnected) {
                    if (this.carrier !== this.lastCarrier) {
                        if (this.lastCarrier) {
                            this.lastCarrier.triggerEvent('release-me', msg);
                        }
                        this.carrier.triggerEvent('carry-me', msg);
                    }
                    
                    this.carrierConnected = false;
                } else if (this.carrier) {
                    this.carrier.triggerEvent('release-me', msg);
                    this.carrier = null;
                }
                this.lastCarrier = this.carrier;
            },
            "hit-solid": function (collisionInfo) {
                if (collisionInfo.y > 0) {
                    this.updateCarrier(collisionInfo.entity, 'down');
                } else if (collisionInfo.y < 0) {
                    this.updateCarrier(collisionInfo.entity, 'up');
                } else if (collisionInfo.x < 0) {
                    this.updateCarrier(collisionInfo.entity, 'left');
                } else if (collisionInfo.x > 0) {
                    this.updateCarrier(collisionInfo.entity, 'right');
                }
            }
        },
        methods: {
            updateCarrier: function (entity, direction) {
                if (this.portableDirections[direction]) {
                    if (entity) {
                        if (entity !== this.carrier) {
                            this.carrier = entity;
                        }
                        this.carrierConnected = true;
                    }
                }
            }
        }
    });
}());

//##############################################################################
// LogicPortal.js
//##############################################################################

/**
# COMPONENT **LogicPortal**
A component which changes the scene when activated. When the portal receives an occupied message it sends the entity in that message notifying it. This message is meant to give the entity a chance to activate the portal in the manner it wants. The portal can also be activated by simply telling it to activate.

## Dependencies
- [[HandlerLogic]] (on entity's parent) - This component listens for a "handle-logic" message it then checks to see if it should change the scene if the portal is activated.
- [[SceneChanger]] (on entity) - This component listens for the "new-scene" message that the LogicPortal sends and actually handles the scene changing.
- [[CollisionBasic]] (on entity) - Not required, but if we want the 'occupied-portal' call to fire on collision you'll need to have a CollisionBasic component on the portal.

## Messages

### Listens for:
- **handle-logic** - Checks to see if we should change scene if the portal is activated.
- **occupied-portal** - This message takes an entity and then sends the entity a 'portal-waiting' message. The idea behind this was that you could use it with collision. When an entity gets in front of the portal the collision sends this message, we then tell the entity that collided to do whatever it needs and then it calls back to activate the portal.
  - @param message.entity (entity Object) - The entity that will receive the 'portal-waiting' message.
- **activate-portal** - This message turns the portal on. The next 'handle-logic' call will cause a change of scene.

### Local Broadcasts:
- **new-scene** - Calls the 'SceneChanger' component to tell it to change scenes.
  - @param object.destination (string) - The id of the scene that we want to go to.

### Peer Broadcasts:
- **portal-waiting** - Informs another object that the portal is waiting on it to send the activate message.
  - @param entity - This is the portal entity. To be used so that the object can communicate with it directly.

## JSON Definition
    {
      "type": "name-of-component",
      "destination" : "level-2"
      //Required - The destination scene to which the portal will take us. In most cases this will come into the portal from Tiled where you'll set a property on the portal you place.
    }
*/
/* global include, platypus */
(function () {
    'use strict';
    
    var DataMap = include('platypus.DataMap');

    return platypus.createComponentClass({
        id: 'LogicPortal',
        constructor: function (definition) {
            var i = 0,
                entrants = definition.entrants || definition.entrant || 'no one',
                state = this.owner.state;
             
            this.destination = this.owner.destination || definition.destination;
            this.used = false;
            this.ready = false;
            this.wasReady = false;

            this.entrants = DataMap.setUp();
            if (Array.isArray(entrants)) {
                for (i = 0; i < entrants.length; i++) {
                    this.entrants.set(entrants[i], false);
                }
            } else {
                this.entrants.set(entrants, false);
            }
            
            this.state = state;

            state.set('occupied', false);
            state.set('ready', true);
        },
        events: {
            "handle-logic": function () {
                var entrants = this.entrants,
                    keys = entrants.keys,
                    i = keys.length,
                    occupied = false,
                    ready = true,
                    state = this.state;
                
                if (!this.used && this.activated) {
                    this.owner.triggerEvent("port-" + this.destination);
                    this.used = true;
                } else if (this.ready && !this.wasReady) {
                    this.owner.triggerEvent('portal-waiting');
                    this.wasReady = true;
                } else if (this.wasReady && !this.ready) {
                    this.owner.triggerEvent('portal-not-waiting');
                    this.wasReady = false;
                }
                
                
                //Reset portal for next collision run.
                while (i--) {
                    if (entrants[keys[i]]) {
                        occupied = true;
                        entrants.set(keys[i], false);
                    } else {
                        ready = false;
                    }
                }
                state.set('occupied', occupied);
                state.set('ready', ready);
                this.ready = false;
            },
            "occupied-portal": function (collision) {
                var entrants = this.entrants,
                    keys = entrants.keys,
                    i = keys.length;
                
                entrants.set(collision.entity.type, true);
                
                while (i--) {
                    if (!entrants.get(keys[i])) {
                        return;
                    }
                }
                
                this.ready = true;
            },
            "activate-portal": function () {
                this.activated = true;
            }
        },
        methods: {
            destroy: function () {
                this.state = null;
                this.entrants.recycle();
                this.entrants = null;
            }
        }
    });
}());

//##############################################################################
// LogicPushable.js
//##############################################################################

/**
# COMPONENT **LogicPushable**
A component that enables an entity to be pushed.

## Dependencies
- [[HandlerLogic]] (on entity's parent) - This component listens for a "handle-logic" message. It then moves the entity if it's being pushed.
- [[CollisionBasic]] (on entity) - This component listens for messages from the CollisionBasic component. In particular 'hit-solid' and 'push-entity' are coming from collision.

## Messages

### Listens for:
- **handle-logic** - Checks to see if we're being pushed. If so, we get pushed. Then resets values.
  - @param resp.delta (number) - The time since the last tick.
- **push-entity** - Received when we collide with an object that can push us. We resolve which side we're colliding on and set up the currentPushX and currentPushY values so we'll move on the handle-logic call.
  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.
  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.
- **hit-solid** - Called when the entity collides with a solid object. Stops the object from being pushed further in that direction.
  - @param collisionInfo.x (number) - Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.
  - @param collisionInfo.y (number) - Either 1,0, or -1. 1 if we're colliding with an object on our bottom. -1 if on our top. 0 if not at all.

## JSON Definition
    {
      "type": "LogicPushable",
       "xPush" : .01,
      //Optional - The distance per millisecond this object can be pushed in x. Defaults to .01.
      "yPush" : .01,
      //Optional - The distance per millisecond this object can be pushed in y. Defaults to .01.
      "push" : .01
      //Optional - The distance per millisecond this object can be pushed in x and y. Overwritten by the more specific values xPush and yPush. Defaults to .01.
    }
*/

/* global platypus */
(function () {
    'use strict';

    var setMagnitude = function (direction, magnitude) {
        return (direction / Math.abs(direction)) * magnitude;
    };
    
    return platypus.createComponentClass({
        id: 'LogicPushable',
        constructor: function (definition) {
            this.yPush = definition.push || definition.yPush || 0;
            this.xPush = definition.push || definition.xPush || 0.1;
            if (definition.roll) {
                this.radius = definition.radius || this.owner.radius || ((this.owner.width || this.owner.height || 2) / 2);
                this.owner.orientation = this.owner.orientation || 0;
            } else {
                this.radius = 0;
            }
            this.currentPushX = 0;
            this.currentPushY = 0;
            this.lastX = this.owner.x;
            this.lastY = this.owner.y;
            this.pushers = Array.setUp();
        },
        events: {
            "handle-logic": function (resp) {
                var i = 0,
                    delta = resp.delta;
                
                if (this.currentPushY) {
                    this.owner.y += setMagnitude(this.currentPushY, this.yPush * delta);
                    this.currentPushY = 0;
                }
                if (this.currentPushX) {
                    this.owner.x += setMagnitude(this.currentPushX, this.xPush * delta);
                    this.currentPushX = 0;
                }
                if ((this.lastX !== this.owner.x) || (this.lastY !== this.owner.y)) {
                    if (this.radius) {
                        this.owner.orientation += (this.owner.x + this.owner.y - this.lastX - this.lastY) / this.radius;
                    }
                    this.lastX = this.owner.x;
                    this.lastY = this.owner.y;
                }
                for (i = 0; i < this.pushers.length; i++) {
                    this.pushers[i].triggerEvent('pushed', this.owner);
                }
                this.pushers.length = 0;
            },
            "push-entity": function (collisionInfo) {
                var x = (collisionInfo.x || 0),
                    y = (collisionInfo.y || 0);
                
                this.currentPushX -= x;
                this.currentPushY -= y;
                if ((this.yPush && y) || (this.xPush && x)) {
                    this.pushers.push(collisionInfo.entity);
                }
            },
            "hit-solid": function (collisionInfo) {
                if (((collisionInfo.y > 0) && (this.vY > 0)) || ((collisionInfo.y < 0) && (this.vY < 0))) {
                    this.vY = 0;
                } else if (((collisionInfo.x < 0) && (this.vX < 0)) || ((collisionInfo.x > 0) && (this.vX > 0))) {
                    this.vX = 0;
                }
                return true;
            }
        },
        
        methods: {
            destroy: function () {
                this.pushers.recycle();
            }
        }
    });
}());

//##############################################################################
// LogicRebounder.js
//##############################################################################

/**
# COMPONENT **LogicRebounder**
This component works with `CollisionBasic` to cause entities to bounce away on solid collisions.

## Dependencies
- [[CollisionBasic]] - Relies on collision messages to perform rebounding movement.

## Messages

### Listens for:
- **handle-logic** - On receiving this message, `LogicRebounder` clears its stored collision information.
- **hit-static** - On receiving this message, `LogicRebounder` rebounds.
  - @param message.direction (2d vector) - This is the direction in which the collision occurred, tangental to the impact interface.
- **hit-non-static** - On receiving this message, `LogicRebounder` rebounds.
  - @param message.direction (2d vector) - This is the direction in which the collision occurred, tangental to the impact interface.
  - @param message.entity ([[entity]]) - This is the entity with which this entity is colliding.
- **share-velocity** - On receiving this message, `LogicRebounder` stores collision information.
  - @param entity ([[entity]]) - This is the entity with which this entity is colliding.

### Peer Broadcasts:
- **share-velocity** - This component triggers this message to prevent double collision calls.
  - @param entity ([[entity]]) - This entity.

## JSON Definition
    {
      "type": "LogicRebounder",
      
      "mass": 12,
      // Optional. Relative size of the entity. Defaults to 1.
      
      "elasticity": 0.4
      // Optional. Bounciness of the entity. Defaults to 0.8.
    }

Requires: ["../Vector.js"]
*/
/* global include, platypus */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector');

    return platypus.createComponentClass({
        id: 'LogicRebounder',
        
        constructor: function (definition) {
            platypus.Vector.assign(this.owner, 'velocity', 'dx', 'dy', 'dz');

            this.owner.mass = this.owner.mass || definition.mass || 1;
            this.elasticity = definition.elasticity || 0.8;
            
            this.v = Vector.setUp(0, 0, 0);
            this.incidentVector = Vector.setUp(0, 0, 0);
            
            this.staticCollisionOccurred = false;
            this.nonStaticCollisionOccurred = false;
            
            this.hitThisTick = Array.setUp();
            this.otherV = Vector.setUp(0, 0, 0);
            this.otherVelocityData = Array.setUp();
        },

        events: {// These are messages that this component listens for
            "handle-logic": function () {
                var i = 0;
                
                this.hitThisTick.length = 0;
                for (i = 0; i < this.otherVelocityData.length; i++) {
                    this.otherVelocityData[i].velocity.recycle();
                }
                this.otherVelocityData.length = 0;
            },
            "hit-static": function (collData) {
                var magnitude = 0,
                    other = collData.entity,
                    x = 0;

                for (x = 0; x < this.hitThisTick.length; x++) {
                    if (other === this.hitThisTick[x]) {
                        return;
                    }
                }
                this.hitThisTick.push(other);
                
                this.v.setVector(this.owner.velocity);
                this.incidentVector.setVector(collData.direction);
                
                magnitude = this.v.scalarProjection(this.incidentVector);
                if (!isNaN(magnitude)) {
                    this.incidentVector.scale(magnitude * (1 + this.elasticity));
                    this.v.subtractVector(this.incidentVector);
                }
                
                this.owner.velocity.setVector(this.v);
            },
            "hit-non-static": function (collData) {
                var x = 0,
                    other          = collData.entity,
                    otherVSet      = false,
                    relevantV      = 0,
                    otherRelevantV = 0,
                    reboundV       = 0;
                
                x = this.hitThisTick.indexOf(other);
                if (x >= 0) {
                    return;
                }
                this.hitThisTick.push(other);
                
                for (x = 0; x < this.otherVelocityData.length; x++) {
                    if (other === this.otherVelocityData[x].entity) {
                        this.otherV.setVector(this.otherVelocityData[x].velocity);
                        otherVSet = true;
                        break;
                    }
                }
                
                if (!otherVSet) {
                    this.otherV.setVector(other.velocity);
                    other.triggerEvent('share-velocity', this.owner);
                }
                
                this.v.setVector(this.owner.velocity);
                this.incidentVector.setVector(collData.direction);
                
                
                relevantV = this.v.scalarProjection(this.incidentVector);
                relevantV = (isNaN(relevantV)) ? 0 : relevantV;
                otherRelevantV = this.otherV.scalarProjection(this.incidentVector);
                otherRelevantV = (isNaN(otherRelevantV)) ? 0 : otherRelevantV;
                
                reboundV = (relevantV * (this.owner.mass - other.mass) + 2 * other.mass * otherRelevantV) / (this.owner.mass + other.mass);
                
                this.incidentVector.scale(reboundV - relevantV);
                
                this.owner.velocity.setVector(this.incidentVector);
                
            },
            "share-velocity": function (other) {
                this.otherVelocityData.push({
                    entity: other,
                    velocity: Vector.setUp(other.velocity)
                });
            }
        },
        
        methods: {// These are methods that are called by this component.
            destroy: function () {
                this.v.recycle();
                this.incidentVector.recycle();
                this.otherV.recycle();
                this.hitThisTick.recycle();
                this.otherVelocityData.recycle();
            }
        },
        
        publicMethods: {// These are methods that are available on the entity.

        }
    });
}());

//##############################################################################
// LogicRegionSpawner.js
//##############################################################################

/**
# COMPONENT **LogicRegionSpawner**
This component spawns new entities within a given area at set intervals.

## Dependencies
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to determine whether to spawn another entity.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component determines whether to spawn another entity.
  - @param message.delta - To determine whether to spawn, the component keeps a running count of tick lengths.

## JSON Definition
    {
      "type": "LogicRegionSpawner",
      // List all additional parameters and their possible values here.
      
      "spawn": "teddy-bear",
      // Required. String identifying the type of entity to spawn.
      
      "interval": 30000,
      // Optional. Time in milliseconds between spawning an entity. Defaults to 1000.
      
      "regions": {
      // If spawning entity covers a large area, the spawned entities can be randomly spawned over a regional grid, so that the whole area gets a somewhat uniform coverage of spawned entities

        "width": 4000,
        "height": 5000,
        // Optional. Dimensions of a spawning region in world units. Defaults to entity's dimensions. The entity's dimensions are sliced into chunks of this size for spawn distribution.
      }
    }
*/
/* global include, platypus */
(function () {
    'use strict';
    
    var Entity = include('platypus.Entity');

    return platypus.createComponentClass({
        
        id: 'LogicRegionSpawner',
        
        constructor: function (definition) {
            var x       = 0,
                y       = 0,
                columns = 1,
                rows    = 1,
                width   = 0,
                height  = 0,
                rw      = 0,
                rh      = 0;
            
            this.spawnPosition = {
                x: 0,
                y: 0
            };
            this.spawnProperties = {
                properties: this.spawnPosition
            };
            
            this.regions = null;
            this.usedRegions = null;
            this.regionWidth = 0;
            this.regionHeight = 0;
            if (definition.regions) {
                this.regions = Array.setUp();
                this.usedRegions = Array.setUp();
                this.regionWidth  = width  = definition.regions.width  || this.owner.width;
                this.regionHeight = height = definition.regions.height || this.owner.height;
                columns = Math.round(this.owner.width  / width);
                rows    = Math.round(this.owner.height / height);
                for (x = 0; x < columns; x++) {
                    for (y = 0; y < rows; y++) {
                        rw = Math.min(width,  this.owner.width  - x * width);
                        rh = Math.min(height, this.owner.height - y * height);
                        this.regions.push({
                            x: x * width,
                            y: y * height,
                            width: rw,
                            height: rh
                        });
                    }
                }
            }
            
            this.entityClass = platypus.game.settings.entities[definition.spawn];
            
            this.interval = this.owner.interval || definition.interval || 1000;
            this.time = 0;
        },

        events: {// These are messages that this component listens for
            "handle-logic": function (resp) {
                var regions = this.regions,
                    region  = null;
                
                this.time += resp.delta;
                
                if (this.time > this.interval) {
                    this.time -= this.interval;
                    
                    if (regions) {
                        if (!regions.length) {
                            this.regions = this.usedRegions;
                            this.usedRegions = regions;
                            regions = this.regions;
                        }
                        
                        region = regions[Math.floor(regions.length * Math.random())];
                        
                        this.spawnPosition.x = this.owner.x - (this.owner.regX || 0) + (region.x + (Math.random() * region.width));
                        this.spawnPosition.y = this.owner.y - (this.owner.regY || 0) + (region.y + (Math.random() * region.height));
                    } else {
                        this.spawnPosition.x = this.owner.x - (this.owner.regX || 0) + (Math.random() * this.owner.width);
                        this.spawnPosition.y = this.owner.y - (this.owner.regY || 0) + (Math.random() * this.owner.height);
                    }

                    this.owner.triggerEvent('entity-created', this.owner.parent.addEntity(new platypus.Entity(this.entityClass, this.spawnProperties)));
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.regions.recycle();
                this.usedRegions.recycle();
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var spawn = def.spawn || props.spawn || defaultProps.spawn;
            
            if (spawn) {
                return Entity.getAssetList({
                    type: spawn
                });
            }
            
            return Array.setUp();
        }
    });
}());

//##############################################################################
// LogicRotationalMovement.js
//##############################################################################

/**
# COMPONENT **LogicRotationalMovement**
This component changes the (x, y) position of an object according to its current speed and heading. It maintains its own heading information independent of other components allowing it to be used simultaneously with other logic components like [[Logic-Pushable]]. It accepts directional messages that can stand alone, or come from a mapped controller, in which case it checks the `pressed` value of the message before changing its course accordingly.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.
  - @param message.delta - To determine how far to move the entity, the component checks the length of the tick.
- **[directional message]** - Directional messages include `turn-left`, `turn-right`, `go-forward`, and `go-backward`. On receiving one of these messages, the entity adjusts its movement and orientation.
  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: true causes movement in the triggered direction, false turns off movement in that direction. Note that if no message is included, the only way to stop movement in a particular direction is to trigger `stop` on the entity before progressing in a new orientation.
- **stop** - Stops rotational and linear motion movement messages are again received.
  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: a value of false will not stop the entity.
- **stop-turning** - Stops rotational motion until movement messages are again received.
  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: a value of false will not stop the entity.
- **stop-moving** - Stops linear motion until movement messages are again received.
  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: a value of false will not stop the entity.

## JSON Definition:
    {
      "type": "LogicRotationalMovement",
      
      "speed": 4.5,
      // Optional. Defines the distance in world units that the entity should be moved per millisecond. Defaults to 0.3.
      
      "angle": 0,
      // Optional: Radian orientation that entity should begin in. Defaults to 0 (facing right).
      
      "degree": 0.1
      // Optional: Unit in radian that the angle should change per millisecond.
    }
*/
/*global platypus */
(function () {
    'use strict';

    var cos = Math.cos,
        sin = Math.sin,
        polarToCartesianX = function (m, a) {
            return m * cos(a);
        },
        polarToCartesianY = function (m, a) {
            return m * sin(a);
        };
    
    return platypus.createComponentClass({
        id: 'LogicRotationalMovement',
        constructor: function (definition) {
            var state = this.owner.state;
            
            this.speed = definition.speed || 0.3;
            this.magnitude = 0;
            this.degree = definition.degree || 1;
            this.angle = definition.angle || 0;
            
            this.state = state;
            state.set('moving', false);
            state.set('turningRight', false);
            state.set('turningLeft', false);
    
            this.owner.orientation  = 0;
            
            this.moving = false;
            this.turningRight = false;
            this.turningLeft = false;
        },
        events: {
            "handle-logic": function (resp) {
                var state = this.state,
                    vX = 0,
                    vY = 0;
                
                if (this.turningRight) {
                    this.angle += this.degree * resp.delta / 15;
                }
        
                if (this.turningLeft) {
                    this.angle -= this.degree * resp.delta / 15;
                }
                
                if (this.moving) {
                    vX = polarToCartesianX(this.magnitude, this.angle);
                    vY = polarToCartesianY(this.magnitude, this.angle);
                }
        
                this.owner.x += (vX * resp.delta);
                this.owner.y += (vY * resp.delta);
                
                state.set('moving', this.moving);
                state.set('turningLeft', this.turningLeft);
                state.set('turningRight', this.turningRight);
                
                if (this.owner.rotation !== this.angle) {
                    this.owner.rotation = this.angle;
                }
            },
            "turn-right": function (state) {
                if (state) {
                    this.turningRight = state.pressed;
                } else {
                    this.turningRight = true;
                }
            },
            "turn-left": function (state) {
                if (state) {
                    this.turningLeft = state.pressed;
                } else {
                    this.turningLeft = true;
                }
            },
            "go-forward": function (state) {
                if (!state || state.pressed) {
                    this.moving = true;
                    this.magnitude = this.speed;
                } else {
                    this.moving = false;
                }
            },
            "go-backward": function (state) {
                if (!state || state.pressed) {
                    this.moving = true;
                    this.magnitude = -this.speed;
                } else {
                    this.moving = false;
                }
            },
            "stop": function (state) {
                if (!state || state.pressed) {
                    this.moving = false;
                    this.turningLeft = false;
                    this.turningRight = false;
                }
            },
            "stop-moving": function (state) {
                if (!state || state.pressed) {
                    this.moving = false;
                }
            },
            "stop-turning": function (state) {
                if (!state || state.pressed) {
                    this.turningLeft = false;
                    this.turningRight = false;
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// LogicSpawner.js
//##############################################################################

/**
# COMPONENT **LogicSpawner**
This component creates an entity and propels it away. This is useful for casting, firing, tossing, and related behaviors.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to determine whether it should be spawning or not.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component checks its current state to decide whether to spawn entities.
- **spawn** - creates an entity on the following tick message.
  - @param message.pressed (boolean) - Optional. If `message` is included, the component checks the value of `pressed`: false results in no entities being created. Is this primarily for controller input.

## JSON Definition
    {
      "type": "LogicSpawner"
      // List all additional parameters and their possible values here.

      "spawneeClass": "wet-noodle",
      // Required: string identifying the type of entity to create.
      
      "state": "tossing",
      // Optional. The entity state that should be true while entities are being created. Defaults to "firing".
      
      "speed": 4,
      // Optional. The velocity with which the entity should start. Initial direction is determined by this entity's facing states ("top", "right", etc).
      
      "offsetX": 45,
      "offsetY": -20,
      // Optional. Location relative to the entity where the should be located once created. Defaults to (0, 0).
    }
*/
/*global include, platypus */
(function () {
    'use strict';

    var Entity = include('platypus.Entity');

    return platypus.createComponentClass({
        
        id: 'LogicSpawner',
        
        constructor: function (definition) {
            var className = this.owner.spawneeClass || definition.spawneeClass,
                prop = '',
                x = 0;

            this.state = this.owner.state;
            this.stateName = definition.state || 'spawning';
            this.entityClass = platypus.game.settings.entities[className];
            this.speed = definition.speed || this.owner.speed || 0;

            this.state.set(this.stateName, false);
            
            this.spawneeProperties = {
                x: 0,
                y: 0,
                z: 0,
                dx: 0,
                dy: 0,
                spawner: this.owner
            };
            
            if (definition.passOnProperties) {
                for (x = 0; x < definition.passOnProperties.length; x++) {
                    prop = definition.passOnProperties[x];
                    if (this.owner[prop]) {
                        this.spawneeProperties[prop] = this.owner[prop];
                    }
                }
            }
            
            
            this.propertiesContainer = {
                properties: this.spawneeProperties
            };
            
            this.offsetX = this.owner.offsetX || definition.offsetX || 0;
            this.offsetY = this.owner.offsetY || definition.offsetY || 0;
            
            this.firing = false;
        },

        events: {// These are messages that this component listens for
            "handle-logic": function () {
                var offset = 0,
                    classZ = 0,
                    state  = this.state;
                
                if (this.firing) {
                    this.spawneeProperties.x = this.owner.x;
                    this.spawneeProperties.y = this.owner.y;
                    classZ = (this.entityClass.properties && this.entityClass.properties.z) ? this.entityClass.properties.z : 0;
                    this.spawneeProperties.z = this.owner.z + classZ;
                    
                    offset = this.offsetX;
                    if (state.get('left')) {
                        offset *= -1;
                    }
                    this.spawneeProperties.x += offset;
                    
                    offset = this.offsetY;
                    if (state.get('top')) {
                        offset *= -1;
                    }
                    this.spawneeProperties.y += offset;
                    
                    if (this.speed) {
                        if (state.get('top')) {
                            this.spawneeProperties.dy = -this.speed;
                        } else if (state.get('bottom')) {
                            this.spawneeProperties.dy = this.speed;
                        } else {
                            delete this.spawneeProperties.dy;
                        }
                        if (state.get('left')) {
                            this.spawneeProperties.dx = -this.speed;
                        } else if (state.get('right')) {
                            this.spawneeProperties.dx = this.speed;
                        } else {
                            delete this.spawneeProperties.dx;
                        }
                    } else {
                        delete this.spawneeProperties.dx;
                        delete this.spawneeProperties.dy;
                    }
                    
                    if (this.parent) {
                        this.owner.triggerEvent('entity-created', this.parent.addEntity(new platypus.Entity(this.entityClass, this.propertiesContainer)));
                    }
                }
                
                state.set(this.stateName, this.firing);

                this.firing = false;
            },
            "spawn": function (value) {
                this.firing = !value || (value.pressed !== false);
                
                this.parent = this.owner.parent; //proofing against this entity being destroyed prior to spawned entity. For example, when a destroyed entity spawns a drop.
            }
        },
        
        methods: {
            destroy: function () {
                this.state = null;
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var spawn = def.spawneeClass || props.spawneeClass || defaultProps.spawneeClass;
            
            if (spawn) {
                return Entity.getAssetList({
                    type: spawn
                });
            }
            
            return Array.setUp();
        }
    });
}());

//##############################################################################
// LogicStateMachine.js
//##############################################################################

/**
# COMPONENT **LogicStateMachine**
This component is a general purpose state-machine for an entity, taking in various message inputs to determine the entity's state and triggering messages as necessary when a certain state occurs or several state combinations are in place.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component checks sustained inputs for changes in state.
- **update-state** - Updates the entity's state according to this message's state information.
  - @param message (object) - This is an object of key/value pairs where keys are states and the values are booleans to turn on and off states.
- **state-changed** - Updates the entity's state according to this message's state information, and broadcasts any applicable messages.
  - @param message (object) - This is an object of key/value pairs where keys are states and the values are booleans to turn on and off states.
- **[input messages]** - This component listens for messages as determined by the JSON settings.

### Local Broadcasts:
- **[output messages]** - This component triggers output messages as determined by the JSON settings.

## JSON Definition
    {
      "type": "LogicStateMachine",
      
      "inputs":{
      // This is a list of messages that this component should listen for to change states.
      
        "smell-toast":{
        // If the entity triggers "smell-toast", this component will change the state of the entity as follows:
        
          "smelling-food": true,
          "smelling-nothing": false
        },
        
        "go-to-store":{
          "at-store": true
        }
      },
      
      "sustained-inputs":{
      // These are messages that must be triggered every tick for the state to remain true: if not, they become false.
        "near-grover": "smelling-trash"
      }
    }
*/
/* global include, platypus */
(function () {
    'use strict';

    var DataMap = include('platypus.DataMap'),
        StateMap = include('platypus.StateMap'),
        changeState = function (changes, state) {
            state.update(changes);
        },
        changeSustainedState = function (change, state) {
            state.set(change, true);
        },
        handleResult = null,
        handleOutput = null,
        setUpOutputs = function (outs) {
            var data = null,
                key = '';
            
            if (!outs || (typeof outs !== 'object') || Array.isArray(outs) || outs.event) {
                return outs;
            } else {
                data = DataMap.setUp();
                for (key in outs) {
                    if (outs.hasOwnProperty(key)) {
                        data.set(key, setUpOutputs(outs[key]));
                    }
                }
                return data;
            }
        },
        recycleOutputs = function (outs) {
            var keys = outs.keys,
                i = keys.length;

            if (outs instanceof DataMap) {
                while (i--) {
                    recycleOutputs(outs[keys[i]]);
                }
                outs.recycle();
            }
        };
    
    handleResult = function (title, state, last, checks, changed, self, queue) {
        var i = 0,
            key = '',
            keys = null,
            message = checks.message || (checks.message === 0) || (checks.message === false),
            value = null;

        if (changed) {
            if (typeof checks === 'string') {
                self.triggerEvent(checks);
                return;
            } else if (Array.isArray(checks)) {
                for (i = 0; i < checks.length; i++) {
                    handleResult(title, state, last, checks[i], changed, self, queue);
                }
                return;
            } else if (checks.event && (message || checks.delay)) {
                if (checks.delay) {
                    queue.push(checks);
                } else {
                    self.trigger(checks.event, checks.message);
                }
                return;
            } else if (checks.get) {
                value = checks.get('true');
                if (value) {
                    handleResult(title, state, last, value, changed, self, queue);
                }
            }
        }

        keys = checks.keys;
        if (keys) {
            i = keys.length;
            while (i--) {
                key = keys[i];
                if (key !== 'true') {
                    handleOutput(key, state, last, checks.get(key), changed, self, queue);
                }
            }
        }
    };
    
    handleOutput = function (title, state, last, checks, changed, self, queue) {
        var c     = changed,
            value = false,
            st = "",
            stateValue = false;

        if (title.charAt(0) === '!') {
            st = title.substring(1);
            stateValue = state.get(st);
            value = (stateValue === false);
            if ((title !== 'outputs') && (last.get(st) !== stateValue)) {
                c = true;
            }
        } else {
            stateValue = state.get(title);
            value = (stateValue === true);
            if ((title !== 'outputs') && (last.get(title) !== stateValue)) {
                c = true;
            }
        }

        if (value || (title === 'outputs')) {
            handleResult(title, state, last, checks, c, self, queue);
        }
    };

    return platypus.createComponentClass({
        id: 'LogicStateMachine',
        
        properties: {
            /**
             * This is the list of events containing key/value pairs that describe state changes to make for the given event.
             *
             *     {
             *         "smell-toast": {
             *             "smelling-food": true,
             *             "smelling-nothing": false
             *         },
             *         "go-to-store": {
             *             "at-store": true
             *         }
             *     }
             *
             * @property inputs
             * @type Object
             * @default null
             */
            inputs: null,
            
            /**
             * These are messages that should be triggered when certain conditions are met. The messages are only triggered the instant the condition is met, until the conditions are no longer met and then once again met. Example:
             *
             *     {
             *         "smelling-food": { // Keys map to states, and if true, the value of the key is processed. In this case, the value of the "smelling-food" key is another object of key/value pairs, giving us another layer of checks.
             *             "!smelling-trash": "time-to-eat", // This key is an inverse check, meaning that the "smelling-trash" state of the entity must be false to continue along this path. This time the value is a string, so the string "time-to-eat" is treated as a message to be broadcast if the entity is both "smelling-food" and not "smelling-trash".
             *             "true": "belly-rumble" // In some cases, a message should be triggered for a set of states, while still doing deeper state checks like above. "true" will always handle the next layer of values if the parent key was true.
             *         },
             *         "smelling-trash": "feeling-sick" // Multiple states can be handled to multiple depths, like a list of if () statements
             *         "!smelling-nothing": {
             *             "!smelling-trash":{
             *                 "!at-store": "go-to-store", // Note that the "go-to-store" message will change this entity's state to "at-store" according to "inputs" above, but LogicStateMachine uses a cache of states when broadcasting output messages, so the next section will not be processed until the next state check.
             *                 "at-store":{
             *                     "have-money": "buy-more-food",
             *                     "!have-money": "buy-less-food"
             *                 }
             *             }
             *         }
             *     }
             *
             * @property outputs
             * @type Object
             * @default null
             */
            outputs: null
        },
        
        constructor: function (definition) {
            var i = 0,
                inputDefinition = this.inputs,
                key = '',
                keys = null,
                state = null,
                stateObjects = null,
                susDef = definition["sustained-inputs"],
                thisState = this.owner.state;
            
            this.state = thisState;
            
            if (inputDefinition) {
                stateObjects = Array.setUp();
                for (key in inputDefinition) {
                    if (inputDefinition.hasOwnProperty(key)) {
                        state = StateMap.setUp(inputDefinition[key]);
                        stateObjects.push(state);
                        this.addEventListener(key, changeState.bind(this, state, thisState));
                        keys = state.keys;
                        i = keys.length;
                        while (i--) {
                            thisState.set(keys[i], false);
                        }
                    }
                }
                this.stateObjects = stateObjects;
            }

            this.sustainedState = StateMap.setUp();
            if (susDef) {
                for (key in susDef) {
                    if (susDef.hasOwnProperty(key)) {
                        this.addEventListener(key, changeSustainedState.bind(this, susDef[key], this.sustainedState));
                        this.sustainedState.set(susDef[key], false);
                        thisState.set(susDef[key], false);
                    }
                }
            }

            this.snapshot = StateMap.setUp();
            this.last = StateMap.setUp();
            this.queueTimes = Array.setUp();
            this.queue = Array.setUp();
            this.outputs = setUpOutputs(this.outputs);
        },

        events: {
            "handle-logic": function (resp) {
                var susState = this.sustainedState,
                    key = '',
                    keys = susState.keys,
                    i = keys.length,
                    state = this.state;
                
                while (i--) {
                    key = keys[i];
                    state.set(key, susState.get(key));
                    susState.set(key, false);
                }
                
                i = this.queue.length;
                while (i--) {
                    this.queueTimes[i] -= resp.delta;
                    
                    if (this.queueTimes[i] <= 0) {
                        this.owner.trigger(this.queue[i].event, this.queue[i].message);
                        this.queueTimes.greenSplice(i);
                        this.queue.greenSplice(i);
                    }
                }
            },
            
            "update-state": function (state) {
                this.state.update(state);
            },
            
            "state-changed": function (state) {
                var i = 0,
                    queue = null,
                    ss = this.snapshot;
                
                if (this.outputs) {
                    ss.update(state);
                    
                    queue = Array.setUp();
                    handleOutput('outputs', ss, this.last, this.outputs, false, this.owner, queue);
                    i = queue.length;
                    while (i--) {
                        this.queue.push(queue[i]);
                        this.queueTimes.push(queue[i].delay);
                    }
                    queue.recycle();
                    
                    this.last.update(ss);
                }
            }
        },
        
        methods: {
            destroy: function () {
                var i = 0,
                    so = this.stateObjects;
                
                this.queueTimes.recycle();
                this.queue.recycle();
                
                if (so) {
                    i = so.length;
                    while (i--) {
                        so[i].recycle();
                    }
                    so.recycle();
                    this.stateObjects = null;
                }

                this.sustainedState.recycle();
                this.snapshot.recycle();
                this.last.recycle();
                
                this.state = null;
                this.inputs = null;
            }
        }
    });
}());

//##############################################################################
// LogicSwitch.js
//##############################################################################

/**
# COMPONENT **LogicSwitch**
This component serves as a switch in the game world, typically tied to collision events such that this entity changes state when another entity collides or passed over.

## Dependencies:
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its state.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component determines its state and triggers messages accordingly.
- **switch-pressed** - Causes the switch to be in a pressed state.

### Local Broadcasts:
- **switch-on** - This message is triggered when the switch has just been pressed.
- **switch-off** - This message is triggered when the switch has just been released.
- **initial-press** - This message is triggered the first time the switch is pressed. This occurs before the "switch-on" message is triggered.

## JSON Definition:
    {
      "type": "LogicSwitch",
      
      "sticky": true
      // Optional. Whether a pressed switch should stay pressed once collision messages cease. Defaults to `false`.
    }
*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        
        id: 'LogicSwitch',
        
        constructor: function (definition) {
            this.state = this.owner.state;
            this.pressed = false;
            this.wasPressed = this.pressed;
            this.sticky = definition.sticky || false;
            this.state.set('pressed', false);
            this.initialPress = true;
        },

        events: {// These are messages that this component listens for
            "handle-logic": function () {
                if (this.sticky) {
                    if (this.pressed && !this.wasPressed) {
                        this.state.set('pressed', true);
                        this.wasPressed = true;
                        this.owner.triggerEvent('switch-on');
                    }
                } else {
                    if (this.pressed !== this.wasPressed) {
                        if (this.pressed) {
                            this.state.set('pressed', true);
                            this.owner.triggerEvent('switch-on');
                        } else {
                            this.state.set('pressed', false);
                            this.owner.triggerEvent('switch-off');
                        }
                    }
                    this.wasPressed = this.pressed;
                    this.pressed = false;
                }
            },
            'switch-pressed': function () {
                this.pressed = true;
                if (this.initialPress) {
                    this.owner.triggerEvent('initial-press');
                    this.initialPress = false;
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// LogicTeleportee.js
//##############################################################################

/**
# COMPONENT **LogicTeleportee**
This component causes an entity to teleport when receiving a teleport message.

## Dependencies:
- [[CollisionBasic]] (on entity) - This component triggers "relocate-entity" to perform teleport, for which "CollisionBasic" listens.
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component updates its location according to its current state.
- **teleport** - Teleports the entity to its set destination.
- **set-destination** - Sets the destination to teleport to in world coordinates.
  - @param message.x, message.y (number) - The position in world coordinates to set the teleport destination to.
- **hit-telepoint** - Sets the destination to the colliding entity's coordinates: useful for checkpoint behavior.
  - @param message ([[Entity]]) - The entity whose coordinates will be the teleport destination.

### Local Broadcasts:
- **relocate-entity** - Broadcasts the new location for the entity.
  - @param message.x, message.y (number) - The position in world coordinates to set the teleport destination to.
- **teleport-complete** - Triggered once the entity has been moved to the new location.

## JSON Definition
    {
      "type": "LogicTeleportee"
    }
*/
/* global include, platypus */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector');

    return platypus.createComponentClass({
        id: 'LogicTeleportee',
        
        constructor: function () {
            this.teleportDestination = Vector.setUp();
            this.teleportNow = false;
            this.DestinationSet = false;
            this.message = {
                position: this.teleportDestination
            };
        },

        events: {// These are messages that this component listens for
            "handle-logic": function () {
                if (this.teleportNow) {
                    this.owner.triggerEvent('relocate-entity', this.message);
                    this.teleportNow = false;
                    this.owner.triggerEvent('teleport-complete');
                }
            },
            "teleport": function () {
                if (this.destinationSet) {
                    this.teleportNow = true;
                }
            },
            "set-destination": function (position) {
                this.setDestination(position);
            },
            "hit-telepoint": function (collisionInfo) {
                this.setDestination(collisionInfo.entity);
            }
        },
        
        methods: {
            setDestination: function (position) {
                this.teleportDestination.setXYZ(position.x, position.y, this.owner.z);
                this.destinationSet = true;
            },
            
            destroy: function () {
                this.teleportDestination.recycle();
            }
        }
    });
}());

//##############################################################################
// LogicTeleporter.js
//##############################################################################

/**
# COMPONENT **LogicTeleporter**
This component listens for redirected collision messages and fires a message on the colliding entity to specify where the colliding entity should relocate itself.

## Dependencies:
- [[Collision-Basic]] (on entity) - This component listens for collision messages on the entity.
- [[Entity-Container]] (on entity's parent) - This component listens for new peer entities being added on its parent to find its teleport destination.

## Messages

### Listens for:
- **peer-entity-added** - This teleporter listens as other entities are added so it can recognize the entity it should teleport colliding objects to.
  - @param message (object) - expects an entity as the message object in order to determine whether it is the requested teleportation destination.
- **teleport-entity** - On receiving this message, the component will fire `teleport` on the colliding entity, sending this.destination. The colliding entity must handle the `teleport` message and relocate itself.
  - @param message.x (integer) - uses `x` to determine if collision occurred on the left (-1) or right (1) of this entity.
  - @param message.y (integer) - uses `y` to determine if collision occurred on the top (-1) or bottom (1) of this entity.
  - @param message.entity (object) - triggers a `teleport` message on `entity`.

### Peer Broadcasts:
- **teleport** - On receiving a `teleport-entity` message, if the colliding entity is colliding on the teleporter's facing side, this message is triggered on the colliding entity.
  - @param message (object) - sends the destination entity as the message object, the x and y coordinates being the most important information for the listening entity.

## JSON Definition:
    {
      "type": "LogicTeleporter",
      
      "facing": "up",
      // Optional: "up", "down", "left", or "right". Will only trigger "teleport" if colliding entity collides on the facing side of this entity. If nothing is specified, all collisions fire a "teleport" message on the colliding entity.
      
      "teleportId": "Destination entity's linkId property"
      // Required: String that matches the "linkId" property of the destination entity. This destination entity is passed on a "teleport" message so teleporting entity knows where to relocate.
    }

*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'LogicTeleporter',

        constructor: function (definition) {
            
            this.destination = null;
            this.linkId = this.owner.teleportId || definition.teleportId;
            this.facing = this.owner.facing || definition.facing || false; //TODO: Should probably deprecate this in favor of orientation. - DDD 3/2/2016
        
            if (this.facing) {
                this.owner.state.set('facing-' + this.facing, true);
            }
        },

        events: {// These are messages that this component listens for
            "peer-entity-added": function (entity) {
                if (!this.destination && (entity.linkId === this.linkId)) {
                    this.destination = entity;
                }
            },
    
            "teleport-entity": function (collisionInfo) {
                switch (this.facing) {
                case 'up':
                    if (collisionInfo.y < 0) {
                        collisionInfo.entity.triggerEvent('teleport', this.destination);
                    }
                    break;
                case 'right':
                    if (collisionInfo.x > 0) {
                        collisionInfo.entity.triggerEvent('teleport', this.destination);
                    }
                    break;
                case 'down':
                    if (collisionInfo.y > 0) {
                        collisionInfo.entity.triggerEvent('teleport', this.destination);
                    }
                    break;
                case 'left':
                    if (collisionInfo.x < 0) {
                        collisionInfo.entity.triggerEvent('teleport', this.destination);
                    }
                    break;
                default:
                    collisionInfo.entity.triggerEvent('teleport', this.destination);
                    break;
                }
            }
        },
        
        methods: {// These are methods that are called on the component
            "destroy": function () {
                this.destination = null;
            }
        }
        
    });
}());

//##############################################################################
// LogicTimer.js
//##############################################################################

/**
# COMPONENT **LogicTimer**
A timer that can used to trigger events. The timer can increment and decrement. It can be an interval timer, going off over and over. Has a max time which it will not exceed by default this is 1 hour.

## Dependencies
- [[Handler-Logic]] (on entity's parent) - This component listens for a "handle-logic" message to update the timer.

## Messages

### Listens for:
- **handle-logic** - Handles the update for the timer. Increments or decrements the current time. If it's hit the max it stops the timer at the max. If it hits the alarm it sets it off. Sends an update message indicating the timer's current time for other components to use.
  - @param data.delta (number) - The time passed since the last tick.
- **set** - Set the time.
  - @param data.time (number) - The new value for the time.
- **start** - Start the timer counting.
- **stop** - Stop the timer counting.

### Local Broadcasts:
- **[alarm message from definition]** - The definition.alarm value from the JSON definition is used as the message id. It's sent when the alarm goes off.
- **[update message from definition]** - The definition.update value from the JSON definition is used as the message id. It's sent every 'handle-logic' tick.
  - @param message.time (number) - The current time value for the timer.

## JSON Definition
    {
      "type": "LogicTimer",
      "time" : 0,
      //Optional - The starting time for the timer. Defaults to 0.
      "alarmTime" : 10000,
      //Optional - The time when the alarm will trigger the alarm message. Defaults to undefined, which never triggers the alarm.
      "isInterval" : false,
      //Optional - Whether or not the alarm fires at intervals of the alarmTime. Defaults to false.
      "alarmMessage" : "ding",
      //Optional - The message sent when the alarm goes off. Defaults to an empty string.
      "updateMessage" : "",
      //Optional - The message sent when the timer updates. Defaults to an empty string.
      "on" : true,
      //Optional - Whether the alarm starts on. Defaults to true.
      "isIncrementing" : true,
      //Optional - Whether the timer is incrementing or decrementing. If the value is false it is decrementing. Defaults to true.
      "maxTime" : 3600000
      //Optional - The max value, positive or negative, that the timer will count to. At which it stops counting. Default to 3600000 which equals an hour.
    }
*/
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'LogicTimer',
        constructor: function (definition) {
            this.time = this.owner.time || definition.time ||  0;
            this.prevTime = this.time;
            this.alarmTime = this.owner.alarmTime || definition.alarmTime || 0;
            this.isInterval = this.owner.isInterval || definition.isInterval || false;
            this.alarmMessage =  this.owner.alarmMessage || definition.alarmMessage || '';
            this.updateMessage = this.owner.updateMessage || definition.updateMessage || '';
            this.isOn = this.owner.on || definition.on || true;
            this.isIncrementing = this.owner.isIncrementing || definition.isIncrementing || true;
            this.maxTime = this.owner.maxTime || definition.maxTime || 3600000; //Max time is 1hr by default.
        },
        events: {
            "handle-logic": function (data) {
                if (this.isOn) {
                    this.prevTime = this.time;
                    if (this.isIncrementing) {
                        this.time += data.delta;
                    } else {
                        this.time -= data.delta;
                    }
                    
                    if (Math.abs(this.time) > this.maxTime) {
                        //If the timer hits the max time we turn it off so we don't overflow anything.
                        if (this.time > 0) {
                            this.time = this.maxTime;
                        } else if (this.time < 0) {
                            this.time = -this.maxTime;
                        }
                        this.triggerEvent('stop-timer');
                    }
                    
                    if (this.alarmTime !== 0) {
                        if (this.isInterval) {
                            if (this.isIncrementing) {
                                if (Math.floor(this.time / this.alarmTime) > Math.floor(this.prevTime / this.alarmTime)) {
                                    this.owner.trigger(this.alarmMessage);
                                }
                            } else if (Math.floor(this.time / this.alarmTime) < Math.floor(this.prevTime / this.alarmTime)) {
                                this.owner.trigger(this.alarmMessage);
                            }
                        } else if (this.isIncrementing) {
                            if (this.time > this.alarmTime && this.prevTime < this.alarmTime) {
                                this.owner.trigger(this.alarmMessage);
                            }
                        } else if (this.time < this.alarmTime && this.prevTime > this.alarmTime) {
                            this.owner.trigger(this.alarmMessage);
                        }
                    }
                }
                this.owner.trigger(this.updateMessage, {time: this.time});
            },
            "set-timer": function (data) {
                this.time = data.time;
            },
            "start-timer": function () {
                this.isOn = true;
            },
            "stop-timer": function () {
                this.isOn = false;
            }
        }
    });
}());

//##############################################################################
// LogicWindUpRacer.js
//##############################################################################

/**
 * Replicates logic for a wind-up toy: listens for a wind-up message over a series of ticks to charge, and then begins racing once the charge is complete.
 *
 * @namespace platypus.components
 * @class LogicWindUpRacer
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        
        id: 'LogicWindUpRacer',
        
        properties: {
            /**
             * Velocity at which the entity should travel while racing.
             *
             * @property speed
             * @type Number
             * @default 0.3
             */
            speed: 0.3,
            
            /**
             * Time in milliseconds that entity will race before coming to a stop.
             *
             * @property raceTime
             * @type Number
             * @default 5000
             */
            raceTime: 5000,
            
            /**
             * Time in milliseconds that entity needs to receive wind-up calls before racing can begin.
             *
             * @property windTime
             * @type Number
             * @default 500
             */
            windTime: 500
        },
        
        constructor: function () {
            var thisState = this.owner.state;
            
            this.windProgress = 0;
            
            this.winding = false;
            this.racing = false;
            this.blocked = false;
            this.right = false;
            this.left = false;
            
            this.state = thisState;
            thisState.set('windingUp', false);
            thisState.set('racing', false);
            thisState.set('blocked', false);
        },

        events: {
            /**
             * On a `tick` logic message, the component updates its charging counter if necessary.
             *
             * @method 'handle-logic'
             * @param message.delta {Number} To determine how much to charge, the component checks the length of the tick.
             */
            "handle-logic": function (resp) {
                var thisState = this.state;
                
                if (this.racing) {

                    /**
                     * This event is triggered when winding is finished and the entity begins racing.
                     *
                     * @event 'racing'
                     */
                    if (!this.blocked && this.right && thisState.get('right')) {
                        this.owner.x += this.speed * resp.delta;
                        this.owner.triggerEvent('racing');
                    } else if (!this.blocked && this.left && thisState.get('left')) {
                        this.owner.x -= this.speed * resp.delta;
                        this.owner.triggerEvent('racing');
                    } else {
                        this.racing = false;

                        /**
                         * This event is triggered when the entity stops racing.
                         *
                         * @event 'stopped-racing'
                         */
                        this.owner.triggerEvent('stopped-racing');
                    }
                } else if (this.winding) {
                    if ((this.right && thisState.get('right')) || (this.left && thisState.get('left'))) {
                        this.windProgress += resp.delta;
                    }

                    /**
                     * This event is triggered as the entity winds up.
                     *
                     * @event 'winding'
                     * @param fraction {Number} The amount of progress that has been made from 0 to 1.
                     */
                    this.owner.triggerEvent('winding', this.windProgress / this.windTime);
                } else if (this.windProgress) {
                    if (this.windProgress >= this.windTime) {
                        this.racing = true;
                    }
                    this.windProgress = 0;

                    /**
                     * This event is triggered when the entity stops winding.
                     *
                     * @event 'stopped-winding'
                     */
                    this.owner.triggerEvent('stopped-winding');
                }
                
                thisState.set('windingUp', this.winding);
                thisState.set('racing', this.racing);
                thisState.set('blocked', this.blocked);
                this.blocked = false;
            },
            
            /**
             * Causes the entity to stop racing.
             *
             * @method 'stop-racing'
             */
            "stop-racing": function () {
                this.racing = false;
                this.owner.triggerEvent('stopped-racing');
            },
            
            /**
             * Causes the entity to wind up for a race.
             *
             * @method 'wind-up'
             * @param message.pressed {Boolean} If `message` is included, the component checks the value of `pressed`: `false` causes winding to stop.
             */
            "wind-up": function (value) {
                this.winding = !value || (value.pressed !== false);
                this.right = this.state.get('right');
                this.left  = this.state.get('left');
            },
            
            /**
             * On receiving this message, the entity stops racing.
             *
             * @method 'hit-solid'
             * @param collision.x {Number} Either 1,0, or -1. 1 if we're colliding with an object on our right. -1 if on our left. 0 if not at all.
             */
            "hit-solid": function (collision) {
                if (collision.x) {
                    if (this.racing && ((this.right && (collision.x > 0)) || (this.left && (collision.x < 0)))) {
                        this.blocked = true;
                        
                        /**
                         * This message is triggered if the entity collides while racing.
                         *
                         * @event 'blocked'
                         * @param collision {platypus.CollisionData} Collision information from the entity or tile that blocked movement.
                         */
                        this.owner.triggerEvent('blocked', collision);
                    }
                }
            }
        },
    
        methods: {
            destroy: function () {
                this.state.set('windingUp', false);
                this.state.set('racing', false);
                this.state.set('blocked', false);
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// Motion.js
//##############################################################################

/**
 * This component works in tandem with the [Mover](platypus.components.Mover.html) component by adding a vector of motion to the entity. This component is typically created by `Mover` and doesn't need to be added separately.
 *
 * @namespace platypus.components
 * @class Motion
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector'),
        isTrue = function () {
            return true;
        },
        createController = function (self, definition) {
            var getActiveAccelerationState = isTrue,
                getActiveVelocityState = isTrue,
                getInstantState = isTrue,
                state = self.owner.state,
                controlState = definition.controlState,
                instantState = definition.instantState,
                instantSuccess = definition.instantSuccess;

            if (controlState) {
                getActiveVelocityState = function () {
                    return state.get(controlState);
                };
            }

            if (self.instant || instantState) {
                if (instantState) {
                    getInstantState = function () {
                        return state.get(instantState);
                    };
                }
                
                self.instant = true;

                self.update = function () {
                    var state  = getInstantState(),
                        vState = getActiveVelocityState();
                    
                    if (this.activeVelocity) {
                        if (this.enact && !vState) { // Turn off ready if the state doesn't allow it.
                            this.ready = false;
                        }

                        if (this.ready && this.enact && state) {
                            this.ready = false; // to insure a single instance until things are reset
                            this.velocity.setVector(this.instant);
                            if (instantSuccess) {
                                this.owner.triggerEvent(instantSuccess);
                            }
                        } else if (!this.ready && !(this.enact && state)) {
                            this.ready = true;
                            this.decay();
                        } else if (vState) {
                            return null;
                        }
                        return this.velocity;
                    } else {
                        return null;
                    }
                };
            } else {
                self.update = function (delta) {
                    if (this.activeVelocity && getActiveVelocityState()) {
                        if (this.activeAcceleration && getActiveAccelerationState()) {
                            this.move(delta);
                        }

                        return this.velocity;
                    } else {
                        return null;
                    }
                };
            }
        };
    
    return platypus.createComponentClass({
        
        id: 'Motion',

        properties: {
            /**
             * Whether this motion should automatically re-orient when the entity re-orients.
             *
             * @property orient
             * @type boolean
             * @default true
             */
            orient: true,
            
            /**
             * A vector, Array, or number specifying the acceleration of the motion. Numbers apply magnitude along the x-axis. Arrays map to [x, y, z] on the vector.
             *
             * @property acceleration
             * @type platypus.Vector|Array|number
             * @default Vector(0, 0, 0)
             * @since 0.6.8
             */
            acceleration: 0,
            
            /**
             * Whether this motion should apply acceleration to the entity. Defaults to `true` unless an initial acceleration is left unset.
             *
             * @property activeAcceleration
             * @type boolean
             * @default true
             */
            activeAcceleration: true,
            
            /**
             * Whether this motion should apply acceleration to the entity.
             *
             * @property activeVelocity
             * @type boolean
             * @default true
             */
            activeVelocity: true,
            
            /**
             * This is the highest magnitude allowed for the motion vector.
             *
             * @property maxMagnitude
             * @type number
             * @default Infinity
             */
            maxMagnitude: Infinity,
            
            /**
             * When this state on the entity changes, this motion's active state is changed to match. If an "event" property is also set on this component, both the event and the state must be true for the motion to be active.
             *
             * @property controlState
             * @type String
             * @default ""
             */
            controlState: "",
            
            /**
             * If instant or instantState are set, the motion is only triggered for a single step and must be re-triggered to activate again. When the instantState on the entity becomes `true`, this motion's active state is changed to match. If an "instantState" property is also set on this component, both the event and the state must be true for the motion to be active.
             *
             * @property instant
             * @type Boolean
             * @default false
             * @since 0.6.7
             */
            instant: false,
            
            /**
             * If instant or instantState are set, the motion is only triggered for a single step and must be re-triggered to activate again. When the instantState on the entity becomes `true`, this motion's active state is changed to match. If an "instant" property is also set on this component, both the event and the state must be true for the motion to be active. If "event" or "controlState" are also defined, they must also be `true` to trigger an instant motion on the entity.
             *
             * @property instantState
             * @type String
             * @default ""
             */
            instantState: "",
            
            /**
             * If instantState is set, this event is triggered when the intance of motion occurs on the entity.
             *
             * @property instantSuccess
             * @type String
             * @default ""
             */
            instantSuccess: "",
            
            /**
             * This determines if setting active to `false` (via the control event or state) should dampen velocity. This is a ratio applied to the vector magnitude between 0 and 1. This is useful for events like jumping where a longer keypress should jump farther than a shorter keypress.
             *
             * @property instantDecay
             * @type number
             * @default null
             */
            instantDecay: null,
            
            /**
             * A vector, Array, or number specifying the direction and magnitude of the motion. Numbers apply magnitude along the x-axis. Arrays map to [x, y, z] on the vector.
             *
             * @property velocity
             * @type platypus.Vector|Array|number
             * @default Vector(0, 0, 0)
             * @since 0.6.8
             */
            velocity: 0,
            
            stopOnCollision: true,
            
            drag: -1,
            friction: -1
        },
        
        constructor: function (definition) {
            if (!this.acceleration) {
                this.activeAcceleration = false;
            }
            this.acceleration = Vector.setUp(this.acceleration);
            this.velocity     = Vector.setUp(this.velocity);

            this.triggered = false;
            this.ready = true;
            
            if (typeof this.instantDecay === "number") {
                this.capMagnitude = this.velocity.magnitude() * this.instantDecay;
            } else {
                this.capMagnitude = -1;
            }
            
            createController(this, definition);
            
            if (this.instant) {
                this.enact = false;
                this.instant = Vector.setUp(this.velocity);
                this.velocity.setXYZ(0, 0, 0);
            }

            if (this.orient) { // Orient vectors in case the entity is in a transformed position.
                this.owner.triggerEvent('orient-vector', this.velocity);
                this.owner.triggerEvent('orient-vector', this.acceleration);
            }
        },

        events: {
            /**
             * This event controls whether this velocity is active or inactive.
             *
             * @method 'control-velocity'
             * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{pressed: false}`, the motion becomes inactive.
             * @since 0.6.8
             */
            "control-velocity": function (control) {
                this.activeVelocity = (control && (control.pressed !== false));
            },
            
            /**
             * This event sets the velocity to inactive.
             *
             * @method 'stop-velocity'
             * @since 0.6.8
             */
            "stop-velocity": function () {
                this.activeVelocity = false;
            },
            
            /**
             * This event sets the velocity to active.
             *
             * @method 'start-velocity'
             * @since 0.6.8
             */
            "start-velocity": function () {
                this.activeVelocity = true;
            },
            
            /**
             * This event controls whether the acceleration is active or inactive.
             *
             * @method 'control-acceleration'
             * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{pressed: false}`, the motion becomes inactive.
             * @since 0.6.8
             */
            "control-acceleration": function (control) {
                this.activeAcceleration = (control && (control.pressed !== false));
            },
            
            /**
             * This event sets the acceleration to inactive.
             *
             * @method 'stop-acceleration'
             * @since 0.6.8
             */
            "stop-acceleration": function () {
                this.activeAcceleration = false;
            },
            
            /**
             * This event sets the acceleration to active.
             *
             * @method 'start-acceleration'
             * @since 0.6.8
             */
            "start-acceleration": function () {
                this.activeAcceleration = true;
            },
            
            /**
            * This event triggers an instant motion.
            *
            * @method 'instant-motion'
            * @param control {Object|boolean} If `true`, this motion becomes active. If `false` or `{triggered: false}`, the motion becomes inactive.
            * @since 0.6.7
            */
            "instant-motion": function (control) {
                this.enact = (control && (control.triggered !== false));
            },

            /**
            * This event triggers the beginning of an instant motion.
            *
            * @method 'instant-begin'
            * @since 0.6.7
            */
            "instant-begin": function () {
                this.enact = true;
            },

            /**
            * This event triggers the end of an instant motion.
            *
            * @method 'instant-end'
            * @since 0.6.7
            */
            "instant-end": function () {
                this.enact = false;
            },
            
            /**
            * This event modifies the properties of this Motion.
            *
            * @method 'set-motion'
            * @param motion {Object} A list of key/value pairs corresponding to motion values.
            * @param [motion.maxMagnitude] {Number} A value describing the maximum velocity or acceleration the motion vector can exert on the Entity.
            * @since 0.6.8
            */
            "set-motion": function (motion) {
                if (motion.acceleration) {
                    this.acceleration.set(motion.acceleration);
                }
                if (motion.velocity) {
                    this.velocity.set(motion.velocity);
                    if (typeof this.instantDecay === "number") {
                        this.capMagnitude = this.velocity.magnitude() * this.instantDecay;
                    } else {
                        this.capMagnitude = -1;
                    }
                }
                if (typeof motion.maxMagnitude === "number") {
                    this.maxMagnitude = motion.maxMagnitude;
                }
            }
        },

        methods: {
            move: function (delta) {
                var v = Vector.setUp(this.acceleration).multiply(delta);
                
                this.velocity.add(v);
                v.recycle();
                
                if (this.velocity.magnitude() > this.maxMagnitude) {
                    this.velocity.normalize().multiply(this.maxMagnitude);
                }
                return this.velocity;
            },
            
            // This handles things like variable height jumping by adjusting the jump velocity to the pre-determined cap velocity for jump-button release.
            decay: function () {
                if ((this.capMagnitude >= 0) && (this.velocity.magnitude() > this.capMagnitude)) {
                    this.velocity.normalize().multiply(this.capMagnitude);
                }
            },
            
            destroy: function () {
                if (this.orient) {
                    this.owner.triggerEvent('remove-vector', this.acceleration);
                    this.owner.triggerEvent('remove-vector', this.velocity);
                }
                this.acceleration.recycle();
                this.velocity.recycle();
                if (this.instant) {
                    this.instant.recycle();
                }
            }
        },
        
        publicMethods: {
        }
    });
}());

//##############################################################################
// Mover.js
//##############################################################################

/**
 * This component handles entity motion via velocity and acceleration changes. This is useful for directional movement, gravity, bounce-back collision reactions, jumping, etc.
 *
 * @namespace platypus.components
 * @class Mover
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector'),
        tempVector = Vector.setUp(),
        updateMax   = function (delta, interim, goal, time) {
            if (delta && (interim !== goal)) {
                if (interim < goal) {
                    return Math.min(interim + delta * time, goal);
                } else {
                    return Math.max(interim - delta * time, goal);
                }
            }
            
            return interim;
        },
        clampNumber = function (v, d) {
            var mIn = this.maxMagnitudeInterim = updateMax(this.maxMagnitudeDelta, this.maxMagnitudeInterim, this.maxMagnitude, d);
            
            if (v.magnitude() > mIn) {
                v.normalize().multiply(mIn);
            }
        },
        clampObject = function (v, d) {
            var max = this.maxMagnitude,
                mD  = this.maxMagnitudeDelta,
                mIn = this.maxMagnitudeInterim;

            mIn.up    = updateMax(mD, mIn.up,    max.up,    d);
            mIn.right = updateMax(mD, mIn.right, max.right, d);
            mIn.down  = updateMax(mD, mIn.down,  max.down,  d);
            mIn.left  = updateMax(mD, mIn.left,  max.left,  d);
            
            if (v.x > 0) {
                if (v.x > mIn.right) {
                    v.x = mIn.right;
                }
            } else if (v.x < 0) {
                if (v.x < -mIn.left) {
                    v.x = -mIn.left;
                }
            }

            if (v.y > 0) {
                if (v.y > mIn.down) {
                    v.y = mIn.down;
                }
            } else if (v.y < 0) {
                if (v.y < -mIn.up) {
                    v.y = -mIn.up;
                }
            }
        };
        
    return platypus.createComponentClass({
        
        id: 'Mover',

        properties: {
            /** This is a normalized vector describing the direction the ground should face away from the entity.
             *
             * @property ground
             * @type Array|Vector
             * @default Vector(0, 1)
             */
            ground: [0, 1]
        },
        
        publicProperties: {
            /**
             * A list of key/value pairs describing vectors or vector-like objects describing acceleration and velocity on the entity. See the ["Motion"]("Motion"%20Component.html) component for properties.
             *
             * @property movers
             * @type Array
             * @default []
             */
            movers: [],
            
            /**
             * If specified, the property adds gravity motion to the entity.
             *
             * @property gravity
             * @type number|Array|Vector
             * @default: 0
             */
            gravity: 0,
            
            /**
             * If specified, the property adds jumping motion to the entity.
             *
             * @property jump
             * @type number|Array|Vector
             * @default: 0
             */
            jump: 0,
            
            /**
             * If specified, the property adds velocity to the entity.
             *
             * @property speed
             * @type number|Array|Vector
             * @default: 0
             */
            speed: 0,
            
            /**
             * This property determines how quickly velocity is dampened when the entity is not in a "grounded" state. This should be a value between 1 (no motion) and 0 (no drag).
             *
             * @property drag
             * @type number
             * @default 0.01
             */
            drag: 0.01,
            
            /**
             * This property determines how quickly velocity is dampened when the entity is in a "grounded" state. This should be a value between 1 (no motion) and 0 (no friction).
             *
             * @property friction
             * @type number
             * @default 0.06
             */
            friction: 0.06,
            
            /**
             * This property determines the maximum amount of velocity this entity can maintain. This can be a number or an object describing maximum velocity in a particular direction. For example:
             *
             *     {
             *         "up": 8,
             *         "right": 12,
             *         "down": 0.4,
             *         "left": 12
             *     }
             *
             * @property maxMagnitude
             * @type number|Object
             * @default Infinity
             */
            maxMagnitude: Infinity,
            
            /**
             * This property determines the rate of change to new maximum amount of velocities.
             *
             * @property maxMagnitudeDelta
             * @type number
             * @default 0
             */
            maxMagnitudeDelta: 0,
            
            /**
             * This property determines whether orientation changes should apply external velocities from pre-change momentum.
             *
             * @property reorientVelocities
             * @type Boolean
             * @default true
             */
            reorientVelocities: true
        },
        
        constructor: function () {
            var maxMagnitude = Infinity,
                max = this.maxMagnitude,
                thisState = this.owner.state;
            
            platypus.Vector.assign(this.owner, 'position',  'x',  'y',  'z');
            platypus.Vector.assign(this.owner, 'velocity', 'dx', 'dy', 'dz');

            this.position = this.owner.position;
            this.velocity = this.owner.velocity;
            this.lastVelocity = Vector.setUp(this.velocity);
            this.collision = null;
            
            this.pause = false;
            
            // Copy movers so we're not re-using mover definitions
            this.moversCopy = this.movers;
            this.movers = Array.setUp();

            this.velocityChanges = Array.setUp();
            this.velocityDirections = Array.setUp();

            this.ground = Vector.setUp(this.ground);
            
            this.state = thisState;
            thisState.set('grounded', false);
            
            Object.defineProperty(this.owner, "maxMagnitude", {
                get: function () {
                    return maxMagnitude;
                },
                set: function (max) {
                    if (typeof max === 'number') {
                        this.clamp = clampNumber;
                        maxMagnitude = max;
                        if (!this.maxMagnitudeDelta) {
                            this.maxMagnitudeInterim = max;
                        }
                    } else {
                        this.clamp = clampObject;
                        if (typeof maxMagnitude === 'number') {
                            maxMagnitude = {
                                up: maxMagnitude,
                                right: maxMagnitude,
                                down: maxMagnitude,
                                left: maxMagnitude
                            };
                        }
                        if (typeof max.up === 'number') {
                            maxMagnitude.up = max.up;
                        }
                        if (typeof max.right === 'number') {
                            maxMagnitude.right = max.right;
                        }
                        if (typeof max.down === 'number') {
                            maxMagnitude.down = max.down;
                        }
                        if (typeof max.left === 'number') {
                            maxMagnitude.left = max.left;
                        }

                        if (typeof this.maxMagnitudeInterim === 'number') {
                            if (this.maxMagnitudeDelta) {
                                this.maxMagnitudeInterim = {
                                    up: this.maxMagnitudeInterim,
                                    right: this.maxMagnitudeInterim,
                                    down: this.maxMagnitudeInterim,
                                    left: this.maxMagnitudeInterim
                                };
                            } else {
                                this.maxMagnitudeInterim = {
                                    up: maxMagnitude.up,
                                    right: maxMagnitude.right,
                                    down: maxMagnitude.down,
                                    left: maxMagnitude.left
                                };
                            }
                        } else if (!this.maxMagnitudeDelta) {
                            this.maxMagnitudeInterim.up    = maxMagnitude.up;
                            this.maxMagnitudeInterim.right = maxMagnitude.right;
                            this.maxMagnitudeInterim.down  = maxMagnitude.down;
                            this.maxMagnitudeInterim.left  = maxMagnitude.left;
                        }
                    }
                }.bind(this)
            });
            this.maxMagnitudeInterim = 0;
            this.maxMagnitude = max;
        },

        events: {
            /**
             * When a ["Motion"]("Motion"%20Component.html) component is added, this component adds it to its list of movers.
             *
             * @method 'component-added'
             * @param component {"Motion" Component} The motion to add as a mover on this entity.
             */
            "component-added": function (component) {
                if (component.type === 'Motion') {
                    this.movers.push(component);
                }
            },
            
            /**
             * When a ["Motion"]("Motion"%20Component.html) component is removed, this component removes it from its list of movers.
             *
             * @method 'component-removed'
             * @param component {"Motion" Component} The motion to remove as a mover from this entity.
             */
            "component-removed": function (component) {
                var i = 0;
                
                if (component.type === 'Motion') {
                    i = this.movers.indexOf(component);
                    if (i >= 0) {
                        this.movers.greenSplice(i);
                    }
                }
            },
            
            /**
             * This component listens for a "load" event before setting up its mover list.
             *
             * @method 'load'
             */
            "load": function () {
                var i = 0,
                    movs = this.moversCopy;
                
                delete this.moversCopy;
                for (i = 0; i < movs.length; i++) {
                    this.addMover(movs[i]);
                }
                
                this.externalForces = this.addMover({
                    velocity: [0, 0, 0],
                    orient: false
                }).velocity;
                
                // Set up speed property if supplied.
                if (this.speed) {
                    if (!isNaN(this.speed)) {
                        this.speed = [this.speed, 0, 0];
                    }
                    this.speed = this.addMover({
                        velocity: this.speed,
                        controlState: "moving"
                    }).velocity;
                }

                // Set up gravity property if supplied.
                if (this.gravity) {
                    if (!isNaN(this.gravity)) {
                        this.gravity = [0, this.gravity, 0];
                    }
                    this.gravity = this.addMover({
                        acceleration: this.gravity,
                        orient: false,
                        aliases: {
                            "gravitate": "control-acceleration"
                        }
                    }).acceleration;
                }
                
                // Set up jump property if supplied.
                if (this.jump) {
                    if (!isNaN(this.jump)) {
                        this.jump = [0, this.jump, 0];
                    }
                    this.jump = this.addMover({
                        velocity: this.jump,
                        instant: true,
                        controlState: "grounded",
                        state: "jumping",
                        instantSuccess: "just-jumped",
                        instantDecay: 0.2,
                        aliases: {
                            "jump": "instant-motion"
                        }
                    }).instant;
                }
            },
            
            /**
             * On each "handle-movement" event, this component moves the entity according to the list of movers on the entity.
             *
             * @method 'handle-movement'
             * @param tick {Object}
             * @param tick.delta {number} The amount of time in milliseconds since the last tick.
             * @since 0.6.8
             */
            "handle-movement": function (tick) {
                var delta    = tick.delta,
                    m        = null,
                    thisState = this.state,
                    vect     = null,
                    velocity = this.velocity,
                    position = this.position,
                    movers   = this.movers,
                    i        = movers.length;
                
                if (thisState.get('paused') || this.paused) {
                    return;
                }
                
                if (!velocity.equals(this.lastVelocity, 2)) {
                    this.externalForces.addVector(velocity).subtractVector(this.lastVelocity);
                }
                
                velocity.setXYZ(0, 0, 0);
                
                while (i--) {
                    m = movers[i].update(delta);
                    if (m) {
                        if (this.grounded) { // put this in here to match earlier behavior
                            if (movers[i].friction !== -1) {
                                m.multiply(1 - movers[i].friction);
                            } else {
                                m.multiply(1 - this.friction);
                            }
                        } else if (movers[i].drag !== -1) {
                            m.multiply(1 - movers[i].drag);
                        } else {
                            m.multiply(1 - this.drag);
                        }
                        velocity.add(m);
                    }
                }

                this.clamp(velocity, delta);
                this.lastVelocity.setVector(velocity);
                
                vect = Vector.setUp(velocity).multiply(delta);
                position.add(vect);
                vect.recycle();
                
                thisState.set('grounded', this.grounded);
                
                this.grounded = false;
            },
            
            /**
             * On receiving this message, this component stops all velocities along the axis of the collision direction and sets "grounded" to `true` if colliding with the ground.
             *
             * @method 'hit-solid'
             * @param collisionInfo {Object}
             * @param collisionInfo.direction {platypus.Vector} The direction of collision from the entity's position.
             */
            "hit-solid": function (collisionInfo) {
                var s = 0,
                    e = 0,
                    entityV = collisionInfo.entity && collisionInfo.entity.velocity,
                    direction = collisionInfo.direction,
                    add = true,
                    vc = this.velocityChanges,
                    vd = this.velocityDirections,
                    i = vc.length;
                
                if (direction.dot(this.ground) > 0) {
                    this.grounded = true;
                }

                s = this.velocity.scalarProjection(direction);
                if (s > 0) {
                    if (entityV) {
                        e = Math.max(entityV.scalarProjection(direction), 0);
                        if (e < s) {
                            s = e;
                        } else {
                            s = 0;
                        }
                    } else {
                        s = 0;
                    }
                    
                    while (i--) {
                        if ((s < vc[i]) && (vd[i].dot(direction) > 0)) {
                            vc[i] = s;
                            vd[i].setVector(direction);
                            add = false;
                            break;
                        }
                    }
                    
                    if (add) {
                        vc.push(s);
                        vd.push(Vector.setUp(direction));
                    }
                }
            },
            
            "handle-post-collision-logic": function () {
                var direction = null,
                    ms = this.movers,
                    vc = this.velocityChanges,
                    vd = this.velocityDirections,
                    i = vc.length,
                    j = ms.length,
                    m = null,
                    s = 0,
                    sdi = 0,
                    soc = null,
                    v = tempVector;
                
                if (i) {
                    soc = Array.setUp();
                    
                    while (j--) {
                        m = ms[j];
                        if (m.stopOnCollision) {
                            soc.push(m);
                        }
                    }
                    
                    while (i--) {
                        direction = vd[i];
                        s = vc[i];
                        j = soc.length;
                        sdi = s / j;
                        while (j--) {
                            m = soc[j];
                            v.setVector(direction).normalize().multiply(sdi - m.velocity.scalarProjection(direction));
                            m.velocity.add(v);
                        }
                        direction.recycle();
                    }
                    
                    vc.length = 0;
                    vd.length = 0;
                }
            },
            
            /**
             * Update mover properties.
             *
             * @method 'set-mover'
             * @param mover {Object}
             * @param [mover.maxMagnitude] {Number|Object} New maximums for magnitude.
             * @param [mover.magnitude] {Number} Delta for the change in maximums.
             * @since 0.6.8
             */
            "set-mover": function (mover) {
                if (typeof mover.maxMagnitudeDelta === 'number') {
                    this.maxMagnitudeDelta = mover.maxMagnitudeDelta;
                }
                
                if (mover.maxMagnitude) {
                    this.maxMagnitude = mover.maxMagnitude;
                }
            },
            
            /**
             * Stops all movement on the Entity.
             *
             * @method 'pause-movment'
             * @since 0.6.8
             */
            "pause-movement": function () {
                this.paused = true;
            },
            
            /**
             * Unpauses all movement on the Entity.
             *
             * @method 'unpause-movment'
             * @since 0.6.8
             */
            "unpause-movement": function () {
                this.paused = false;
            },
            
            /**
             * Handles velocity change if velocities should not be re-oriented.
             *
             * @method 'orientation-updated'
             * @param matrix {Array} A 3x3 matrix describing the orientation change.
             * @since 0.7.3
             */
            "orientation-updated": function (matrix) {
                if (!this.reorientVelocities) {
                    this.lastVelocity.multiply(matrix);
                }
            }
        },
        
        methods: {
            destroy: function () {
                var i = 0,
                    max = this.maxMagnitude;
                
                for (i = this.movers.length - 1; i >= 0; i--) {
                    this.removeMover(this.movers[i]);
                }
                this.movers.recycle();
                this.ground.recycle();
                this.lastVelocity.recycle();
                this.velocityChanges.recycle();
                this.velocityDirections.recycle();
                
                delete this.owner.maxMagnitude; // remove property handlers
                this.owner.maxMagnitude = max;
                
                this.state = null;
            }
        },
        
        publicMethods: {
            /**
             * This method adds a mover to the entity in the form of a ["Motion"]("Motion"%20Component.html) component definition.
             *
             * @method addMover
             * @param mover {Object} For motion definition properties, see the ["Motion"]("Motion"%20Component.html) component.
             * @return motion {"Motion" Component}
             */
            addMover: function (mover) {
                var m = this.owner.addComponent(new platypus.components.Motion(this.owner, mover));

                return m;
            },
            
            /**
             * This method removes a mover from the entity.
             *
             * @method removeMover
             * @param motion {"Motion" Component}
             */
            removeMover: function (m) {
                this.owner.removeComponent(m);
            }
        }
    });
}());

//##############################################################################
// Node.js
//##############################################################################

/**
# COMPONENT **Node**
This component causes an entity to be a position on a [[NodeMap]]. This component should not be confused with `NodeResident` which should be used on entities that move around on a NodeMap: `Node` simply represents a non-moving location on the NodeMap.
  
## JSON Definition
    {
      "type": "NodeResident",
      
      "nodeId": "city-hall",
      // Optional. The id of the node that this entity should start on. Uses the entity's nodeId property if not set here.
      
      "nodes": ['path','sidewalk','road'],
      // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.
      
      "shares": ['friends','neighbors','city-council-members'],
      // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity cannot reside with any entities on the same node.
      
      "speed": 5,
      // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).
      
      "updateOrientation": true
      // Optional. Determines whether the entity's orientation is updated by movement across the NodeMap. Default is false.
    }
*/
/* global platypus */
(function () {
    'use strict';
    
    return platypus.createComponentClass({
        
        id: 'Node',
        
        publicProperties: {
            x: 0,
            y: 0,
            z: 0
        },
        
        constructor: function (definition) {
            this.nodeId = definition.nodeId || this.owner.nodeId || this.owner.id || String(Math.random());
            
            if ((typeof this.nodeId !== 'string') && (this.nodeId.length)) {
                this.nodeId = definition.nodeId.join('|');
            }
            
            this.owner.nodeId = this.nodeId;
            
            this.owner.isNode = true;
            this.map = this.owner.map = this.owner.map || null;
            this.contains = this.owner.contains = Array.setUp();
            this.edgesContain = this.owner.edgesContain = Array.setUp();
            
            platypus.Vector.assign(this.owner, 'position', 'x', 'y', 'z');
            
            this.neighbors = this.owner.neighbors = definition.neighbors || this.owner.neighbors || {};
        },
        
        events: {
            "add-neighbors": function (neighbors) {
                var i = 0,
                    direction = null;
                
                for (direction in neighbors) {
                    if (neighbors.hasOwnProperty(direction)) {
                        this.neighbors[direction] = neighbors[direction];
                    }
                }
                
                for (i = 0; i < this.contains.length; i++) {
                    this.contains[i].triggerEvent('set-directions');
                }
            },
            "remove-neighbor": function (nodeOrNodeId) {
                var i  = null,
                    id = nodeOrNodeId;
                
                if (typeof id !== 'string') {
                    id = id.nodeId;
                }

                for (i in this.neighbors) {
                    if (this.neighbors.hasOwnProperty(i)) {
                        if (typeof this.neighbors[i] === 'string') {
                            if (this.neighbors[i] === id) {
                                delete this.neighbors[i];
                                break;
                            }
                        } else if (this.neighbors[i].nodeId === id) {
                            delete this.neighbors[i];
                            break;
                        }
                    }
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.contains.recycle();
                this.edgesContain.recycle();
            }
        },
        
        publicMethods: {
            getNode: function (desc) {
                var neighbor = null;
                
                //map check
                if (!this.map && this.owner.map) {
                    this.map = this.owner.map;
                }
                
                if (this.neighbors[desc]) {
                    neighbor = this.neighbors[desc];
                    if (neighbor.isNode) {
                        return neighbor;
                    } else if (typeof neighbor === 'string') {
                        neighbor = this.map.getNode(neighbor);
                        if (neighbor) {
                            this.neighbors[desc] = neighbor;
                            return neighbor;
                        }
                    } else if (neighbor.length) {
                        neighbor = this.map.getNode(neighbor.join('|'));
                        if (neighbor) {
                            this.neighbors[desc] = neighbor;
                            return neighbor;
                        }
                    }
                    return null;
                } else {
                    return null;
                }
            },
            addToNode: function (entity) {
                var i = 0;
                
                for (i = 0; i < this.contains.length; i++) {
                    if (this.contains[i] === entity) {
                        return false;
                    }
                }
                this.contains.push(entity);
                return entity;
            },
            removeFromNode: function (entity) {
                var i = 0;
                
                for (i = 0; i < this.contains.length; i++) {
                    if (this.contains[i] === entity) {
                        return this.contains.greenSplice(i);
                    }
                }
                return false;
            },
            addToEdge: function (entity) {
                var i = 0;
                
                for (i = 0; i < this.edgesContain.length; i++) {
                    if (this.edgesContain[i] === entity) {
                        return false;
                    }
                }
                this.edgesContain.push(entity);
                return entity;
            },
            removeFromEdge: function (entity) {
                var i = 0;
                
                for (i = 0; i < this.edgesContain.length; i++) {
                    if (this.edgesContain[i] === entity) {
                        return this.edgesContain.greenSplice(i);
                    }
                }
                return false;
            }
        }
    });
}());

//##############################################################################
// NodeMap.js
//##############################################################################

/**
 * This component sets up a NodeMap to be used by the [NodeResident](platypus.components.NodeResident.html) component on this entity's child entities.
 *
 * @namespace platypus.components
 * @class NodeMap
 * @uses platypus.Component
 */
/* global include, platypus, recycle, springroll */
(function () {
    'use strict';
    
    var Vector = include('platypus.Vector'),
        Node = function (definition, map) { // This is a basic node object, but can be replaced by entities having a `Node` component if more functionality is needed.
            if (definition.id) {
                if (typeof definition.id === 'string') {
                    this.id = definition.id;
                } else if (Array.isArray(definition.id)) {
                    this.id = definition.id.join('|');
                } else {
                    this.id = String(Math.random());
                }
            } else {
                this.id = String(Math.random());
            }

            this.isNode = true;
            this.map = map;
            this.contains = Array.setUp();
            this.type = definition.type || '';
            this.x = definition.x || 0;
            this.y = definition.y || 0;
            this.z = definition.z || 0;

            this.neighbors = definition.neighbors || {};
        },
        proto = Node.prototype;
    
    proto.getNode = function (desc) {
        var neighbor = null;
        
        if (this.neighbors[desc]) {
            neighbor = this.neighbors[desc];
            if (neighbor.isNode) {
                return neighbor;
            } else if (typeof neighbor === 'string') {
                neighbor = this.map.getNode(neighbor);
                if (neighbor) {
                    this.neighbors[desc] = neighbor;
                    return neighbor;
                }
            } else if (Array.isArray(neighbor)) {
                neighbor = this.map.getNode(neighbor.join('|'));
                if (neighbor) {
                    this.neighbors[desc] = neighbor;
                    return neighbor;
                }
            }
            return null;
        } else {
            return null;
        }
    };

    proto.add = function (entity) {
        var i = 0;
        
        for (i = 0; i < this.contains.length; i++) {
            if (this.contains[i] === entity) {
                return false;
            }
        }
        this.contains.push(entity);
        return entity;
    };
    
    proto.remove = function (entity) {
        var i = 0;
        
        for (i = 0; i < this.contains.length; i++) {
            if (this.contains[i] === entity) {
                return this.contains.greenSplice(i);
            }
        }
        return false;
    };
    
    proto.recycle = function () {
        this.contains.recycle();
        this.recycle();
    };
    
    recycle.add(Node, !!springroll.Debug, 'Node');
    
    return platypus.createComponentClass({
        id: 'NodeMap',
        
        publicProperties: {
            /**
             * An array of node definitions to create the NodeMap. A node definition can take the following form:
             *
             *         {
             *           "NodeId": "Node1",
             *           // A string or array that becomes the id of the Node. Arrays are joined using "|" to create the id string.
             *           "type": "path",
             *           // A string that determines the type of the node.
             *           "x": 0,
             *           // Sets the x axis position of the node.
             *           "y": 0,
             *           // Sets the y axis position of the node.
             *           "z": 0,
             *           // Sets the z axis position of the node.
             *           "neighbors": {
             *           // A list of key/value pairs where the keys are directions from the node and values are node ids.
             *             "west": "node0",
             *             "east": "node2"
             *           }
             *         }
             *
             * @property map
             * @type Array
             * @default []
             */
            map: []
        },
        
        constructor: function () {
            var i   = 0,
                map = this.map;
            
            this.map   = Array.setUp(); // Original map is node definitions, so we replace it with actual nodes.
            this.nodes = {};
            this.residentsAwaitingNode = Array.setUp();
            
            for (i = 0; i < map.length; i++) {
                this.addNode(Node.setUp(map[i], this));
            }
        },

        events: {
            /**
             * Expects a node definition to create a node in the NodeMap.
             *
             * @method 'add-node'
             * @param definition {Object} Key/value pairs.
             * @param definition.nodeId {String|Array} This value becomes the id of the Node. Arrays are joined using "|" to create the id string.
             * @param definition.type {String} This determines the type of the node.
             * @param definition.x {String} Sets the x axis position of the node.
             * @param definition.y {String} Sets the y axis position of the node.
             * @param definition.z {String} Sets the z axis position of the node.
             * @param definition.neighbors {Object} A list of key/value pairs where the keys are directions from the node and values are node ids. For example: {"west": "node12"}.
             */
            "add-node": function (nodeDefinition) {
                var i = 0,
                    entity = null,
                    node   = null;
                
                if (nodeDefinition.isNode) {// if it's already a node, put it on the map.
                    node = nodeDefinition;
                    nodeDefinition.map = this;
                } else {
                    node = Node.setUp(nodeDefinition, this);
                }
                
                this.addNode(node);
                
                for (i = this.residentsAwaitingNode.length - 1; i >= 0; i--) {
                    entity = this.residentsAwaitingNode[i];
                    if (node.id === entity.nodeId) {
                        this.residentsAwaitingNode.greenSplice(i);
                        entity.node = this.getNode(entity.nodeId);
                        entity.triggerEvent('on-node', entity.node);
                    }
                }
            },

            /**
             * Checks the child entity for a nodeId and if found adds the child to the corresponding node.
             *
             * @method 'child-entity-added'
             * @param entity {platypus.Entity} The entity that may be placed on a node, or if the entity is a node it is added to the map of nodes.
             */
            "child-entity-added": function (entity) {
                if (entity.isNode) {        // a node
                    this.owner.triggerEvent('add-node', entity);
                } else if (entity.nodeId) { // a NodeResident
                    entity.node = this.getNode(entity.nodeId);
                    if (!entity.node) {
                        this.residentsAwaitingNode.push(entity);
                    } else {
                        entity.triggerEvent('on-node', entity.node);
                    }
                }
            }
        },
        
        methods: {
            addNode: function (node) {
                this.map.push(node);
                this.nodes[node.id] = node;
            },
            
            destroy: function () {
                var i = 0;
                
                // Destroy simple node objects.
                for (i = 0; i < this.map.length; i++) {
                    if (!(this.map[i] instanceof platypus.Entity)) {
                        this.map[i].recycle();
                    }
                }
                
                this.map.recycle();
                this.residentsAwaitingNode.recycle();
            }
        },
        
        publicMethods: {
            /**
             * Gets a node by node id.
             *
             * @method getNode
             * @param id {String|Array|Node} This id of the node to retrieve. If an array or more than one parameter is supplied, values are concatenated with "|" to create a single string id. Supplying a node returns the same node (useful for processing a mixed list of nodes and node ids).
             */
            getNode: function () {
                var i       = 0,
                    id      = '',
                    divider = '',
                    args    = arguments;
                
                if (args.length === 1) {
                    if (args[0].isNode) {
                        return args[0];
                    } else if (Array.isArray(args[0])) {
                        args = args[0];
                    }
                }
                
                for (i = 0; i < args.length; i++) {
                    id += divider + args[i];
                    divider = '|';
                }

                return this.nodes[id] || null;
            },
            
            /**
             * Finds the closest node to a given point, with respect to any inclusion or exclusion lists.
             *
             * method getClosestNode
             * @param point {platypus.Vector} A location for which a closest node is being found.
             * @param [including] {Array} A list of nodes to include in the search. If not set, the entire map is searched.
             * @param [excluding] {Array} A list of nodes to exclude from the search.
             */
            getClosestNode: function (point, including, excluding) {
                var i = 0,
                    j = 0,
                    p1 = Vector.setUp(point),
                    p2 = Vector.setUp(),
                    m = 0,
                    list = including || this.map,
                    closest = null,
                    d = Infinity;
                
                for (i = 0; i < list.length; i++) {
                    m = p2.setVector(p1).subtractVector(list[i].position).magnitude();
                    if (m < d) {
                        if (excluding) {
                            j = excluding.indexOf(list[i]);
                            if (j >= 0) {
                                break;
                            }
                        }
                        
                        d = m;
                        closest = list[i];
                    }
                }
                
                p1.recycle();
                p2.recycle();
                
                return closest;
            }
        }
    });
}());

//##############################################################################
// NodeResident.js
//##############################################################################

/**
# COMPONENT **NodeResident**
This component connects an entity to its parent's [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.

## Dependencies
- [[NodeMap]] (on entity's parent) - This component uses the `NodeMap` to determine its location and navigate to other nodes.
- [[HandlerLogic]] (on entity's parent) - This component listens for a logic tick message to maintain and update its location.

## Messages

### Listens for:
- **handle-logic** - On a `tick` logic message, the component updates its location and triggers messages regarding its neighbors.
  - @param message.delta (Number) - This component uses the current time to determine its progress along an edge if moving from node to node on the map.
- **on-node** - Sets the entity's position to the sent node, updates its coordinates, and triggers messages regarding its neighbors if any.
  - @param node (Node) - The node that this entity should be located on.
- **leave-node** - Removes the entity from its current node if it's on one.
- **goto-node** - Begins moving the entity along edges to get to sent node.
  - @param node (Node) - The node that this entity should move to.
- **follow** - Causes this entity to follow another entity. The leading entity must also have a `NodeResident` component and exist in the NodeMap.
  - @param entity (Entity) - The entity that this entity should follow.

### Local Broadcasts:
- **next-to-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all neighboring entities, as well as on itself on behalf of neighboring entities.
  - @param entity (Entity) - The entity that is next to the listening entity.
- **with-[entity-type]** - This message is triggered when the entity is placed on a node. It will trigger on all entities residing on the same node, as well as on itself on behalf of all resident entities.
  - @param entity (Entity) - The entity that is with the listening entity.
- **left-node** - Triggered when the entity leaves a node.
  - @param node (Node) - The node that the entity just left.
- **[Messages specified in definition]** - When the entity is placed on a node, it checks out the type of node and triggers a message on the entity if an event is listed for the current node type.

## States
- **on-node** - This state is true when the entity is on a node.
- **moving** - This state is true when the entity is moving from one node to another.
- **going-[direction]** - This state is true when the entity is moving (or has just moved) in a direction (determined by the NodeMap) from one node to another.
  
## JSON Definition
    {
      "type": "NodeResident",
      
      "nodeId": "city-hall",
      // Optional. The id of the node that this entity should start on. Uses the entity's nodeId property if not set here.
      
      "nodes": {"path": "walking", "sidewalk": "walking", "road": "driving"],
      // Optional. This is a list of node types that this entity can reside on. If not set, entity can reside on any type of node.
      
      "shares": ['friends','neighbors','city-council-members'],
      // Optional. This is a list of entities that this entity can reside with on the same node. If not set, this entity can reside with any entities on the same node.
      
      "speed": 5,
      // Optional. Sets the speed with which the entity moves along an edge to an adjacent node. Default is 0 (instantaneous movement).
      
      "updateOrientation": true
      // Optional. Determines whether the entity's orientation is updated by movement across the NodeMap. Default is false.
    }
*/

/**
 * This component connects an entity to its parent's [[NodeMap]]. It manages navigating the NodeMap and triggering events on the entity related to its position.
 *
 * @namespace platypus.components
 * @class NodeResident
 * @uses platypus.Component
 */
/* global platypus */
(function () {
    'use strict';
    
    var createGateway = function (nodeDefinition, map, gateway) {
            return function () {
                // ensure it's a node if one is available at this gateway
                var node = map.getNode(nodeDefinition);

                if (this.isPassable(node)) {
                    this.destinationNodes.length = 0;
                    this.destinationNodes.push(node);

                    if (this.node) {
                        this.onEdge(node);
                    } else {
                        this.distance = 0;
                    }
                    this.progress = 0;

                    this.setState('going-' + gateway);
                    return true;
                }

                return false;
            };
        },
        distance = function (origin, destination) {
            var x = destination.x - origin.x,
                y = destination.y - origin.y,
                z = destination.z - origin.z;

            return Math.sqrt(x * x + y * y + z * z);
        },
        angle = function (origin, destination, distance, ratio) {
            var x = destination.x - origin.x,
                y = destination.y - origin.y,
                a = 0;

            if (origin.rotation && destination.rotation) {
                x = (origin.rotation + 180) % 360;
                y = (destination.rotation + 180) % 360;
                return (x * (1 - ratio) + y * ratio + 180) % 360;
            } else {
                if (!distance) {
                    return a;
                }

                a = Math.acos(x / distance);
                if (y < 0) {
                    a = (Math.PI * 2) - a;
                }
                return a * 180 / Math.PI;
            }
        },
        axisProgress = function (r, o, d, f) {
            return o * (1 - r) + d * r + f;
        },
        isFriendly = function (entities, kinds) {
            var x = 0,
                y = 0,
                found = false;

            if (kinds === null) {
                return true;
            }

            for (x = 0; x < entities.length; x++) {
                for (y = 0; y < kinds.length; y++) {
                    if (entities[x].type === kinds[y]) {
                        found = true;
                    }
                }
                if (!found) {
                    return false;
                } else {
                    found = false;
                }
            }

            return true;
        };

    return platypus.createComponentClass({
        
        id: 'NodeResident',
        
        publicProperties: {

            /**
             * This describes the rate at which a node resident should progress along an edge to another node. This property is set on the entity itself and can be manipulated in real-time.
             *
             * @property speed
             * @type Number
             * @default 0
             */
            speed: 0
        },
        
        constructor: function (definition) {
            var offset = definition.offset || this.owner.nodeOffset || {};
            
            this.nodeId = this.owner.nodeId = definition.nodeId || this.owner.nodeId;
            
            this.neighbors = {};
            this.friendlyNodes = definition.nodes || null;
            this.friendlyEntities = definition.shares || null;
            this.snapToNodes = definition.snapToNodes || false;
            this.updateOrientation = definition.updateOrientation || false;
            this.distance = 0;
            this.buffer   = definition.buffer || 0;
            this.progress = 0;
            this.offset = {
                x: offset.x || 0,
                y: offset.y || 0,
                z: offset.z || 0
            };
            this.destinationNodes = Array.setUp();
            this.algorithm = definition.algorithm || distance;
            
            this.state = this.owner.state;
            this.state.set('moving', false);
            this.state.set('on-node', false);
            this.currentState = '';
        },
        
        events: {
            "set-algorithm": function (algorithm) {
                this.algorithm = algorithm || distance;
            },
            "handle-logic": function (resp) {
                var i = 0,
                    ratio    = 0,
                    momentum = 0,
                    node     = null,
                    arr = null;
                
                if (!this.owner.node) {
                    arr = Array.setUp(this.owner.x, this.owner.y);
                    this.owner.triggerEvent('on-node', this.owner.parent.getClosestNode(arr));
                    arr.recycle();
                    
                    /**
                     * This event is triggered if the entity is placed on the map but not assigned a node. It is moved to the nearest node and "in-location" is triggered.
                     *
                     * @event 'in-location'
                     * @param entity {platypus.Entity} The entity that is in location.
                     */
                    this.owner.triggerEvent('in-location', this.owner);
                }

                if (this.followEntity) {
                    node = this.followEntity.node || this.followEntity;
                    if (node && node.isNode && (node !== this.node)) {
                        this.lag = 0;
                        this.state.set('moving', this.gotoNode());
                        if (this.followDistance) {
                            momentum = this.lag;
                        }
                    } else {
                        this.followEntity = null;
                    }
                } else {
                    momentum = this.speed * resp.delta;
                }

                // if goto-node was blocked, try again.
                if (this.blocked) {
                    this.blocked = false;
                    if (this.goingToNode) {
                        this.owner.triggerEvent('goto-closest-node', this.goingToNode);
                    }
                }
                
                if (this.destinationNodes.length) {
                    this.state.set('moving', (this.speed !== 0));
                    if (this.node) {
                        this.onEdge(this.destinationNodes[0]);
                    } else if (!this.lastNode) {
                        this.owner.triggerEvent('on-node', this.destinationNodes[0]);
                        this.destinationNodes.greenSplice(0);
                        if (!this.destinationNodes.length) {
                            this.state.set('moving', false);
                            return;
                        }
                    }
                    
                    if (this.snapToNodes) {
                        for (i = 0; i < this.destinationNodes.length; i++) {
                            this.owner.triggerEvent('on-node', this.destinationNodes[i]);
                        }
                        this.destinationNodes.length = 0;
                    } else {
                        while (this.destinationNodes.length && momentum) {
                            if ((this.progress + momentum) >= this.distance) {
                                node = this.destinationNodes[0];
                                momentum -= (this.distance - this.progress);
                                this.progress = 0;
                                this.destinationNodes.greenSplice(0);
                                this.owner.triggerEvent('on-node', node);
                                if (this.destinationNodes.length && momentum) {
                                    this.onEdge(this.destinationNodes[0]);
                                }
                            } else {
                                this.progress += momentum;
                                ratio = this.progress / this.distance;
                                this.owner.x = axisProgress(ratio, this.lastNode.x, this.destinationNodes[0].x, this.offset.x);
                                this.owner.y = axisProgress(ratio, this.lastNode.y, this.destinationNodes[0].y, this.offset.y);
                                this.owner.z = axisProgress(ratio, this.lastNode.z, this.destinationNodes[0].z, this.offset.z);
                                if (this.updateOrientation) {
                                    this.owner.rotation = angle(this.lastNode, this.destinationNodes[0], this.distance, ratio);
                                }
                                momentum = 0;
                            }
                        }
                    }
                } else {
                    this.state.set('moving', false);
                }
            },
            "on-node": function (node) {
                var j = 0,
                    entities = null;
                
                this.owner.node = this.node = node; //TODO: not sure if this needs to be accessible outside this component.
                this.node.removeFromEdge(this.owner);
                if (this.lastNode) {
                    this.lastNode.removeFromEdge(this.owner);
                }
                this.node.addToNode(this.owner);
                
                this.setState('on-node');
                
                this.owner.x = this.node.x + this.offset.x;
                this.owner.y = this.node.y + this.offset.y;
                this.owner.z = this.node.z + this.offset.z;
                if (this.updateOrientation && this.node.rotation) {
                    this.owner.rotation = this.node.rotation;
                }
                
                //add listeners for directions
                this.owner.triggerEvent('set-directions');
                
                //trigger mapped messages for node types
                if (this.friendlyNodes && this.friendlyNodes[node.type]) {
                    this.owner.trigger(this.friendlyNodes[node.type], node);
                }

                //trigger "with" events
                entities = node.contains;
                for (j = 0; j < entities.length; j++) {
                    if (this.owner !== entities[j]) {
                        entities[j].triggerEvent("with-" + this.owner.type, this.owner);
                        this.owner.triggerEvent("with-" + entities[j].type, entities[j]);
                    }
                }
            },
            "leave-node": function () {
                if (this.node) {
                    this.node.removeFromNode(this.owner);
                    this.owner.triggerEvent('left-node', this.node);
                    this.owner.triggerEvent('remove-directions');
                }
                this.lastNode = this.node;
                this.node = null;
            },
            "goto-node": function (node) {
                this.gotoNode(node);
            },
            "follow": function (entityOrNode) {
                if (entityOrNode.entity) {
                    this.followDistance = entityOrNode.distance;
                    this.followEntity = entityOrNode.entity;
                } else {
                    this.followDistance = 0;
                    this.followEntity = entityOrNode;
                }
            },
            "goto-closest-node": (function () {
                var checkList = function (here, list) {
                        var i = 0;

                        for (i = 0; i < list.length; i++) {
                            if (list[i] === here) {
                                return true;
                            }
                        }

                        return false;
                    },
                    checkType = function (here, type) {
                        return (here.type === type);
                    },
                    checkObjectType = function (here, node) {
                        return (here.type === node.type);
                    };
                
                return function (nodesOrNodeType) {
                    var travResp = null,
                        depth    = 20, //arbitrary limit
                        origin   = this.node || this.lastNode,
                        test     = null,
                        steps    = nodesOrNodeType.steps || 0,
                        nodes    = null;

                    this.goingToNode = nodesOrNodeType;
                    
                    if (typeof nodesOrNodeType === 'string') {
                        test = checkType;
                    } else if (typeof nodesOrNodeType.type === 'string') {
                        test = checkObjectType;
                    } else {
                        test = checkList;
                    }
                    
                    if (origin && nodesOrNodeType && !test(origin, nodesOrNodeType)) {
                        nodes = Array.setUp();
                        travResp = this.traverseNode({
                            depth: depth,
                            origin: origin,
                            position: origin,
                            test: test,
                            destination: nodesOrNodeType,
                            nodes: nodes,
                            shortestPath: Infinity,
                            distance: 0,
                            found: false,
                            algorithm: this.algorithm,
                            blocked: false
                        });
                        
                        travResp.distance -= this.progress;
                        
                        if (travResp.found) {
                            //TODO: should probably set this up apart from this containing function
                            if (this.followEntity) {
                                if (!this.followDistance) {
                                    this.setPath(travResp, steps);
                                } else if ((travResp.distance + (this.followEntity.progress || 0)) > this.followDistance) {
                                    this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;
                                    this.setPath(travResp, steps);
                                } else {
                                    this.lag = 0;
                                }
                            } else {
                                this.setPath(travResp, steps);
                            }
                        } else if (travResp.blocked) {
                            this.blocked = true;
                        }
                        
                        nodes.recycle();
                    }
                };
            }()),
            "set-directions": function () {
                var i = '',
                    j = 0,
                    entities = null,
                    node     = this.node,
                    nextNode = null;
                
                this.owner.triggerEvent('remove-directions');
                
                for (i in node.neighbors) {
                    if (node.neighbors.hasOwnProperty(i)) {
                        this.neighbors[i] = createGateway(node.neighbors[i], node.map, i);
                        this.addEventListener(i, this.neighbors[i]);

                        //trigger "next-to" events
                        nextNode = node.map.getNode(node.neighbors[i]);
                        if (nextNode) {
                            entities = nextNode.contains;
                            for (j = 0; j < entities.length; j++) {
                                entities[j].triggerEvent("next-to-" + this.owner.type, this.owner);
                                this.owner.triggerEvent("next-to-" + entities[j].type, entities[j]);
                            }
                        }
                    }
                }
            },
            "remove-directions": function () {
                var i = '';
                
                for (i in this.neighbors) {
                    if (this.neighbors.hasOwnProperty(i)) {
                        this.removeEventListener(i, this.neighbors[i]);
                        delete this.neighbors[i];
                    }
                }
            }
        },
        
        methods: {
            gotoNode: (function () {
                var test = function (here, there) {
                    return (here === there);
                };
                
                return function (node) {
                    var travResp = null,
                        depth = 20, //arbitrary limit
                        origin = this.node || this.lastNode,
                        nodes = null,
                        moving = false;
                    
                    if (!node && this.followEntity) {
                        node = this.followEntity.node || this.followEntity.lastNode || this.followEntity;
                    }
                    
                    if (origin && node && (this.node !== node)) {
                        nodes = Array.setUp();
                        
                        travResp = this.traverseNode({
                            depth: depth,
                            origin: origin,
                            position: origin,
                            test: test,
                            destination: node,
                            nodes: nodes,
                            shortestPath: Infinity,
                            distance: 0,
                            found: false,
                            algorithm: this.algorithm,
                            blocked: false
                        });
                        
                        travResp.distance -= this.progress;
                        
                        if (travResp.found) {
                            //TODO: should probably set this up apart from this containing function
                            if (this.followEntity) {
                                if (!this.followDistance) {
                                    this.setPath(travResp);
                                    moving = true;
                                } else if ((travResp.distance + (this.followEntity.progress || 0)) > this.followDistance) {
                                    this.lag = travResp.distance + (this.followEntity.progress || 0) - this.followDistance;
                                    this.setPath(travResp);
                                    moving = true;
                                } else {
                                    this.lag = 0;
                                }
                            } else {
                                this.setPath(travResp);
                                moving = true;
                            }
                        } else if (travResp.blocked) {
                            this.blocked = true;
                        }
                        
                        nodes.recycle();
                    }
                    
                    return moving;
                };
            }()),
            
            isPassable: function (node) {
                return node && (this.node !== node) && (!this.friendlyNodes || (typeof this.friendlyNodes[node.type] !== 'undefined')) && (!node.contains.length || isFriendly(node.contains, this.friendlyEntities));
            },
            traverseNode: function (record) {
                //TODO: may want to make this use A*. Currently node traversal order is arbitrary and essentially searches entire graph, but does clip out paths that are too long.
                
                var i         = 1,
                    j         = '',
                    map       = record.position.map,
                    neighbors = null,
                    node      = null,
                    nodeList  = null,
                    resp      = null,
                    algorithm = record.algorithm || distance,
                    savedResp = {
                        shortestPath: Infinity,
                        found: false,
                        blocked: false
                    },
                    blocked   = true,
                    hasNeighbor = false;

                if ((record.depth === 0) || (record.distance > record.shortestPath)) {
                    // if we've reached our search depth or are following a path longer than our recorded successful distance, bail
                    return record;
                } else if (record.test(record.position, record.destination)) {
                    // if we've reached our destination, set shortest path information and bail.
                    record.found = true;
                    record.shortestPath = record.distance;
                    return record;
                } else {
                    //Make sure we do not trace an infinite node loop.
                    nodeList = record.nodes;
                    for (i = 1; i < nodeList.length - 1; i++) {
                        if (nodeList[i] === record.position) {
                            return record;
                        }
                    }
                        
                    neighbors = record.position.neighbors;
                    for (j in neighbors) {
                        if (neighbors.hasOwnProperty(j)) {
                            node = map.getNode(neighbors[j]);
                            hasNeighbor = true;
                            if (this.isPassable(node)) {
                                nodeList = record.nodes.greenSlice();
                                nodeList.push(node);
                                resp = this.traverseNode({
                                    depth: record.depth - 1,
                                    origin: record.origin,
                                    position: node,
                                    destination: record.destination,
                                    test: record.test,
                                    algorithm: algorithm,
                                    nodes: nodeList,
                                    shortestPath: record.shortestPath,
                                    distance: record.distance + algorithm(record.position, node),
                                    gateway: record.gateway || j,
                                    found: false,
                                    blocked: false
                                });
                                nodeList.recycle();
                                if (resp.found && (savedResp.shortestPath > resp.shortestPath)) {
                                    savedResp = resp;
                                }
                                blocked = false;
                            }
                        }
                    }
                    savedResp.blocked = (hasNeighbor && blocked);
                    return savedResp;
                }
            },
            setPath: function (resp, steps) {
                if (resp.nodes[0] === this.node) {
                    resp.nodes.greenSplice(0);
                }
                this.destinationNodes.recycle();
                this.destinationNodes = resp.nodes.greenSlice();
                if (steps) {
                    this.destinationNodes.length = Math.min(steps, this.destinationNodes.length);
                }
            },
            setState: function (state) {
                if (state === 'on-node') {
                    this.state.set('on-node', true);
                } else {
                    this.state.set('on-node', false);
                    if (this.currentState) {
                        this.state.set(this.currentState, false);
                    }
                    this.currentState = state;
                    this.state.set(state, true);
                }
            },
            onEdge: function (toNode) {
                this.distance = distance(this.node, toNode);
                if (this.updateOrientation) {
                    this.owner.rotation = angle(this.node, toNode, this.distance, this.progress / this.distance);
                }
                this.node.addToEdge(this.owner);
                toNode.addToEdge(this.owner);
                this.owner.triggerEvent('leave-node');
            },
            destroy: function () {
                this.destinationNodes.recycle();
                this.state = null;
            }
        }
    });
}());

//##############################################################################
// Orientation.js
//##############################################################################

/**
 * This component handles the orientation of an entity. It maintains an `orientationMatrix` property on the owner to describe the entity's orientation using an affine transformation matrix.
 *
 * Several methods on this component accept either a 3x3 2D Array or a string to describe orientation changes. Accepted strings include:
 *  - "horizontal"       - This flips the entity around the y-axis.
 *  - "vertical"         - This flips the entity around the x-axis.
 *  - "diagonal"         - This flips the entity around the x=y axis.
 *  - "diagonal-inverse" - This flips the entity around the x=-y axis.
 *  - "rotate-90"        - This rotates the entity 90 degrees clockwise.
 *  - "rotate-180"       - This rotates the entity 180 degrees clockwise (noticeable when tweening).
 *  - "rotate-270"       - This rotates the entity 90 degrees counter-clockwise.
 *
 * NOTE: This component absorbs specific properties already on the entity into orientation:
 *  - **orientationMatrix**: 3x3 2D array describing an affine transformation.
 *  - If the above is not provided, these properties are used to set initial orientation. This is useful when importing Tiled maps.
 *     - **scaleX**: absorb -1 if described
 *     - **scaleY**: absorb -1 if described
 *     - **rotation**: absorb 90 degree rotations
 *
 * @namespace platypus.components
 * @class Orientation
 * @uses platypus.Component
 */
/* global platypus, include */
(function () {
    'use strict';
    
    var Data = include('platypus.Data'),
        Vector = include('platypus.Vector'),
        normal = Vector.setUp(0, 0, 1),
        origin = Vector.setUp(1, 0, 0),
        matrices = {
            'horizontal': [[ -1,  0,  0],
                           [  0,  1,  0],
                           [  0,  0, -1]],
            'vertical': [[  1,  0,  0],
                         [  0, -1,  0],
                         [  0,  0, -1]],
            'diagonal': [[  0,  1,  0],
                         [  1,  0,  0],
                         [  0,  0, -1]],
            'diagonal-inverse': [[  0, -1,  0],
                                 [ -1,  0,  0],
                                 [  0,  0, -1]],
            'rotate-90': [[  0, -1,  0],
                          [  1,  0,  0],
                          [  0,  0,  1]],
            'rotate-180': [[ -1,  0,  0],
                           [  0, -1,  0],
                           [  0,  0,  1]],
            'rotate-270': [[  0,  1,  0],
                           [ -1,  0,  0],
                           [  0,  0,  1]]
        },
        multiply = (function () {
            var cell = function (row, column, m) {
                var i = 0,
                    sum = 0;

                for (i = 0; i < row.length; i++) {
                    sum += row[i] * m[i][column];
                }

                return sum;
            };

            return function (a, b, dest) {
                var i   = 0,
                    j   = 0,
                    arr = Array.setUp();

                for (i = 0; i < a.length; i++) {
                    for (j = 0; j < a[0].length; j++) {
                        arr.push(cell(a[i], j, b));
                    }
                }

                for (i = 0; i < a.length; i++) {
                    for (j = 0; j < a[0].length; j++) {
                        dest[i][j] = arr.greenSplice(0);
                    }
                }
                
                arr.recycle();
            };
        }()),
        identitize = function (m) {
            var i = 0,
                j = 0;

            for (i = 0; i < 3; i++) {
                for (j = 0; j < 3; j++) {
                    if (i === j) {
                        m[i][j] = 1;
                    } else {
                        m[i][j] = 0;
                    }
                }
            }

            return m;
        };
    
    return platypus.createComponentClass({
        id: 'Orientation',
        publicProperties: {
            /**
             * The Entity's scale along the X-axis will mirror the entity's initial orientation if it is negative. This value is available via `entity.scaleX`, but is not manipulated by this component after instantiation.
             *
             * @property scaleX
             * @type number
             * @default 1
             */
            "scaleX": 1,

            /**
             * The Entity's scale along the Y-axis will flip the entity's initial orientation if it is negative. This value is available via `entity.scaleY`, but is not manipulated by this component after instantiation.
             *
             * @property scaleY
             * @type number
             * @default 1
             */
            "scaleY": 1,

            /**
             * The Entity's rotation will rotate entity's initial orientation if it is a multiple of 90 degrees. This value is available via `entity.rotation`, but is not manipulated by this component after instantiation.
             *
             * @property rotation
             * @type number
             * @default 0
             */
            "rotation": 0,

            /**
             * The Entity's orientation is an angle in radians describing an entity's orientation around the Z-axis. This property is affected by a changing `entity.orientationMatrix` but does not itself change the orientation matrix.
             *
             * @property orientation
             * @type number
             * @default 0
             */
            "orientation": 0,
            
            /**
             * The entity's orientation matrix determines the orientation of an entity and its vectors. It's a 3x3 2D Array describing an affine transformation of the entity.
             *
             * @property orientationMatrix
             * @type Array
             * @default 3x3 identity matrix
             */
            "orientationMatrix": null
        },
        constructor: (function () {
            var setupOrientation = function (self, orientation) {
                var vector = Vector.setUp(1, 0, 0),
                    owner  = self.owner,
                    matrix = Array.setUp(
                        Array.setUp(1, 0, 0),
                        Array.setUp(0, 1, 0),
                        Array.setUp(0, 0, 1)
                    );
                
                Object.defineProperty(owner, 'orientationMatrix', {
                    get: function () {
                        multiply(self.matrixTween, self.matrix, identitize(matrix));
                        return matrix;
                    },
                    enumerable: true
                });

                delete owner.orientation;
                Object.defineProperty(owner, 'orientation', {
                    get: function () {
                        return vector.signedAngleTo(origin, normal);
                    },
                    set: function (value) {
                        vector.setVector(origin).rotate(value);
                    },
                    enumerable: true
                });

                if (orientation) {
                    if (typeof orientation !== 'number') {
                        vector.set(orientation);
                    } else {
                        vector.rotate(orientation);
                    }
                }

                return vector;
            };
            
            return function () {
                this.loadedOrientationMatrix = this.orientationMatrix;
                
                // This is the stationary transform
                this.matrix = Array.setUp(
                    Array.setUp(1, 0, 0),
                    Array.setUp(0, 1, 0),
                    Array.setUp(0, 0, 1)
                );
                
                // This is the tweening transform
                this.matrixTween = Array.setUp(
                    Array.setUp(1, 0, 0),
                    Array.setUp(0, 1, 0),
                    Array.setUp(0, 0, 1)
                );
                
                this.relocationMessage = Data.setUp(
                    "position", null
                );
                
                this.vectors  = Array.setUp();
                this.inverses = Array.setUp();
                this.tweens   = Array.setUp();
                
                this.orientationVector = setupOrientation(this, this.orientation);
                this.owner.triggerEvent('orient-vector', this.orientationVector);
                
                this.owner.state.set('reorienting', false);
            };
        }()),

        events: {
            /**
             * This component listens for this event prior to loading initial transformations.
             *
             * @method 'load'
             */
            "load": function () {
                if (this.loadedOrientationMatrix) {
                    this.transform(this.loadedOrientationMatrix);
                } else {
                    if (this.scaleX && this.scaleX < 0) {
                        this.scaleX = -this.scaleX;
                        this.transform('horizontal');
                    }
                    if (this.scaleY && this.scaleY < 0) {
                        this.scaleY = -this.scaleY;
                        this.transform('vertical');
                    }
                    if (this.rotation) {
                        if (((this.rotation + 270) % 360) === 0) {
                            this.rotation = 0;
                            this.transform('rotate-90');
                        } else if (((this.rotation + 180) % 360) === 0) {
                            this.rotation = 0;
                            this.transform('rotate-180');
                        } else if (((this.rotation + 90) % 360) === 0) {
                            this.rotation = 0;
                            this.transform('rotate-270');
                        }
                    }
                }
                delete this.loadedOrientationMatrix;
            },
            
            /**
             * On the 'handle-logic' event, this component updates any transformational tweening of the entity.
             *
             * @method 'handle-logic'
             * @param tick.delta {number} Time passed since the last logic step.
             */
            "handle-logic": function (tick) {
                var i = this.tweens.length,
                    delta = tick.delta,
                    state = this.owner.state,
                    finishedTweening = null,
                    tween = null,
                    msg = this.relocationMessage;
                
                if (i) {
                    finishedTweening = Array.setUp();
                    state.set('reorienting', true);
                    identitize(this.matrixTween);
                    
                    while (i--) {
                        if (this.updateTween(this.tweens[i], delta)) { // finished tweening
                            finishedTweening.push(this.tweens.greenSplice(i));
                        }
                    }
                    
                    i = this.vectors.length;
                    while (i--) {
                        this.updateVector(this.vectors[i], this.inverses[i]);
                    }
                    
                    i = finishedTweening.length;
                    while (i--) {
                        tween = finishedTweening[i];
                        this.transform(tween.endMatrix);
                        if (tween.anchor) {
                            tween.offset.multiply(tween.endMatrix).addVector(tween.anchor);
                            msg.position = tween.offset;
                            this.owner.triggerEvent('relocate-entity', msg);
                            if (tween.recycleOffset) {
                                tween.offset.recycle();
                            }
                        }
                        tween.onFinished(tween.endMatrix);
                        tween.recycle();
                    }
                    
                    finishedTweening.recycle();
                } else if (state.get('reorienting')) {
                    identitize(this.matrixTween);
                    state.set('reorienting', false);
                }
            },
            
            /**
             * On receiving this message, any currently running orientation tweens are immediately completed to give the entity a new stable position.
             *
             * @method 'complete-tweens'
             * @since 0.7.1
             */
            "complete-tweens": function () {
                var i = 0;
                
                for (i = 0; i < this.tweens.length; i++) {
                    this.tweens[i].time = this.tweens[i].endTime;
                }
            },
            
            /**
             * On receiving this message, any currently running orientation tweens are discarded, returning the entity to its last stable position.
             *
             * @method 'drop-tweens'
             */
            "drop-tweens": function () {
                var i = 0;
                
                i = this.tweens.length;
                while (i--) {
                    if (this.tweens[i].offset) {
                        this.tweens[i].offset.recycle();
                    }
                }
                this.tweens.length = 0;
                
                i = this.vectors.length;
                while (i--) {
                    this.updateVector(this.vectors[i], this.inverses[i]);
                }
            },
            
            /**
             * On receiving a vector via this event, the component will transform the vector using the current orientation matrix and then store the vector and continue manipulating it as the orientation matrix changes.
             *
             * @method 'orient-vector'
             * @param vector {platypus.Vector} The vector whose orientation will be maintained.
             */
            "orient-vector": function (vector) {
                var aligned = vector.aligned || false;
                
                if (vector.vector) {
                    vector = vector.vector;
                }
                
                if (this.vectors.indexOf(vector) === -1) {
                    if (!aligned) {
                        vector.multiply(this.matrix);
                    }
                    this.vectors.push(vector);
                    this.inverses.push(Vector.setUp());
                }
            },
            
            /**
             * On receiving this message, the maintained vector is immediately dropped from the list of maintained vectors.
             *
             * @method 'remove-vector'
             * @param vector {platypus.Vector} The vector to be removed.
             */
            "remove-vector": function (vector) {
                var i = this.vectors.indexOf(vector);
                
                if (i >= 0) {
                    this.vectors.greenSplice(i);
                    this.inverses.greenSplice(i).recycle();
                }
            },
            
            /**
             * This message causes the component to begin tweening the entity's orientation over a span of time into the new orientation.
             *
             * @method 'tween-transform'
             * @param options {Object} A list of key/value pairs describing the tween options.
             * @param options.matrix {Array} A transformation matrix: only required if `transform` is not provided
             * @param options.transform {String} A transformation type: only required if `matrix` is not provided.
             * @param options.time {number} The time over which the tween occurs. 0 makes it instantaneous.
             * @param [options.anchor] {platypus.Vector} The anchor of the orientation change. If not provided, the owner's position is used.
             * @param [options.offset] {platypus.Vector} If an anchor is supplied, this vector describes the entity's distance from the anchor. It defaults to the entity's current position relative to the anchor position.
             * @param [options.angle] {number} Angle in radians to transform. This is only valid for rotations and is derived from the transform if not provided.
             * @param [options.tween] {Function} A function describing the transition. Performs a linear transition by default. See CreateJS Ease for other options.
             * @param [options.beforeTick] {Function} A function that should be processed before each tick as the tween occurs. This function should return `true`, otherwise the tween doesn't take a step.
             * @param [options.afterTick] {Function} A function that should be processed after each tick as the tween occurs.
             * @param [options.onTick] {Function} Deprecated in favor of `beforeTick` and `afterTick`.
             * @param [options.onFinished] {Function} A function that should be run once the transition is complete.
             */
            "tween-transform": (function () {
                var doNothing = function () {
                        // Doing nothing!
                    },
                    returnTrue = function () {
                        return true;
                    },
                    linearEase = function (t) {
                        return t;
                    };

                return function (props) {
                    var arr = null,
                        angle  = props.angle || 0,
                        matrix = props.matrix,
                        tween  = Data.setUp(
                            "transform", props.transform,
                            "anchor", props.anchor,
                            "endTime", props.time || 0,
                            "time", 0,
                            "tween", props.tween || linearEase,
                            "onFinished", props.onFinished || doNothing,
                            "beforeTick", props.beforeTick || returnTrue,
                            "afterTick", props.onTick || props.afterTick || doNothing
                        );
                    
                    if (!matrix) {
                        matrix = matrices[props.transform];
                    }
                    tween.endMatrix = matrix;
                    
                    if (!angle && (props.transform.indexOf('rotate') === 0)) {
                        switch (props.transform) {
                        case 'rotate-90':
                            angle = Math.PI / 2;
                            break;
                        case 'rotate-180':
                            angle = Math.PI;
                            break;
                        case 'rotate-270':
                            angle = -Math.PI / 2;
                            break;
                        default:
                            arr = props.transform.greenSplit('-');
                            angle = (arr[1] / 180) * Math.PI;
                            arr.recycle();
                            break;
                        }
                    }
                    tween.angle = angle;
                    
                    if (props.anchor) {
                        tween.offset = props.offset;
                        if (!tween.offset) {
                            tween.offset = this.owner.position.copy().subtractVector(props.anchor, 2);
                            tween.recycleOffset = true;
                        }
                    }
                    
                    this.tweens.push(tween);
                };
            }()),
            
            /**
             * This message performs an immediate transform of the entity by performing the transformation via a prepended matrix multiplication.
             *
             * @method 'transform'
             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.
             */
            "transform": function (transform) {
                this.transform(transform);
            },
            
            /**
             * This message performs an immediate transform of the entity by performing the transformation via a prepended matrix multiplication.
             *
             * @method 'prepend-transform'
             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.
             */
            "prepend-transform": function (transform) {
                this.transform(transform);
            },
            
            /**
             * This message performs an immediate transform of the entity by performing the transformation via an appended matrix multiplication.
             *
             * @method 'append-transform'
             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.
             */
            "append-transform": function (transform) {
                this.transform(transform, true);
            },
            
            /**
             * This message performs an immediate transform of the entity by returning the entity to an identity transform before performing a matrix multiplication.
             *
             * @method 'replace-transform'
             * @param transform {Array|String} A 3x3 @D Array or a string describing a transformation.
             */
            "replace-transform": function (transform) {
                this.replace(transform);
            }
        },
        
        methods: {
            transform: function (transform, append) {
                if (Array.isArray(transform)) {
                    this.multiply(transform, append);
                } else if (typeof transform === 'string') {
                    if (matrices[transform]) {
                        this.multiply(matrices[transform], append);
                    }
                }
            },
            
            multiply: (function () {
                return function (m, append) {
                    var i = 0;
                    
                    if (append) {
                        multiply(this.matrix, m, this.matrix);
                    } else {
                        multiply(m, this.matrix, this.matrix);
                    }
                    
                    for (i = 0; i < this.vectors.length; i++) {
                        this.vectors[i].multiply(m);
                        this.inverses[i].multiply(m);
                    }
                    
                    /**
                     * Once a transform is complete, this event is triggered to notify the entity of the completed transformation.
                     *
                     * @event 'orientation-updated'
                     * @param matrix {Array} A 3x3 2D array describing the change in orientation.
                     */
                    this.owner.triggerEvent('orientation-updated', m);
                };
            }()),

            replace: (function () {
                var det2 = function (a, b, c, d) {
                        return a * d - b * c;
                    },
                    det3 = function (a) {
                        var i = 0,
                            sum = 0;

                        for (i = 0; i < 3; i++) {
                            sum += a[i][0] * a[(i + 1) % 3][1] * a[(i + 2) % 3][2];
                            sum -= a[i][2] * a[(i + 1) % 3][1] * a[(i + 2) % 3][0];
                        }
                        return sum;
                    },
                    invert = function (a) {
                        var arr = Array.setUp(Array.setUp(), Array.setUp(), Array.setUp()),
                            inv = 1 / det3(a);

                        arr[0].push(det2(a[1][1], a[1][2], a[2][1], a[2][2]) * inv);
                        arr[0].push(det2(a[0][2], a[0][1], a[2][2], a[2][1]) * inv);
                        arr[0].push(det2(a[0][1], a[0][2], a[1][1], a[1][2]) * inv);
                        arr[1].push(det2(a[1][2], a[1][0], a[2][2], a[2][0]) * inv);
                        arr[1].push(det2(a[0][0], a[0][2], a[2][0], a[2][2]) * inv);
                        arr[1].push(det2(a[0][2], a[0][0], a[1][2], a[1][0]) * inv);
                        arr[2].push(det2(a[1][0], a[1][1], a[2][0], a[2][1]) * inv);
                        arr[2].push(det2(a[0][1], a[0][0], a[2][1], a[2][0]) * inv);
                        arr[2].push(det2(a[0][0], a[0][1], a[1][0], a[1][1]) * inv);

                        return arr;
                    };
                
                return function (m) {
                    var inversion = invert(this.matrix);
                    
                    // We invert the matrix so we can re-orient all vectors for the incoming replacement matrix.
                    this.multiply(inversion);
                    this.multiply(m);
                    
                    // clean-up
                    inversion.recycle(2);
                };
            }()),
            
            updateTween: (function () {
                var getMid = function (a, b, t) {
                    return (a * (1 - t) + b * t);
                };
                
                return function (tween, delta) {
                    var t = 0,
                        a = 1,                //  a c -
                        b = 0,                //  b d -
                        c = 0,                //  - - z
                        d = 1,
                        z = 1,
                        angle = 0,
                        m = tween.endMatrix,
                        matrix = null,
                        initialOffset = null,
                        finalOffset = null;
                    
                    if (tween.beforeTick(tween.time)) {
                        tween.time += delta;
                    }
                    
                    if (tween.time >= tween.endTime) {
                        return true;
                    }
                    
                    t = tween.tween(tween.time / tween.endTime);
                    
                    if (tween.angle) {
                        angle = t * tween.angle;
                        a = d = Math.cos(angle);
                        b = Math.sin(angle);
                        c = -b;
                    } else {
                        a = getMid(a, m[0][0], t);
                        b = getMid(b, m[1][0], t);
                        c = getMid(c, m[0][1], t);
                        d = getMid(d, m[1][1], t);
                        z = getMid(z, m[2][2], t);
                    }
                    
                    matrix = Array.setUp(
                        Array.setUp(a, c, 0),
                        Array.setUp(b, d, 0),
                        Array.setUp(0, 0, z)
                    );

                    multiply(this.matrixTween, matrix, this.matrixTween);
                    
                    if (tween.anchor) {
                        initialOffset = Vector.setUp(tween.offset).multiply(1 - t);
                        finalOffset = Vector.setUp(tween.offset).multiply(t);
                        
                        this.owner.triggerEvent('relocate-entity', {
                            position: initialOffset.add(finalOffset).multiply(matrix).addVector(tween.anchor)
                        });
                        
                        initialOffset.recycle();
                        finalOffset.recycle();
                    }

                    tween.afterTick(t, matrix);
                    
                    matrix.recycle(2);
                    
                    return false;
                };
            }()),
            
            updateVector: function (vector, inverse) {
                inverse.setVector(vector.add(inverse)); // Inverses are stored to return to the original postion, *but* also allow outside changes on the vectors to be retained. This introduces floating point errors on tweened vectors. - DDD 2/10/2016
                vector.multiply(this.matrixTween);
                inverse.subtractVector(vector);
            },
            
            destroy: function () {
                this.vectors.recycle();
                this.inverses.recycle();
                this.tweens.recycle();
                this.orientationVector.recycle();
                this.orientationMatrix.recycle(2);
                this.matrix.recycle(2);
                this.matrixTween.recycle(2);
                this.relocationMessage.recycle();
            }
        }
    });
}());

//##############################################################################
// RandomEvents.js
//##############################################################################

/**
 * This component listens for certain messages, picks a message from a related list of events, and triggers it. This is useful for adding random behaviors to an entity, such as having an entity say one thing from a list of audio clips. For example, defining this component on an Entity may look like this:
 * 
 *     {
 *       "type": "RandomEvents",
 *       
 *       "events": {
 *       // This is a key/value list of events to listen for, with each event mapping to an array of events to pick from.
 *       
 *         "make-sound": ["scream", "whisper", "talk"]
 *         //on the component receiving the "make-sound" message, it will trigger one of the three possible messages listed here.
 *       }
 *     }
 *     
 * @namespace platypus.components
 * @class RandomEvents
 * @uses platypus.Component
*/
/*global platypus */
(function () {
    'use strict';

    var createTrigger = function (eventList) {
        return function (value, debug) {
            this.owner.trigger(eventList[Math.floor(Math.random() * eventList.length)], value, debug);
        };
    };

    return platypus.createComponentClass({
        id: 'RandomEvents',
        
        constructor: function (definition) {
            var event = '';
            
            if (definition.events) {
                for (event in definition.events) {
                    if (definition.events.hasOwnProperty(event)) {
                        this.addEventListener(event, createTrigger(definition.events[event]));
                    }
                }
            }
        }
    });
}());

//##############################################################################
// RelayFamily.js
//##############################################################################

/**
 * This component allows an entity to communicate directly with one or more entities via the message model, by passing local messages directly to entities in the same family as new triggered events. This component is placed on a single entity and all entities created by this entity become part of its "family".
 *
 * @namespace platypus.components
 * @class RelayFamily
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'RelayFamily',
        
        properties: {
            /**
             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the event that will be broadcast to its linked entities. The value can also be an array of events to be fired on linked entities.
             *
             *      "events": {
             *          "sleeping": "good-night",
             *          "awake": ["alarm", "get-up"]
             *      }
             *
             * @property events
             * @type Object
             * @default null
             */
            events: null
        },

        constructor: function () {
            var event = '';
            
            if (this.events) {
                for (event in this.events) {
                    if (this.events.hasOwnProperty(event)) {
                        this.addEventListener(event, this.broadcast.bind(this, null, this.events[event]));
                    }
                }
            }
    
            this.owner.familyLinks = Array.setUp(this.owner);
        },
        
        events: {
            /**
             * Called when linking a new member to the family, this event accepts a list of family members from the new member and uses it to link all the family members together.
             *
             * @method 'link-family'
             * @param links {Array|Entities} An array of entities.
             */
            "link-family": function (links) {
                var i = 0,
                    oldList = this.owner.familyLinks,
                    newList = Array.setUp().union(links).union(oldList);

                for (i = 0; i < newList.length; i++) {
                    newList[i].familyLinks = newList;
                }
                this.broadcast(links,   'family-members-added', oldList);
                this.broadcast(oldList, 'family-members-added', links);
                oldList.recycle();
            },
            
            /**
             * Called when this entity spawns a new entity, this event links the newly created entity to this entity.
             *
             * @method 'entity-created'
             * @param entity {platypus.Entity} The entity to link.
             */
            "entity-created": function (entity) {
                if (!entity.triggerEvent('link-family', this.owner.familyLinks)) {
                    entity.addComponent(new platypus.components.RelayFamily(entity, {}));
                    entity.triggerEvent('link-family', this.owner.familyLinks);
                }
            }
        },
        
        methods: {
            broadcast: function (links) {
                var entities = links || this.owner.familyLinks,
                    i = 0,
                    args = Array.prototype.greenSlice.call(arguments);

                args.greenSplice(0);

                for (i = 0; i < entities.length; i++) {
                    entities[i].trigger.apply(entities[i], args);
                }
                
                args.recycle();
            },
            
            destroy: function () {
                var familyLinks = this.owner.familyLinks,
                    i = familyLinks.indexOf(this.owner);
                
                if (i >= 0) {
                    familyLinks.greenSplice(i);
                }
                this.broadcast(familyLinks, 'family-member-removed', this.owner);
                this.events = null;
            }
        }
    });
}());

//##############################################################################
// RelayGame.js
//##############################################################################

/**
 * This component listens for specified local entity messages and re-broadcasts them at the scene level.
 *
 * @namespace platypus.components
 * @class RelayGame
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    var broadcast = function () {
        var currentScene = platypus.game.currentScene;
        
        currentScene.triggerOnChildren.apply(currentScene, arguments);
    };

    return platypus.createComponentClass({
        id: 'RelayGame',
        
        properties: {
            /**
             * This is an object of key/value pairs. The keys are events this component is listening for locally, and the value is the event to be broadcast to the scene. The value can also be an array of events to be fired on the scene.
             *
             *      "events": {
             *          "sleeping": "good-night",
             *          "awake": ["alarm", "get-up"]
             *      }
             *
             * @property events
             * @type Object
             * @default null
             */
            events: null
        },

        constructor: function () {
            var event = '',
                events = this.events;
            
            // Messages that this component listens for and then broadcasts to all layers.
            if (events) {
                for (event in events) {
                    if (events.hasOwnProperty(event)) {
                        this.addEventListener(event, broadcast.bind(this, events[event]));
                    }
                }
            }
        }
    });
}());

//##############################################################################
// RelayLinker.js
//##############################################################################

/**
 * Allows an entity to communicate directly with one or more entities via the message model by passing local events directly to the linked entities as new triggered events.
 *
 * @namespace platypus.components
 * @class RelayLinker
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    var broadcast = function () {
        var i = 0,
            link = null;
        
        for (i = 0; i < this.links.length; i++) {
            link = this.links[i];
            link.trigger.apply(link, arguments);
        }
    };

    return platypus.createComponentClass({
        id: 'RelayLinker',

        properties: {
            /**
             * The id that defines the 'channel' the linkers are talking on. This should be matched on the entity/entities you want to talk between.
             *
             * @property linkId
             * @type String
             * @default 'linked'
             */
            linkId: 'linked',
            
            /**
             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the event to be broadcast to its linked entities. The value can also be an array of events to be fired on linked entities.
             *
             *      "events": {
             *          "sleeping": "good-night",
             *          "awake": ["alarm", "get-up"]
             *      }
             *
             * @property events
             * @type Object
             * @default null
             */
            events: null
        },

        constructor: function () {
            var i = 0,
                event = '';

            if (this.events) {
                for (event in this.events) {
                    if (this.events.hasOwnProperty(event)) {
                        this.addEventListener(event, broadcast.bind(this, this.events[event]));
                    }
                }
            }
            
            if (!this.owner.linkId) {
                this.owner.linkId = this.linkId;
            }
            
            this.addEventListener('to-' + this.linkId + '-entities', broadcast.bind(this, 'from-' + this.linkId + '-entities'));
            this.addEventListener('from-' + this.linkId + '-entities', function (resp) {
                this.owner.trigger(resp.message, resp.value, resp.debug);
            }.bind(this));
            
            this.links = Array.setUp();
            
            if (this.owner.linkEntities) {
                for (i = 0; i < this.owner.linkEntities.length; i++) {
                    this.links.push(this.owner.linkEntities[i]);
                }
            }
            
            this.message = {
                message: '',
                value: null
            };
            this.linkMessage = {
                entity: this.owner,
                linkId: this.linkId,
                reciprocate: false
            };
            
            // In case linker is added after adoption
            if (this.owner.parent) {
                this.resolveAdoption();
            }
        },
        
        events: {

            /**
             * Called when the object is added to its parent, on receiving this message, the component tries to link itself with objects with the same link id.
             *
             * @method 'adopted'
             * @param owner {platypus.Entity} The owner of this component.
             */
            "adopted": function (owner) {
                this.resolveAdoption(owner);
            },
            
            /**
             * On receiving this message, this component checks the linkId of the requesting entity and adds it to its list of connections if it matches.
             *
             * @method 'link-entity'
             * @param toLink {platypus.Entity} The enquiring entity.
             */
            "link-entity": function (toLink) {
                if ((toLink.linkId === this.linkId) && (toLink.entity !== this.owner)) {
                    // Make sure this link is not already in place
                    if (this.links.indexOf(toLink.entity) === -1) {
                        this.links.push(toLink.entity);
                        if (toLink.reciprocate) {
                            this.linkMessage.reciprocate = false;
                            toLink.entity.triggerEvent('link-entity', this.linkMessage);
                        }
                    }
                }
            },
            
            /**
             * Removes the requesting entity from this component's list of linked entities and no farther messages will be transmitted.
             *
             * @method 'unlink-entity'
             * @param toUnlink {platypus.Entity} The enquiring entity.
             */
            "unlink-entity": function (toUnlink) {
                var i = this.links.indexOf(toUnlink.entity);
                
                if (i >= 0) {
                    this.links.greenSplice(i);
                }
            }
        },
        
        methods: {
            resolveAdoption: function () {
                var grandparent = this.owner.parent;
                while (grandparent.parent) {
                    grandparent = grandparent.parent;
                }
                this.linkMessage.reciprocate = true;
                grandparent.triggerOnChildren('link-entity', this.linkMessage);
            },
            
            destroy: function () {
                var i = 0;
                
                for (i = 0; i < this.links.length; i++) {
                    this.links[i].triggerEvent('unlink-entity', this.linkMessage);
                }
                this.links.recycle();
                this.links = null;
                this.events = null;
            }
        }
    });
}());

//##############################################################################
// RelayParent.js
//##############################################################################

/**
 * This component listens for specified local entity messages and re-broadcasts them on its parent entity.
 *
 * @namespace platypus.components
 * @class RelayParent
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';

    var broadcast = function () {
        var parent = this.owner.parent;
        
        if (parent) {
            parent.trigger.apply(parent, arguments);
        }
    };
    
    return platypus.createComponentClass({
        id: 'RelayParent',
        
        properties: {
            /**
             * This is an object of key/value pairs. The keys are events this component is listening for locally, and the value is the event to be broadcast on the parent. The value can also be an array of events to be triggered on the parent.
             *
             *      "events": {
             *          "sleeping": "good-night",
             *          "awake": ["alarm", "get-up"]
             *      }
             *
             * @property events
             * @type Object
             * @default null
             */
            events: null
        },

        constructor: function () {
            var event = '',
                events = this.events;
            
            // Messages that this component listens for and then broadcasts to parent.
            if (events) {
                for (event in events) {
                    if (events.hasOwnProperty(event)) {
                        this.addEventListener(event, broadcast.bind(this, events[event]));
                    }
                }
            }
        }
    });
}());

//##############################################################################
// RelaySelf.js
//##############################################################################

/**
 * This component listens for specified local entity messages and re-broadcasts them on itself as other messages.
 *
 * @namespace platypus.components
 * @class RelaySelf
 * @uses platypus.Component
 */
/*global platypus */
(function () {
    'use strict';
    
    var trigger = function () {
        var owner = this.owner;
        
        owner.trigger.apply(owner, arguments);
    };

    return platypus.createComponentClass({
        id: 'RelaySelf',
        
        properties: {
            /**
             * This is an object of key/value pairs. The keys are events this component is listening for locally, the value is the new event to be broadcast on this entity. The value can also be an array of events to be fired.
             *
             *      "events": {
             *          "sleeping": "good-night",
             *          "awake": ["alarm", "get-up"]
             *      }
             *
             * @property events
             * @type Object
             * @default null
             */
            events: null
        },

        constructor: function () {
            var event = '',
                events = this.events;
            
            // Messages that this component listens for and then triggers on itself as a renamed message - useful as a logic place-holder for simple entities.
            if (events) {
                for (event in events) {
                    if (events.hasOwnProperty(event)) {
                        this.addEventListener(event, trigger.bind(this, events[event]));
                    }
                }
            }
        }
    });
}());

//##############################################################################
// RenderDebug.js
//##############################################################################

/**
 * This component is attached to entities that will appear in the game world. It serves two purposes. First, it displays a rectangle that indicates the location of the entity. By default it uses the specified position and dimensions of the object (in grey). If the object has a collision component it will display the AABB of the collision shape (in pink). If the entity has a LogicCarrier component and is/was carrying an object, a green rectangle will be drawn showing the collision group. The RenderDebug component also allows the developer to right-click on an entity and it will print the object in the debug console.
 *
 * @namespace platypus.components
 * @class RenderDebug
 * @uses platypus.Component
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Graphics = include('PIXI.Graphics'),
        defaultHeight = 100,
        defaultWidth = 100,
        defaultZ = 10000,
        types = {
            "aabb": 0xff88ff,
            "render": 0x0000ff,
            "collision": 0xff00ff,
            "group": 0x00ff00
        },
        createShape = function (shape, type, left, top, width, height, z) {
            var newShape = null,
                opacity = 0.1;

            switch (shape) {
            case 'rectangle':
                newShape = new Graphics().beginFill(types[type], opacity).drawRect(left, top, width, height);
                break;
            case 'circle':
                newShape = new Graphics().beginFill(types[type], opacity).drawCircle(0, 0, width);
                break;
            }
            newShape.z = z;

            return newShape;
        };
    
    return platypus.createComponentClass({
        
        id: 'RenderDebug',
        
        constructor: function () {
            this.parentContainer = null;
            this.shapes = Array.setUp();
            this.isOutdated = true;
        },
        
        events: {// These are messages that this component listens for
            /**
             * The visual components are set up and added to the stage. Setting up mouse input stuff. The click-to-print-to-console functionality is set up too.
             *
             * @method 'handle-render-load'
             * @param handlerData {Object} Data from the render handler
             * @param handlerData.container {PIXI.Container} The parent container.
             */
            "handle-render-load": function (handlerData) {
                if (!platypus.game.settings.debug) {
                    this.owner.removeComponent(this);
                } else if (!this.parentContainer && handlerData && handlerData.container) {
                    this.parentContainer = handlerData.container;
                }
            },
            
            /**
             * Repositions the pieces of the component in preparation for rendering
             *
             * @method 'handle-render'
             * @param renderData {Object} Data from the render handler
             * @param renderData.container {PIXI.Container} The parent container.
             */
            "handle-render": function (renderData) {
                var i = 0,
                    aabb = null,
                    offset = -0.5;

                if (!this.parentContainer) {
                    if (!platypus.game.settings.debug) {
                        this.owner.removeComponent(this);
                        return;
                    } else if (renderData.container) {
                        this.parentContainer = renderData.container;
                    } else {
                        platypus.debug.warn('No Container, removing render debug component from "' + this.owner.type + '".');
                        this.owner.removeComponent(this);
                        return;
                    }
                }

                if (this.isOutdated) {
                    this.updateSprites();
                    this.isOutdated = false;
                }
                
                for (i = 0; i < this.shapes.length; i++) {
                    this.shapes[i].x = this.owner.x;
                    this.shapes[i].y = this.owner.y;
                }
                
                if (this.owner.getCollisionGroupAABB) {
                    aabb = this.owner.getCollisionGroupAABB();
                    if (!this.groupShape) {
                        this.groupShape = new Graphics().beginFill("rgba(255,255,0,0.2)").drawRect(offset, offset, 1, 1);
                        this.groupShape.z = (this.owner.z || 0) + defaultZ;
                        this.parentContainer.addChild(this.groupShape);
                    }
                    this.groupShape.scaleX = aabb.width;
                    this.groupShape.scaleY = aabb.height;
                    this.groupShape.x      = aabb.x;
                    this.groupShape.y      = aabb.y;
                }
            },
            
            /**
             * On receiving this message, will re-orient itself on the next update.
             *
             * @method 'orientation-updated'
             */
            "orientation-updated": function () {
                this.isOutdated = true;
            }
            
        },
        
        methods: {
            updateSprites: function () {
                var z        = (this.owner.z || 0) + defaultZ,
                    i        = 0,
                    j        = 0,
                    width    = this.owner.width  = this.owner.width  || defaultWidth,
                    height   = this.owner.height = this.owner.height || defaultHeight,
                    shapes   = null,
                    aabb     = null,
                    shape    = null;

                for (i = 0; i < this.shapes.length; i++) {
                    this.parentContainer.removeChild(this.shapes[i]);
                }
                this.shapes.length = 0;

                if (this.owner.getAABB) {
                    for (j = 0; j < this.owner.collisionTypes.length; j++) {
                        aabb   = this.owner.getAABB(this.owner.collisionTypes[j]);
                        width  = this.initialWidth  = aabb.width;
                        height = this.initialHeight = aabb.height;
                        shapes = this.owner.getShapes(this.owner.collisionTypes[j]);
                        
                        shape  = createShape('rectangle', 'aabb', aabb.left - this.owner.x, aabb.top - this.owner.y, width, height, z--);
                        this.shapes.push(shape);
                        this.parentContainer.addChild(shape);
                        this.addInput(shape);
                        
                        for (i = 0; i < shapes.length; i++) {
                            shape = createShape(shapes[i].type, 'collision', shapes[i].offsetX - shapes[i].width / 2, shapes[i].offsetY - shapes[i].height / 2, shapes[i].radius || shapes[i].width, shapes[i].height, z--);
                            this.shapes.push(shape);
                            this.parentContainer.addChild(shape);
                            this.addInput(shape);
                        }
                    }
                } else {
                    shape = createShape('rectangle', 'render', -width / 2, -height / 2, width, height, z--);
                    this.shapes.push(shape);
                    this.parentContainer.addChild(shape);
                    this.addInput(shape);
                }
            },
            
            addInput: (function () {
                var lastEntityLog = null,
                    handler = function () {
                        if (lastEntityLog !== this.owner) {
                            lastEntityLog = this.owner;
                            platypus.debug.olive('Entity "' + lastEntityLog.type + '":', lastEntityLog);
                        }

                        return false;
                    };
                
                return function (sprite) {
                    sprite.interactive = true;
                    sprite.addListener('rightdown', handler.bind(this));
                };
            }()),
            
            destroy: function () {
                var i = 0;
                
                for (i = 0; i < this.shapes.length; i++) {
                    this.parentContainer.removeChild(this.shapes[i]);
                }
                this.shapes.recycle();
                this.parentContainer = null;
            }
        }
    });
}());

//##############################################################################
// RenderDestroyMe.js
//##############################################################################

/**
 * This component will destroy the entity once an animation has finished. This is useful for explosions or similar animations where the entity is no longer needed once the animation completes.
 *
 * @namespace platypus.components
 * @class RenderDestroyMe
 * @uses platypus.Component
 */
/* global platypus */
(function () {
    'use strict';

    return platypus.createComponentClass({
        id: 'RenderDestroyMe',
        
        properties: {
            /**
             * This or animationIds required. This is a String identifying the animation that should destroy this entity on its completion.
             *
             * @property animationId
             * @type String
             * @default ''
             */
            animationId: '',
            
            /**
             * This or animationId required. This is an array of Strings identifying the animations that should destroy this entity on their completion.
             *
             * @property animationIds
             * @type Array
             * @default null
             */
            animationIds: null
        },

        constructor: function (definition) {
            if (this.animationId) {
                this.animationIds = Array.setUp(definition.animationId);
            } else if (this.animationIds) {
                this.animationIds = this.animationIds.greenSlice();
            }
        },

        events: {// These are messages that this component listens for
            /**
             * On receiving this message, the component matches the animation id with its animation id setting and destroys the entity if they match.
             *
             * @method 'animation-ended'
             * @param animation {String} Animation id for the animation that just finished.
             */
            "animation-ended": function (animation) {
                if (!this.animationIds || (this.animationIds.indexOf(animation) >= 0)) {
                    this.owner.parent.removeEntity(this.owner);
                }
            }
        },
        
        methods: {
            destroy: function () {
                if (this.animationIds) {
                    this.animationIds.recycle();
                    delete this.animationIds;
                }
            }
        }
    });
}());

//##############################################################################
// RenderProgress.js
//##############################################################################

/**
 * This component creates a visual progress bar that can be used for loading assets or showing other types of progress changes.
 *
 * @namespace platypus.components
 * @class RenderProgress
 * @uses platypus.Component
 */
/*global PIXI, platypus */
(function () {
    'use strict';
    
    return platypus.createComponentClass({
        
        id: 'RenderProgress',
        
        properties: {
            //TODO: Document!
            backgroundColor: 0x000000,
            
            color: 0xffffff,
            
            rotate: false,
            
            mirror: false,
            
            flip: false,
            
            width: 100,
            
            height: 20,
            
            regX: 0,
            
            regY: 0
        },
        
        publicProperties: {
            x: 0,
            
            y: 0,
            
            z: 0
        },
        
        constructor: function () {
            var b   = new PIXI.Graphics(),
                f   = new PIXI.Graphics(),
                con = new PIXI.Container();
            
            this.parentContainer = null;
            this.background = b;
            this.progress   = f;
            this.container  = con;
            
            if (typeof this.backgroundColor === 'string') {
                this.backgroundColor = +this.backgroundColor.replace('#', '0x');
            }
            if (typeof this.color === 'string') {
                this.color = +this.color.replace('#', '0x');
            }
            
            b.f(this.backgroundColor).r(-this.regX, -this.regY, this.width, this.height);
            f.f(this.color).r(-this.regX, -this.regY, this.width, this.height);
            f.scale = new PIXI.Point(0.0001, 1);
            con.addChild(b);
            con.addChild(f);
        },
        
        events: {
            "handle-render-load": function (resp) {
                if (!this.parentContainer && resp && resp.container) {
                    this.parentContainer = resp.container;
                    this.parentContainer.addChild(this.container);
                }
            },
            
            "handle-render": function (resp) {
                if (!this.container) { // If this component's removal is pending
                    return;
                }

                if (!this.parentContainer) {
                    if (resp && resp.container) {
                        this.parentContainer = resp.container;
                        this.parentContainer.addChild(this.container);
                    } else {
                        platypus.debug.warn('No PIXI Stage, removing ProgressRender component from "' + this.owner.type + '".');
                        this.owner.removeComponent(this);
                    }
                }
                
                this.container.x = this.x;
                this.container.y = this.y;
                this.container.z = this.z;
            },
            
            "update-progress": function (progress) {
                if (isNaN(progress)) {
                    if (typeof progress.fraction === 'number') {
                        this.progress.scale.x = progress.fraction;
                    } else if ((typeof progress.total === 'number') && (typeof progress.progress === 'number')) {
                        this.progress.scale.x = progress.progress / progress.total;
                    }
                } else {
                    this.progress.scale.x = progress;
                }
            }
        },
        
        methods: {
            destroy: function () {
                if (this.parentContainer) {
                    this.parentContainer.removeChild(this.container);
                    this.parentContainer = null;
                }
                this.container = null;
            }
        }
    });
}());

//##############################################################################
// RenderTiles.js
//##############################################################################

/**
 * This component handles rendering tile map backgrounds.
 *
 * When rendering the background, this component figures out what tiles are being displayed and caches them so they are rendered as one image rather than individually.
 *
 * As the camera moves, the cache is updated by blitting the relevant part of the old cached image into a new cache and then rendering tiles that have shifted into the camera's view into the cache.
 *
 * @namespace platypus.components
 * @class RenderTiles
 * @uses platypus.Component
 */
/* global include, platypus, recycle, springroll */
(function () {
    'use strict';

    var AABB              = include('platypus.AABB'),
        PIXIAnimation     = include('platypus.PIXIAnimation'),
        Application       = include('springroll.Application'),
        CanvasRenderer    = include('PIXI.CanvasRenderer'),
        Container         = include('PIXI.Container'),
        Graphics          = include('PIXI.Graphics'),
        ParticleContainer = include('PIXI.ParticleContainer'),
        Rectangle         = include('PIXI.Rectangle'),
        RenderTexture     = include('PIXI.RenderTexture'),
        Sprite            = include('PIXI.Sprite'),
        doNothing = function () {
            return null;
        },
        tempCache = AABB.setUp(),
        sort = function (a, b) {
            return a.z - b.z;
        },
        getPowerOfTwo = function (amount) {
            var x = 1;

            while (x < amount) {
                x *= 2;
            }

            return x;
        },
        transformCheck = function (value, tile) {
            var v = +(value.substring(4)),
                x = 0;

            if (0x80000000 & v) {
                tile.scale.x = -1;
            }
            if (0x40000000 & v) {
                tile.scale.y = -1;
            }
            if (0x20000000 & v) {
                x = tile.scale.x;
                tile.scale.x = tile.scale.y;
                tile.scale.y = -x;
                tile.rotation = Math.PI / 2;
            }

            return 0x0fffffff & v;
        },
        Template = function (tile, id) {
            this.id = id;
            this.instances = Array.setUp(tile);
            this.index = 0;
            tile.template = this; // backwards reference for clearing index later.
        },
        nullTemplate = {
            getNext: doNothing,
            destroy: doNothing
        },
        prototype = Template.prototype;

    prototype.getNext = function () {
        var instance = this.instances[this.index],
            template = null;

        if (!instance) {
            template = this.instances[0];
            instance = this.instances[this.index] = new Sprite(template.texture);

            // Copy properties
            instance.scale    = template.scale;
            instance.rotation = template.rotation;
            instance.anchor   = template.anchor;
        }

        this.index += 1;

        return instance;
    };

    prototype.clear = function () {
        this.index = 0;
    };
    
    prototype.destroy = function () {
        var i = 0;
        
        for (i = 0; i < this.instances.length; i++) {
            this.instances[i].destroy();
        }
        
        this.instances.recycle();
        this.recycle();
    };
    
    recycle.add(Template, !!springroll.Debug, 'Template');

    return platypus.createComponentClass({

        id: 'RenderTiles',

        properties: {
            /**
             * The amount of space in pixels around the edge of the camera that we include in the buffered image. If not set, largest buffer allowed by maximumBuffer is used.
             *
             * @property buffer
             * @type number
             * @default 0
             */
            buffer: 0,

            /**
             * Determines whether to cache the entire map across one or more texture caches. By default this is `false`; however, if the entire map fits on one or two texture caches, this is set to `true` since it is more efficient than dynamic buffering.
             *
             * @property cacheAll
             * @type Boolean
             * @default false
             */
            cacheAll: false,

            /**
             * Whether to cache entities on this layer if the entity's render component requests caching.
             *
             * @property entityCache
             * @type boolean
             * @default false
             */
            entityCache: false,

            /**
             * This is a two dimensional array of the spritesheet indexes that describe the map that you're rendering.
             *
             * @property imageMap
             * @type Array
             * @default []
             */
            imageMap: [],

            /**
             * The amount of space that is buffered. Defaults to 2048 x 2048 or a smaller area that encloses the tile layer.
             *
             * @property maximumBuffer
             * @type number
             * @default 2048
             */
            maximumBuffer: 2048,

            /**
             * The x-scale the tilemap is being displayed at.
             *
             * @property scaleX
             * @type number
             * @default 1
             */
            scaleX: 1,

            /**
             * The y-scale the tilemap is being displayed at.
             *
             * @property scaleY
             * @type number
             * @default 1
             */
            scaleY: 1,

            /**
             * A sprite sheet describing all the tile images.
             *
             * Accepts an array of sprite sheet data since 0.8.4
             *
             * @property spriteSheet
             * @type Object|Array|String
             * @default null
             */
            spriteSheet: null,

            /**
             * Whether to cache the tile map to a large texture.
             *
             * @property tileCache
             * @type boolean
             * @default true
             * @since 0.6.4
             */
            tileCache: true,

            /**
             * This is the height in pixels of individual tiles.
             *
             * @property tileHeight
             * @type number
             * @default 10
             */
            tileHeight: 10,

            /**
             * This is the width in pixels of individual tiles.
             *
             * @property tileWidth
             * @type number
             * @default 10
             */
            tileWidth: 10,
            
            /**
             * The map's top offset.
             *
             * @property top
             * @type Number
             * @default 0
             * @since 0.7.5
             */
            top: 0,
            
            /**
             * The map's left offset.
             *
             * @property left
             * @type Number
             * @default 0
             * @since 0.7.5
             */
            left: 0
        },

        constructor: function () {
            var imgMap = this.imageMap;

            this.doMap            = null; //list of display objects that should overlay tile map.
            this.cachedDisplayObjects = null;
            this.populate         = this.populateTiles;

            this.tiles            = {};

            this.renderer         = Application.instance.display.renderer;
            this.tilesSprite      = null;
            this.cacheTexture     = null;
            this.mapContainer      = null;
            this.laxCam = AABB.setUp();

            // temp values
            this.worldWidth    = this.tileWidth;
            this.worldHeight   = this.tileHeight;

            this.cache = AABB.setUp();
            this.cachePixels = AABB.setUp();

            // Set up containers
            this.spriteSheet = PIXIAnimation.formatSpriteSheet(this.spriteSheet);
            this.tileContainer = ((this.spriteSheet.images.length > 1) || (this.renderer instanceof CanvasRenderer)) ? new Container() : new ParticleContainer(15000, {position: true, rotation: true, scale: true});
            this.mapContainer = new Container();
            this.mapContainer.addChild(this.tileContainer);
            
            this.reorderedStage = false;
            this.updateCache = false;

            // Prepare map tiles
            this.imageMap = Array.setUp(this.createMap(imgMap));

            this.tilesWidth  = this.imageMap[0].length;
            this.tilesHeight = this.imageMap[0][0].length;
            this.layerWidth  = this.tilesWidth  * this.tileWidth;
            this.layerHeight = this.tilesHeight * this.tileHeight;

            // Set up buffer cache size
            this.cacheWidth = Math.min(getPowerOfTwo(this.layerWidth), this.maximumBuffer);
            this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight), this.maximumBuffer);

            if (!this.tileCache) {
                this.buffer = 0; // prevents buffer logic from running if tiles aren't being cached.
                this.cacheAll = false; // so tiles are updated as camera moves.
            }
        },

        events: {
            /**
             * This event is triggered before `handle-render` and provides the container that this component will require to display. In this case it compiles the array of tiles that make up the map and adds the tilesSprite displayObject to the stage.
             *
             * @method 'handle-render-load'
             * @param data.container {PIXI.Container} Container to contain this tile-rendering.
             */
            "handle-render-load": function (resp) {
                var extrusionMargin = 2,
                    mapContainer = this.mapContainer,
                    parentContainer = null,
                    renderer = this.renderer,
                    sprite = null,
                    z = this.owner.z;

                if (resp && resp.container) {
                    parentContainer = this.parentContainer = resp.container;

                    if (parentContainer && !this.reorderedStage) {
                        parentContainer.reorder = true;
                        this.reorderedStage = true;
                    }

                    this.updateRegion(0);

                    if (!this.tileCache) {
                        this.render = doNothing;

                        mapContainer.scaleX = this.scaleX;
                        mapContainer.scaleY = this.scaleY;
                        mapContainer.x = this.left;
                        mapContainer.y = this.top;
                        mapContainer.z = z;
                        parentContainer.addChild(mapContainer);
                    } else {
                        this.mapContainerWrapper = new Container();
                        this.mapContainerWrapper.addChild(mapContainer);

                        if ((this.layerWidth <= this.cacheWidth) && (this.layerHeight <= this.cacheHeight)) { // We never need to recache.
                            this.cacheAll   = true;

                            this.render = this.renderCache;
                            this.cacheTexture = new RenderTexture(renderer, this.cacheWidth, this.cacheHeight);

                            this.tilesSprite = sprite = new Sprite(this.cacheTexture);
                            sprite.scaleX = this.scaleX;
                            sprite.scaleY = this.scaleY;
                            sprite.z = z;

                            this.cache.setBounds(0, 0, this.tilesWidth - 1, this.tilesHeight - 1);
                            this.update(this.cacheTexture, this.cache);
                            parentContainer.addChild(sprite);
                        } else if (this.cacheAll || ((this.layerWidth <= this.cacheWidth * 2) && (this.layerHeight <= this.cacheHeight)) || ((this.layerWidth <= this.cacheWidth) && (this.layerHeight <= this.cacheHeight * 2))) { // We cache everything across several textures creating a cache grid.
                            this.cacheAll = true;

                            // Make sure there's room for the one-pixel extrusion around edges of caches
                            this.cacheWidth = Math.min(getPowerOfTwo(this.layerWidth + extrusionMargin), this.maximumBuffer);
                            this.cacheHeight = Math.min(getPowerOfTwo(this.layerHeight + extrusionMargin), this.maximumBuffer);
                            this.updateRegion(extrusionMargin);

                            this.render = this.renderCacheWithExtrusion;
                            this.cacheGrid = this.createGrid(parentContainer, renderer);

                            this.updateCache = true;
                        } else {
                            this.render = this.renderCache;
                            this.cacheAll = false;

                            this.cacheTexture = new RenderTexture(renderer, this.cacheWidth, this.cacheHeight);

                            this.tilesSprite = new Sprite(this.cacheTexture);
                            this.tilesSprite.scaleX = this.scaleX;
                            this.tilesSprite.scaleY = this.scaleY;
                            this.tilesSprite.z = z;

                            // Set up copy buffer and circular pointers
                            this.cacheTexture.alternate = new RenderTexture(renderer, this.cacheWidth, this.cacheHeight);
                            this.tilesSpriteCache = new Sprite(this.cacheTexture.alternate);

                            this.cacheTexture.alternate.alternate = this.cacheTexture;
                            parentContainer.addChild(this.tilesSprite);
                        }
                    }
                }
            },

            /**
             * If this component should cache entities, it checks peers for a "renderCache" display object and adds the display object to its list of objects to render on top of the tile set.
             *
             * @method 'cache-sprite'
             * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.
             */
            "cache-sprite": function (entity) {
                this.cacheSprite(entity);
            },

            /**
             * If this component should cache entities, it checks peers for a "renderCache" display object and adds the display object to its list of objects to render on top of the tile set.
             *
             * @method 'peer-entity-added'
             * @param entity {platypus.Entity} This is the peer entity to be checked for a renderCache.
             */
            "peer-entity-added": function (entity) {
                this.cacheSprite(entity);
            },

            /**
             * This event adds a layer of tiles to render on top of the existing layer of rendered tiles.
             *
             * @method 'add-tiles'
             * @param message.imageMap {Array} This is a 2D mapping of tile indexes to be rendered.
             */
            "add-tiles": function (definition) {
                var map = definition.imageMap;

                if (map) {
                    this.imageMap.push(this.createMap(map));
                    this.updateCache = true;
                }
            },

            /**
             * This event edits the tile index of a rendered tile.
             *
             * @method 'change-tile'
             * @param tile {String} A string representing the name of the tile to switch to.
             * @param x {Number} The column of the tile to edit.
             * @param y {Number} The row of the tile to edit.
             * @param [z] {Number} If RenderTiles has multiple layers, this value specifies the layer, with `0` being the bottom-most layer.
             */
            "change-tile": function (tile, x, y, z) {
                var map = this.imageMap;

                if (map) {
                    this.updateTile(tile, map[z || 0], x, y);
                    this.updateCache = true;
                }
            },

            /**
             * Provides the width and height of the world.
             *
             * @method 'camera-loaded'
             * @param camera {Object}
             * @param camera.world {platypus.AABB} The dimensions of the world.
             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.
             */
            "camera-loaded": function (camera) {
                this.worldWidth  = camera.world.width;
                this.worldHeight = camera.world.height;

                if (this.buffer && !this.cacheAll) { // do this here to set the correct mask before the first caching.
                    this.updateBufferRegion(camera.viewport);
                }
            },

            /**
             * Triggered when the camera moves, this function updates which tiles need to be rendered and caches the image.
             *
             * @method 'camera-update'
             * @param camera {Object} Provides information about the camera.
             * @param camera.viewport {platypus.AABB} The AABB describing the camera viewport in world units.
             */
            "camera-update": function (camera) {
                var x = 0,
                    y = 0,
                    inFrame = false,
                    sprite  = null,
                    ctw     = 0,
                    cth     = 0,
                    ctw2    = 0,
                    cth2    = 0,
                    cache   = this.cache,
                    cacheP  = this.cachePixels,
                    vp      = camera.viewport,
                    resized = (this.buffer && ((vp.width !== this.laxCam.width) || (vp.height !== this.laxCam.height))),
                    tempC   = tempCache,
                    laxCam  = this.convertCamera(vp);

                if (!this.cacheAll && (cacheP.empty || !cacheP.contains(laxCam)) && (this.imageMap.length > 0)) {
                    if (resized) {
                        this.updateBufferRegion(laxCam);
                    }
                    ctw     = this.cacheTilesWidth - 1;
                    cth     = this.cacheTilesHeight - 1;
                    ctw2    = ctw / 2;
                    cth2    = cth / 2;

                    //only attempt to draw children that are relevant
                    tempC.setAll(Math.round((laxCam.x - this.left) / this.tileWidth - ctw2) + ctw2, Math.round((laxCam.y - this.top) / this.tileHeight - cth2) + cth2, ctw, cth);
                    if (tempC.left < 0) {
                        tempC.moveX(tempC.halfWidth);
                    } else if (tempC.right > this.tilesWidth - 1) {
                        tempC.moveX(this.tilesWidth - 1 - tempC.halfWidth);
                    }
                    if (tempC.top < 0) {
                        tempC.moveY(tempC.halfHeight);
                    } else if (tempC.bottom > this.tilesHeight - 1) {
                        tempC.moveY(this.tilesHeight - 1 - tempC.halfHeight);
                    }
                    
                    if (!this.tileCache) {
                        this.update(null, tempC);
                    } else if (cache.empty || !tempC.contains(cache)) {
                        this.tilesSpriteCache.texture = this.cacheTexture;
                        this.cacheTexture = this.cacheTexture.alternate;
                        this.tilesSprite.texture = this.cacheTexture;
                        this.update(this.cacheTexture, tempC, this.tilesSpriteCache, cache);
                    }

                    // Store pixel bounding box for checking later.
                    cacheP.setAll((cache.x + 0.5) * this.tileWidth + this.left, (cache.y + 0.5) * this.tileHeight + this.top, (cache.width + 1) * this.tileWidth, (cache.height + 1) * this.tileHeight);
                }

                if (this.cacheGrid) {
                    for (x = 0; x < this.cacheGrid.length; x++) {
                        for (y = 0; y < this.cacheGrid[x].length; y++) {
                            sprite = this.cacheGrid[x][y];
                            cacheP.setAll((x + 0.5) * this.cacheClipWidth + this.left, (y + 0.5) * this.cacheClipHeight + this.top, this.cacheClipWidth, this.cacheClipHeight);

                            inFrame = cacheP.intersects(laxCam);
                            if (sprite.visible && !inFrame) {
                                sprite.visible = false;
                            } else if (!sprite.visible && inFrame) {
                                sprite.visible = true;
                            }
                            
                            if (sprite.visible && inFrame) {
                                sprite.x = vp.left - laxCam.left + x * this.cacheClipWidth + this.left;
                                sprite.y = vp.top  - laxCam.top  + y * this.cacheClipHeight + this.top;
                            }
                        }
                    }
                } else if (this.tileCache) {
                    this.tilesSprite.x = vp.left - laxCam.left + cache.left * this.tileWidth + this.left;
                    this.tilesSprite.y = vp.top  - laxCam.top  + cache.top  * this.tileHeight + this.top;
                }
            },

            /**
             * On receiving this message, determines whether to update which tiles need to be rendered and caches the image.
             *
             * @method 'handle-render'
             */
            "handle-render": function () {
                if (this.updateCache) {
                    this.updateCache = false;
                    if (this.cacheGrid) {
                        this.updateGrid();
                    } else {
                        this.update(this.cacheTexture, this.cache);
                    }
                }
            }
        },

        methods: {
            cacheSprite: function (entity) {
                var x = 0,
                    y = 0,
                    object = entity.cacheRender,
                    bounds = null,
                    top = 0,
                    bottom = 0,
                    right = 0,
                    left = 0;

                // Determine whether to merge this image with the background.
                if (this.entityCache && object) { //TODO: currently only handles a single display object on the cached entity.
                    if (!this.doMap) {
                        this.doMap = Array.setUp();
                        this.cachedDisplayObjects = Array.setUp();
                        this.populate = this.populateTilesAndEntities;
                    }
                    this.cachedDisplayObjects.push(object);

                    // Determine range:
                    bounds = object.getBounds(object.transformMatrix);
                    bounds.x -= this.left;
                    bounds.y -= this.top;
                    top    = Math.max(0, Math.floor(bounds.y / this.tileHeight));
                    bottom = Math.min(this.tilesHeight, Math.ceil((bounds.y + bounds.height) / this.tileHeight));
                    left   = Math.max(0, Math.floor(bounds.x / this.tileWidth));
                    right  = Math.min(this.tilesWidth, Math.ceil((bounds.x + bounds.width) / this.tileWidth));

                    // Find tiles that should include this display object
                    for (x = left; x < right; x++) {
                        if (!this.doMap[x]) {
                            this.doMap[x] = Array.setUp();
                        }
                        for (y = top; y < bottom; y++) {
                            if (!this.doMap[x][y]) {
                                this.doMap[x][y] = Array.setUp();
                            }
                            this.doMap[x][y].push(object);
                        }
                    }

                    // Prevent subsequent draws
                    entity.removeComponent('RenderSprite');

                    this.updateCache = true; //TODO: This currently causes a blanket cache update - may be worthwhile to only recache if this entity's location is currently in a cache (either cacheGrid or the current viewable area).
                }
            },

            convertCamera: function (camera) {
                var worldWidth  = this.worldWidth / this.scaleX,
                    worldPosX   = worldWidth - camera.width,
                    worldHeight = this.worldHeight / this.scaleY,
                    worldPosY   = worldHeight - camera.height,
                    laxCam      = this.laxCam;

                if ((worldWidth === this.layerWidth) || !worldPosX) {
                    laxCam.moveX(camera.x);
                } else {
                    laxCam.moveX((camera.left - this.left) * (this.layerWidth - camera.width) / worldPosX + camera.halfWidth + this.left);
                }

                if ((worldHeight === this.layerHeight) || !worldPosY) {
                    laxCam.moveY(camera.y);
                } else {
                    laxCam.moveY((camera.top - this.top) * (this.layerHeight - camera.height) / worldPosY + camera.halfHeight + this.top);
                }

                if (camera.width !== laxCam.width || camera.height !== laxCam.height) {
                    laxCam.resize(camera.width, camera.height);
                }

                return laxCam;
            },

            createTile: function (imageName) {
                var tile = null,
                    anim = '';

                // "tile-1" is empty, so it remains a null reference.
                if (imageName === 'tile-1') {
                    return nullTemplate;
                }

                tile = new PIXIAnimation(this.spriteSheet);
                anim = 'tile' + transformCheck(imageName, tile);
                tile.gotoAndStop(anim);

                return Template.setUp(tile, imageName);
            },

            createMap: function (mapDefinition) {
                var x = 0,
                    y = 0,
                    index = '',
                    map   = null;

                if (typeof mapDefinition[0][0] !== 'string') { // This is not a map definition: it's an actual RenderTiles map.
                    return mapDefinition;
                }

                map = Array.setUp();
                for (x = 0; x < mapDefinition.length; x++) {
                    map[x] = Array.setUp();
                    for (y = 0; y < mapDefinition[x].length; y++) {
                        index = mapDefinition[x][y];
                        this.updateTile(index, map, x, y);
                    }
                }
                
                return map;
            },
            
            updateTile: function (index, map, x, y) {
                var tile = null,
                    tiles = this.tiles;
                
                if (index.id) {
                    index = index.id;
                }
                tile = tiles[index];
                if (!tile && (tile !== null)) { // Empty grid spaces are null, so we needn't create a new tile.
                    tile = tiles[index] = this.createTile(index);
                }
                map[x][y] = tile;
            },

            createGrid: function (parentContainer, renderer) {
                var ch = this.cacheHeight,
                    cw = this.cacheWidth,
                    cth = this.cacheTilesHeight,
                    ctw = this.cacheTilesWidth,
                    h = 0,
                    w = 0,
                    outerMargin = 2,
                    extrusion = 1,
                    rt = null,
                    sx = this.scaleX,
                    sy = this.scaleY,
                    th = this.tileHeight,
                    tw = this.tileWidth,
                    tsh = this.tilesHeight,
                    tsw = this.tilesWidth,
                    x = 0,
                    y = 0,
                    z = this.owner.z,
                    col = null,
                    ct = null,
                    cg = Array.setUp();

                for (x = 0; x < tsw; x += ctw) {
                    col = Array.setUp();
                    cg.push(col);
                    for (y = 0; y < tsh; y += cth) {
                        // This prevents us from using too large of a cache for the right and bottom edges of the map.
                        w = Math.min(getPowerOfTwo((tsw - x) * tw + outerMargin), cw);
                        h = Math.min(getPowerOfTwo((tsh - y) * th + outerMargin), ch);

                        rt = new RenderTexture(renderer, w, h);
                        rt.frame = new Rectangle(extrusion, extrusion, ((w / tw) >> 0) * tw + extrusion, ((h / th) >> 0) * th + extrusion);
                        ct = new Sprite(rt);
                        ct.z = z;
                        ct.scaleX = sx;
                        ct.scaleY = sy;
                        col.push(ct);
                        parentContainer.addChild(ct);

                        z -= 0.000001; // so that tiles of large caches overlap consistently.
                    }
                }
                
                return cg;
            },
            
            updateRegion: function (margin) {
                var clipW = Math.floor(this.cacheWidth  / this.tileWidth),
                    clipH = Math.floor(this.cacheHeight / this.tileHeight);

                this.cacheTilesWidth  = Math.min(this.tilesWidth,  clipW);
                this.cacheTilesHeight = Math.min(this.tilesHeight, clipH);

                this.cacheClipWidth   = this.cacheTilesWidth  * this.tileWidth;
                this.cacheClipHeight  = this.cacheTilesHeight * this.tileHeight;

                if (this.tileCache) {
                    this.mapContainer.mask = new Graphics().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth + margin, this.cacheClipHeight + margin).endFill();
                }
            },

            updateBufferRegion: function (viewport) {
                var clipW = Math.floor(this.cacheWidth  / this.tileWidth),
                    clipH = Math.floor(this.cacheHeight / this.tileHeight);

                this.cacheTilesWidth  = Math.min(this.tilesWidth,  Math.ceil((viewport.width  + this.buffer * 2) / this.tileWidth),  clipW);
                this.cacheTilesHeight = Math.min(this.tilesHeight, Math.ceil((viewport.height + this.buffer * 2) / this.tileHeight), clipH);

                this.cacheClipWidth   = this.cacheTilesWidth  * this.tileWidth;
                this.cacheClipHeight  = this.cacheTilesHeight * this.tileHeight;

                this.mapContainer.mask = new Graphics().beginFill(0x000000).drawRect(0, 0, this.cacheClipWidth, this.cacheClipHeight).endFill();
            },

            update: function (texture, bounds, tilesSpriteCache, oldBounds) {
                this.populate(bounds, oldBounds);

                this.render(bounds, texture, this.mapContainer, this.mapContainerWrapper, tilesSpriteCache, oldBounds);

                if (oldBounds) {
                    oldBounds.set(bounds);
                }
            },
            
            populateTiles: function (bounds, oldBounds) {
                var x = 0,
                    y = 0,
                    z = 0,
                    layer = 0,
                    tile  = null,
                    tiles = Array.setUp();

                this.tileContainer.removeChildren();
                for (x = bounds.left; x <= bounds.right; x++) {
                    for (y = bounds.top; y <= bounds.bottom; y++) {
                        if (!oldBounds || oldBounds.empty || (y > oldBounds.bottom) || (y < oldBounds.top) || (x > oldBounds.right) || (x < oldBounds.left)) {
                            for (layer = 0; layer < this.imageMap.length; layer++) {
                                tile = this.imageMap[layer][x][y].getNext();
                                if (tile) {
                                    if (tile.template) {
                                        tiles.push(tile.template);
                                    }
                                    tile.x = (x + 0.5) * this.tileWidth;
                                    tile.y = (y + 0.5) * this.tileHeight;
                                    this.tileContainer.addChild(tile);
                                }
                            }
                        }
                    }
                }

                // Clear out tile instances
                for (z = 0; z < tiles.length; z++) {
                    tiles[z].clear();
                }
                tiles.recycle();
            },
            
            populateTilesAndEntities: function (bounds, oldBounds) {
                var x = 0,
                    y = 0,
                    z = 0,
                    layer   = 0,
                    tile    = null,
                    ent     = null,
                    ents    = Array.setUp(),
                    tiles   = Array.setUp(),
                    oList   = null;

                this.tileContainer.removeChildren();
                for (x = bounds.left; x <= bounds.right; x++) {
                    for (y = bounds.top; y <= bounds.bottom; y++) {
                        if (!oldBounds || oldBounds.empty || (y > oldBounds.bottom) || (y < oldBounds.top) || (x > oldBounds.right) || (x < oldBounds.left)) {
                            // draw tiles
                            for (layer = 0; layer < this.imageMap.length; layer++) {
                                tile = this.imageMap[layer][x][y].getNext();
                                if (tile) {
                                    if (tile.template) {
                                        tiles.push(tile.template);
                                    }
                                    tile.x = (x + 0.5) * this.tileWidth;
                                    tile.y = (y + 0.5) * this.tileHeight;
                                    this.tileContainer.addChild(tile);
                                }
                            }

                            // check for cached entities
                            if (this.doMap[x] && this.doMap[x][y]) {
                                oList = this.doMap[x][y];
                                for (z = 0; z < oList.length; z++) {
                                    if (!oList[z].drawn) {
                                        oList[z].drawn = true;
                                        ents.push(oList[z]);
                                    }
                                }
                            }
                        }
                    }
                }

                this.mapContainer.removeChildren();
                this.mapContainer.addChild(this.tileContainer);

                // Draw cached entities
                if (ents.length) {
                    ents.sort(sort);
                    for (z = 0; z < ents.length; z++) {
                        ent = ents[z];
                        delete ent.drawn;
                        this.mapContainer.addChild(ent);
                        if (ent.mask) {
                            this.mapContainer.addChild(ent.mask);
                        }
                    }
                }

                // Clear out tile instances
                for (z = 0; z < tiles.length; z++) {
                    tiles[z].clear();
                }
                
                tiles.recycle();
                ents.recycle();
            },
            
            renderCache: function (bounds, dest, src, wrapper, oldCache, oldBounds) {
                if (oldCache && !oldBounds.empty) {
                    oldCache.x = oldBounds.left * this.tileWidth;
                    oldCache.y = oldBounds.top * this.tileHeight;
                    src.addChild(oldCache); // To copy last rendering over.
                }

                dest.clear();
                src.x = -bounds.left * this.tileWidth;
                src.y = -bounds.top * this.tileHeight;
                dest.render(wrapper);
                dest.requiresUpdate = true;
            },

            renderCacheWithExtrusion: function (bounds, dest, src, wrapper) {
                var extrusion = 1,
                    border = new Graphics();

                // This mask makes only the extruded border drawn for the next 4 draws so that inner holes aren't extruded in addition to the outer rim.
                border.lineStyle(1, 0x000000);
                border.drawRect(0.5, 0.5, this.cacheClipWidth + 1, this.cacheClipHeight + 1);

                dest.clear();

                // There is probably a better way to do this. Currently for the extrusion, everything is rendered once offset in the n, s, e, w directions and then once in the middle to create the effect.
                wrapper.mask = border;
                src.x = -bounds.left * this.tileWidth;
                src.y = -bounds.top * this.tileHeight + extrusion;
                dest.render(wrapper);
                src.x = -bounds.left * this.tileWidth + extrusion;
                src.y = -bounds.top * this.tileHeight;
                dest.render(wrapper);
                src.x = -bounds.left * this.tileWidth + extrusion * 2;
                src.y = -bounds.top * this.tileHeight + extrusion;
                dest.render(wrapper);
                src.x = -bounds.left * this.tileWidth + extrusion;
                src.y = -bounds.top * this.tileHeight + extrusion * 2;
                dest.render(wrapper);
                wrapper.mask = null;
                src.x = -bounds.left * this.tileWidth + extrusion;
                src.y = -bounds.top * this.tileHeight + extrusion;
                dest.render(wrapper);
//                wrapper.mask = null;
                dest.requiresUpdate = true;
            },
            
            updateGrid: function () {
                var cache = this.cache,
                    cth = this.cacheTilesHeight,
                    ctw = this.cacheTilesWidth,
                    tsh = this.tilesHeight - 1,
                    tsw = this.tilesWidth - 1,
                    x = 0,
                    y = 0,
                    grid = this.cacheGrid;

                for (x = 0; x < grid.length; x++) {
                    for (y = 0; y < grid[x].length; y++) {
                        cache.setBounds(x * ctw, y * cth, Math.min((x + 1) * ctw, tsw), Math.min((y + 1) * cth, tsh));
                        this.update(grid[x][y].texture, cache);
                    }
                }
            },

            destroy: function () {
                var x = 0,
                    y = 0,
                    key = '',
                    grid = this.cacheGrid,
                    map = this.doMap,
                    img = this.imageMap;
                    
                if (grid) {
                    for (x = 0; x < grid.length; x++) {
                        for (y = 0; y < grid[x].length; y++) {
                            grid[x][y].texture.destroy(true);
                            this.parentContainer.removeChild(grid[x][y]);
                        }
                    }
                    grid.recycle(2);
                    delete this.cacheGrid;
                } else if (this.tilesSprite) {
                    if (this.tilesSprite.texture.alternate) {
                        this.tilesSprite.texture.alternate.destroy(true);
                    }
                    this.tilesSprite.texture.destroy(true);
                    this.parentContainer.removeChild(this.tilesSprite);
                } else {
                    this.parentContainer.removeChild(this.mapContainer);
                }
                
                img.recycle(2);
                
                for (key in this.tiles) {
                    if (this.tiles.hasOwnProperty(key)) {
                        this.tiles[key].destroy();
                    }
                }
                this.tiles = null;
                this.parentContainer = null;
                this.tilesSprite = null;
                this.spriteSheet.recycleSpriteSheet();
                
                if (map) {
                    for (x = 0; x < this.cachedDisplayObjects.length; x++) {
                        this.cachedDisplayObjects[x].destroy();
                    }
                    this.cachedDisplayObjects.recycle();

                    for (x = 0; x < map.length; x++) {
                        if (map[x]) {
                            for (y = 0; y < map.length; y++) {
                                if (map[x][y]) {
                                    map[x][y].recycle();
                                }
                            }
                            map[x].recycle();
                        }
                    }
                    map.recycle();
                }
                
                this.laxCam.recycle();
                this.cache.recycle();
                this.cachePixels.recycle();
            }
        },
        
        getAssetList: (function () {
            var
                getImages = function (ss, spriteSheets) {
                    if (ss) {
                        if (typeof ss === 'string') {
                            return getImages(spriteSheets[ss], spriteSheets);
                        } else if (ss.images) {
                            return ss.images.greenSlice();
                        }
                    }

                    return Array.setUp();
                };
            
            return function (component, props, defaultProps) {
                var arr = null,
                    i = 0,
                    images = null,
                    spriteSheets = platypus.game.settings.spriteSheets,
                    ss = component.spriteSheet || props.spriteSheet || defaultProps.spriteSheet;
                
                if (ss) {
                    if (typeof ss === 'string' && (ss !== 'import')) {
                        return getImages(ss, spriteSheets);
                    } else if (Array.isArray(ss)) {
                        i = ss.length;
                        images = Array.setUp();
                        while (i--) {
                            arr = getImages(ss[i], spriteSheets);
                            images.union(arr);
                            arr.recycle();
                        }
                        return images;
                    } else if (ss.images) {
                        return ss.images.greenSlice();
                    }
                }
                
                return Array.setUp();
            };
        }())
    });
}());

//##############################################################################
// SceneChanger.js
//##############################################################################

/**
 * This component allows the entity to initiate a change from the current scene to another scene.
 *
 * @namespace platypus.components
 * @class SceneChanger
 * @extends platypus.Component
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Data = include('platypus.Data');

    return platypus.createComponentClass({
        id: 'SceneChanger',
        
        properties: {
            /**
             * Optional, but must be provided by a "new-scene" parameter if not defined here. This causes a "new-scene" event to load this scene.
             *
             * @property scene
             * @type String
             * @default ""
             */
            scene: "",

            /**
             * An object containing key/value pairs of information that should be passed into the new scene on the new scene's "scene-loaded" and "scene-live" events.
             *
             * @property persistentData
             * @type platypus.Data|Object
             * @default null
             */
            persistentData: null
        },
        
        constructor: function () {
            this.persistentData = Data.setUp(this.persistentData);
        },

        events: {
            /**
             * On receiving this message, a new scene is loaded according to provided parameters or previously determined component settings.
             *
             * @method 'new-scene'
             * @param message.scene {String} This is a label corresponding with a predefined scene.
             * @param message.persistentData {Object} Any values that should be passed to the next scene on the new scene's "scene-loaded" and "scene-live" events.
             */
            "new-scene": function (response) {
                var resp       = response || this,
                    scene      = resp.scene || this.scene,
                    data       = resp.persistentData || this.persistentData;
            
                platypus.game.loadScene(scene, data);
            },

            /**
             * On receiving this message, a scene value is stored, waiting for a `new-scene` to make the transition.
             *
             * @method 'set-scene'
             * @param scene {String} This is a label corresponding with a predefined scene.
             */
            "set-scene": function (scene) {
                this.scene = scene;
            },

            /**
             * On receiving this message, persistent data is stored, waiting for a `new-scene` to make the transition.
             *
             * @method 'set-persistent-scene-data'
             * @param persistentData {Object} Any values that should be passed to the next scene via the "scene-loaded" and "scene-live" events.
             */
            "set-persistent-scene-data": function (data) {
                var thisData = this.persistentData,
                    key = '';
                
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        thisData[key] = data[key];
                    }
                }
            }
        },
        
        methods: {
            destroy: function () {
                //data.recycle() - can't do this here since it may be in use by the next scene.
            }
        }
    });
}());

//##############################################################################
// StateRender.js
//##############################################################################

/**
 * This component is typically added to an entity automatically by a render component. It handles mapping entity states to playable animations.
 *
 * @class StateRender
 * @uses platypus.Component
 * @since 0.9.0
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var StateMap = include('platypus.StateMap'),
        defaultTest = function (animation) {
            return animation;
        },
        stateTest = function (animation, states, ownerState) {
            if (ownerState.includes(states)) {
                return animation;
            }
            return false;
        },
        createTest = function (testStates, animation) {
            if (testStates === 'default') {
                return defaultTest.bind(null, animation);
            } else {
                //TODO: Better clean-up: Create a lot of these without removing them later... DDD 2/5/2016
                return stateTest.bind(null, animation, StateMap.setUp(testStates));
            }
        };

    return platypus.createComponentClass({
        id: 'StateRender',

        properties: {
            /**
             * An object containg key-value pairs that define a mapping from entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.
             *
             *  "animationMap":{
             *      "standing": "default-animation"  // On receiving a "standing" event, or when this.owner.state.standing === true, the "default" animation will begin playing.
             *      "ground,moving": "walking",  // Comma separated values have a special meaning when evaluating "state-changed" messages. The above example will cause the "walking" animation to play ONLY if the entity's state includes both "moving" and "ground" equal to true.
             *      "ground,striking": "swing!", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.
             *      "default": "default-animation" // Optional. "default" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.
             *  }
             *
             * @property animationMap
             * @type Object
             * @default null
             */
            "animationMap": null,

            /**
             * Optional. Forces animations to complete before starting a new animation. Defaults to `false`.
             *
             * @property forcePlayThrough
             * @type Boolean
             * @default false
             */
            forcePlayThrough: false
        },

        constructor: function () {
            var anim      = '',
                animation = '',
                map = this.animationMap;

            this.followThroughs = {};
            this.checkStates = Array.setUp();
            this.state = this.owner.state;
            this.stateChange = true; //Check state against entity's prior state to update animation if necessary on instantiation.
            this.lastState = -1;

            for (anim in map) {
                if (map.hasOwnProperty(anim)) {
                    animation = map[anim];

                    //TODO: Should probably find a cleaner way to accomplish this. Maybe in the animationMap definition? - DDD
                    if (animation[animation.length - 1] === '!') {
                        animation = animation.substring(0, animation.length - 1);
                        this.followThroughs[animation] = true;
                    } else {
                        this.followThroughs[animation] = false;
                    }

                    this.checkStates.push(createTest(anim, animation));
                }
            }

            this.waitingAnimation = false;
            this.waitingState = 0;
            this.playWaiting = false;
            this.animationFinished = false;
        },

        events: {
            /**
             * This listens for the entity state to change and will update the currently playing animation.
             *
             * @method 'state-changed'
             */
            "state-changed": function () {
                this.stateChange = true;
            },

            /**
             * On receiving this event, the component checks for any waiting animations and begins playing them if so.
             *
             * @method 'animation-ended'
             * @param animation {String} The animation that completed.
             */
            "animation-ended": function (animation) {
                if (animation === this.currentAnimation) {
                    if (this.waitingAnimation) {
                        this.currentAnimation = this.waitingAnimation;
                        this.waitingAnimation = false;
                        this.lastState = this.waitingState;
                        
                        this.animationFinished = false;
                        /**
                         * On entering a new animation-mapped state, this component triggers this event to play an animation.
                         *
                         * @event 'play-animation'
                         * @param animation {String} Describes the animation to play.
                         */
                        this.owner.triggerEvent('play-animation', this.currentAnimation);
                    } else {
                        this.animationFinished = true;
                    }
                }
            },

            /**
             * This checks to determine whether another animation should begin playing.
             *
             * @method update-animation
             * @param playing {Boolean} Whether the new animation should play or pause on the first frame.
             */
            "update-animation": function (playing) {
                var i = 0,
                    testCase = false;

                if (this.stateChange) {
                    if (this.state.has('visible')) {
                        this.visible = this.state.get('visible');
                    }
                    if (this.checkStates) {
                        for (i = 0; i < this.checkStates.length; i++) {
                            testCase = this.checkStates[i](this.state);
                            if (testCase) {
                                if (this.currentAnimation !== testCase) {
                                    if (!this.followThroughs[this.currentAnimation] && (!this.forcePlaythrough || (this.animationFinished || (this.lastState >= +i)))) {
                                        this.currentAnimation = testCase;
                                        this.lastState = +i;
                                        this.animationFinished = false;
                                        if (playing) {
                                            this.owner.triggerEvent('play-animation', this.currentAnimation);
                                        } else {
                                            this.owner.triggerEvent('stop-animation', this.currentAnimation);
                                        }
                                    } else {
                                        this.waitingAnimation = testCase;
                                        this.waitingState = +i;
                                    }
                                } else if (this.waitingAnimation && !this.followThroughs[this.currentAnimation]) {// keep animating this animation since this animation has already overlapped the waiting animation.
                                    this.waitingAnimation = false;
                                }
                                break;
                            }
                        }
                    }
                    this.stateChange = false;
                }
            }
        },
        
        methods: {
            destroy: function () {
                this.checkStates.recycle();
                this.followThroughs = null;
                this.state = null;
            }
        },
        
        publicMethods: {
        }
    });
}());

//##############################################################################
// TiledLoader.js
//##############################################################################

/**
 * This component is attached to a top-level entity (loaded by the [Scene](platypus.Scene.html)) and, once its peer components are loaded, ingests a JSON file exported from the [Tiled map editor](http://www.mapeditor.org/) and creates the tile maps and entities. Once it has finished loading the map, it removes itself from the list of components on the entity.
 *
 * This component requires an [EntityContainer](platypus.components.EntityContainer.html) since it calls `entity.addEntity()` on the entity, provided by `EntityContainer`.
 *
 * This component looks for the following entities, and if not found will load default versions:

        {
            "render-layer": {
                "id": "render-layer",
                "components":[{
                    "type": "RenderTiles",
                    "spriteSheet": "import",
                    "imageMap":    "import",
                    "entityCache": true
                }]
            },
            "collision-layer": {
                "id": "collision-layer",
                "components":[{
                    "type": "CollisionTiles",
                    "collisionMap": "import"
                }]
            },
            "image-layer": {
                "id": "image-layer",
                "components":[{
                    "type": "RenderTiles",
                    "spriteSheet": "import",
                    "imageMap":    "import"
                }]
            }
        }

 * @namespace platypus.components
 * @class TiledLoader
 * @uses platypus.Component
 */
/*global atob, include, pako, platypus */
(function () {
    'use strict';

    var Application = include('springroll.Application'), // Import SpringRoll classes
        AABB        = include('platypus.AABB'),
        Data        = include('platypus.Data'),
        Entity      = include('platypus.Entity'),
        maskId = 0x0fffffff,
        maskJumpThrough = 0x10000000, // This is not passed in via Tiled - rather it's additional information sent to CollisionTiles.
        maskXFlip = 0x80000000,
        maskYFlip = 0x40000000,
        decodeBase64 = (function () {
            var decodeString = function (str, index) {
                    return (((str.charCodeAt(index)) + (str.charCodeAt(index + 1) << 8) + (str.charCodeAt(index + 2) << 16) + (str.charCodeAt(index + 3) << 24 )) >>> 0);
                },
                decodeArray = function (arr, index) {
                    return ((arr[index] + (arr[index + 1] << 8) + (arr[index + 2] << 16) + (arr[index + 3] << 24 )) >>> 0);
                };
            
            return function (data, compression) {
                var index = 4,
                    arr   = [],
                    step1 = atob(data.replace(/\\/g, ''));
                    
                if (compression === 'zlib') {
                    step1 = pako.inflate(step1);
                    while (index <= step1.length) {
                        arr.push(decodeArray(step1, index - 4));
                        index += 4;
                    }
                } else {
                    while (index <= step1.length) {
                        arr.push(decodeString(step1, index - 4));
                        index += 4;
                    }
                }
                
                return arr;
            };
        }()),
        getPowerOfTen = function (amount) {
            var x = 1;

            while (x < amount) {
                x *= 10;
            }

            return x;
        },
        transform = {
            x: 1,
            y: 1,
            id: -1
        },
        entityTransformCheck = function (v) {
            var resp = transform,
                b = !!(maskYFlip & v),
                c = !!(maskXFlip & v);

            resp.id = maskId & v;
            resp.x = 1;
            resp.y = 1;

            if (b) {
                resp.y = -1;
            }
            if (c) {
                resp.x = -1;
            }
            return resp;
        },
        getEntityData = function (obj, tilesets) {
            var x = 0,
                gid = obj.gid || -1,
                properties = {},
                data = {
                    gid: -1,
                    transform: null,
                    properties: properties,
                    type: ''
                },
                props = null,
                tileset = null;
            
            if (gid !== -1) {
                data.transform = entityTransformCheck(gid);
                gid = data.gid = transform.id;
            }
            
            for (x = 0; x < tilesets.length; x++) {
                if (tilesets[x].firstgid > gid) {
                    break;
                } else {
                    tileset = tilesets[x];
                }
            }
            
            if (tileset && tileset.tileproperties && tileset.tileproperties[gid - tileset.firstgid]) {
                props = tileset.tileproperties[gid - tileset.firstgid];
            }

            // Check Tiled data to find this object's type
            if (obj.type !== '') {
                data.type = obj.type;
            } else if (obj.name !== '') {
                data.type = obj.name;
            } else if (props) {
                data.type = props.entity || props.type || '';
            }
            
            if (!data.type) { // undefined entity
                return null;
            }
            
            //Copy properties from Tiled
            if (data.transform) {
                properties.scaleX = data.transform.x;
                properties.scaleY = data.transform.y;
            } else {
                properties.scaleX = 1;
                properties.scaleY = 1;
            }
            
            mergeAndFormatProperties(props, data.properties);
            mergeAndFormatProperties(obj.properties, data.properties);
            
            return data;
        },
        mergeAndFormatProperties = function (src, dest) {
            var key = '';
            
            if (src && dest) {
                for (key in src) {
                    if (src.hasOwnProperty(key)) {
                        dest[key] = formatProperty(src[key]);
                    }
                }
            }
            
            return dest;
        },
        formatProperty = function (value) {
            var numberProperty = 0;
            
            if (typeof value === 'string') {
                //This is going to assume that if you pass in something that starts with a number, it is a number and converts it to one.
                numberProperty = parseFloat(value);
                if (numberProperty === 0 || (!!numberProperty)) {
                    return numberProperty;
                } else if (value === 'true') {
                    return true;
                } else if (value === 'false') {
                    return false;
                } else if ((value.length > 1) && (((value[0] === '{') && (value[value.length - 1] === '}')) || ((value[0] === '[') && (value[value.length - 1] === ']')))) {
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                    }
                }
            }

            return value;
        },
        checkLevel = function (level, ss) {
            var i = 0,
                j = 0,
                tilesets = Array.setUp(),
                arr = null,
                assets = Array.setUp(),
                data = null,
                entity = null,
                entityAssets = null;

            if (typeof level === 'string') {
                level = platypus.game.settings.levels[level];
            }

            if (level) {
                level.tilesets = importTilesetData(level.tilesets);

                if (level.assets) { // Property added by a previous parse (so that this algorithm isn't run on the same level multiple times)
                    assets.union(level.assets);
                } else {
                    for (i = 0; i < level.layers.length; i++) {
                        if (level.layers[i].type === 'objectgroup') {
                            for (j = 0; j < level.layers[i].objects.length; j++) {
                                entity = getEntityData(level.layers[i].objects[j], level.tilesets);
                                if (entity) {
                                    entityAssets = Entity.getAssetList(entity);
                                    assets.union(entityAssets);
                                    entityAssets.recycle();
                                }
                            }
                        } else if (level.layers[i].type === 'imagelayer') {
                            assets.union([level.layers[i].image]);
                        } else if (level.layers[i].properties && level.layers[i].properties.entity) {
                            data = Data.setUp('type', level.layers[i].properties.entity);
                            arr = Entity.getAssetList(data);
                            assets.union(arr);
                            arr.recycle();
                            data.recycle();
                        }
                    }
                    if (!ss) { //We need to load the tileset images since there is not a separate spriteSheet describing them
                        for (i = 0; i < level.tilesets.length; i++) {
                            tilesets.push(level.tilesets[i].image);
                        }
                        assets.union(tilesets);
                        tilesets.recycle();
                    }
                    level.assets = assets.greenSlice(); // Save for later in case this level is checked again.
                }
            }
            
            return assets;
        },
        // These are provided but can be overwritten by entities of the same name in the configuration.
        standardEntityLayers = {
            "render-layer": {
                "id": "render-layer",
                "components": [{
                    "type": "RenderTiles",
                    "spriteSheet": "import",
                    "imageMap": "import",
                    "entityCache": true
                }]
            },
            "collision-layer": {
                "id": "collision-layer",
                "components": [{
                    "type": "CollisionTiles",
                    "collisionMap": "import"
                }]
            },
            "image-layer": {
                "id": "image-layer",
                "components": [{
                    "type": "RenderTiles",
                    "spriteSheet": "import",
                    "imageMap": "import"
                }]
            }
        },
        importTileset = function (tileset) {
            var key = '',
                source = platypus.game.settings.levels[tileset.source.replace('.json', '')];
            
            for (key in source) {
                if (source.hasOwnProperty(key)) {
                    tileset[key] = source[key];
                }
            }
            
            delete tileset.source; // We remove this so we never have to rerun this import. Note that we can't simply replace the tileset properties since the tileset's firstgid property may change from level to level.
            
            return tileset;
        },
        importTilesetData = function (tilesets) {
            var i = 0;
            
            for (i = 0; i < tilesets.length; i++) {
                if (tilesets[i].source) {
                    tilesets[i] = importTileset(tilesets[i]);
                }
            }
            
            return tilesets;
        };

    return platypus.createComponentClass({
        id: 'TiledLoader',

        properties: {
            /**
             * This causes the entire map to be offset automatically by an order of magnitude higher than the height and width of the world so that the number of digits below zero is constant throughout the world space. This fixes potential floating point issues when, for example, 97 is added to 928.0000000000001 giving 1025 since a significant digit was lost when going into the thousands.
             *
             * @property offsetMap
             * @type Boolean
             * @default false
             * @since 0.7.5
             */
            offsetMap: false,
            
            /**
             * If set to `true` and if the game is running in debug mode, this causes the collision layer to appear.
             *
             * @property showCollisionTiles
             * @type Boolean
             * @default false
             */
            showCollisionTiles: false,

            /**
             * If specified, the referenced images are used as the game sprite sheets instead of the images referenced in the Tiled map. This is useful for using different or better quality art from the art used in creating the Tiled map.
             *
             * @property images
             * @type Array
             * @default null
             */
            images: null,

            /**
             * Adds a number to each additional Tiled layer's z coordinate to maintain z-order. Defaults to 1000.
             *
             * @property layerIncrement
             * @type number
             * @default 1000
             */
            layerIncrement: 1000,

            /**
             * Keeps the tile maps in separate render layers. Default is 'false' to for better optimization.
             *
             * @property separateTiles
             * @type boolean
             * @default false
             */
            separateTiles: false,
            
            /**
             * If a particular sprite sheet should be used that's not defined by the level images themselves. This is useful for making uniquely-themed variations of the same level. This is overridden by `"spriteSheet": "import"` in the "render-layer" Entity definition, so be sure to remove that when setting this property.
             *
             * @property spriteSheet
             * @type String | Object
             * @default null
             * @since 0.6.6
             */
            spriteSheet: null
        },

        publicProperties: {
            /**
             * Specifies the JSON level to load. Available on the entity as `entity.level`.
             *
             * @property level
             * @type String
             * @default null
             */
            level: null,

            /**
             * Sets how many world units in width and height correspond to a single pixel in the Tiled map. Default is 1: One pixel is one world unit. Available on the entity as `entity.unitsPerPixel`.
             *
             * @property unitsPerPixel
             * @type number
             * @default 1
             */
            unitsPerPixel: 1,

            /**
             * If images are provided, this property sets the scale of the art relative to world coordinates. Available on the entity as `entity.imagesScale`.
             *
             * @property imagesScale
             * @type number
             * @default 1
             */
            imagesScale: 1,

            /**
             * Can be "left", "right", or "center". Defines where entities registered X position should be when spawned. Available on the entity as `entity.entityPositionX`.
             *
             * @property entityPositionX
             * @type String
             * @default "center"
             */
            entityPositionX: "center",

            /**
             * Can be "top", "bottom", or "center". Defines where entities registered Y position should be when spawned. Available on the entity as `entity.entityPositionY`.
             *
             * @property entityPositionY
             * @type String
             * @default "bottom"
             */
            entityPositionY: "bottom",

            /**
             * Whether to wait for a "load-level" event before before loading. Available on the entity as `entity.manuallyLoad`.
             *
             * @property manuallyLoad
             * @type boolean
             * @default false
             */
            manuallyLoad: false
        },

        constructor: function () {
            this.assetCache = Application.instance.assetManager.cache;
            this.layerZ = 0;
            this.followEntity = false;
        },

        events: {

            /**
             * On receiving this message, the component commences loading the Tiled map JSON definition. Once finished, it removes itself from the entity's list of components.
             *
             * @method 'scene-loaded'
             * @param persistentData {Object} Data passed from the last scene into this one.
             * @param persistentData.level {Object} A level name or definition to load if the level is not already specified.
             */
            "scene-loaded": function (persistentData) {
                if (!this.manuallyLoad) {
                    this.loadLevel({
                        level: this.level || persistentData.level,
                        persistentData: persistentData
                    });
                }
            },

            /**
             * If `manuallyLoad` is set, the component will wait for this message before loading the Tiled map JSON definition.
             *
             * @method 'load-level'
             * @param levelData {Object}
             * @param levelData.level {String|Object} The level to load.
             * @param [levelData.persistentData] {Object} Information passed from the last scene.
             */
            "load-level": function (levelData) {
                this.loadLevel(levelData);
            }
        },

        methods: {
            createLayer: function (entityKind, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer) {
                var props = null,
                    width = layer.width,
                    height = layer.height,
                    tHeight = layer.tileheight || tileHeight,
                    tWidth = layer.tilewidth || tileWidth,
                    newWidth = 0,
                    newHeight = 0,
                    tileTypes = 0,
                    tileDefinition = JSON.parse(JSON.stringify(platypus.game.settings.entities[entityKind] || standardEntityLayers[entityKind])), //TODO: a bit of a hack to copy an object instead of overwrite values
                    importAnimation = null,
                    importCollision = null,
                    importRender = null,
                    renderTiles = false,
                    tileset = null,
                    jumpthroughs = null,
                    index = 0,
                    x = 0,
                    y = 0,
                    prop = "",
                    data = null;
                
                this.decodeLayer(layer);
                data = layer.data;
                
                tileDefinition.properties = tileDefinition.properties || {};

                //This builds in parallaxing support by allowing the addition of width and height properties into Tiled layers so they pan at a separate rate than other layers.
                if (layer.properties) {
                    if (layer.properties.width) {
                        newWidth  = parseInt(layer.properties.width,  10);
                    }
                    if (layer.properties.height) {
                        newHeight = parseInt(layer.properties.height, 10);
                    }
                    if (newWidth || newHeight) {
                        newWidth  = newWidth  || width;
                        newHeight = newHeight || height;
                        data      = [];
                        for (x = 0; x < newWidth; x++) {
                            for (y = 0; y < newHeight; y++) {
                                if ((x < width) && (y < height)) {
                                    data[x + y * newWidth] = layer.data[x + y * width];
                                } else {
                                    data[x + y * newWidth] = 0;
                                }
                            }
                        }
                        width  = newWidth;
                        height = newHeight;
                    }
                    
                    mergeAndFormatProperties(layer.properties, tileDefinition.properties);
                }

                importAnimation = {};
                importCollision = [];
                importRender = [];

                if (entityKind === 'collision-layer') {
                    jumpthroughs = [];
                    for (x = 0; x < tilesets.length; x++) {
                        tileset = tilesets[x];
                        if (tileset.tileproperties) {
                            for (prop in tileset.tileproperties) {
                                if (tileset.tileproperties.hasOwnProperty(prop)) {
                                    if (tileset.tileproperties[prop].jumpThrough) {
                                        jumpthroughs.push(tileset.firstgid + parseInt(prop, 10));
                                    }
                                }
                            }
                        }
                    }
                }
                
                tileDefinition.properties.width = tWidth * width * this.unitsPerPixel;
                tileDefinition.properties.height = tHeight * height * this.unitsPerPixel;
                tileDefinition.properties.columns = width;
                tileDefinition.properties.rows = height;
                tileDefinition.properties.tileWidth = tWidth * this.unitsPerPixel;
                tileDefinition.properties.tileHeight = tHeight * this.unitsPerPixel;
                tileDefinition.properties.scaleX = this.imagesScale;
                tileDefinition.properties.scaleY = this.imagesScale;
                tileDefinition.properties.layerZ = this.layerZ;
                tileDefinition.properties.left = tileDefinition.properties.x || mapOffsetX;
                tileDefinition.properties.top = tileDefinition.properties.y || mapOffsetY;
                tileDefinition.properties.z = tileDefinition.properties.z || this.layerZ;

                if (tilesets.length) {
                    tileTypes = (tilesets[tilesets.length - 1].imagewidth / tWidth) * (tilesets[tilesets.length - 1].imageheight / tHeight) + tilesets[tilesets.length - 1].firstgid;
                    for (x = -1; x < tileTypes; x++) {
                        importAnimation['tile' + x] = x;
                    }
                }
                for (x = 0; x < width; x++) {
                    importCollision[x] = [];
                    importRender[x] = [];
                    for (y = 0; y < height; y++) {
                        index = +data[x + y * width] - 1; // -1 from original src to make it zero-based.
                        importRender[x][y] = 'tile' + index;
                        index += 1; // So collision map matches original src indexes. Render (above) should probably be changed at some point as well. DDD 3/30/2016
                        if (jumpthroughs && jumpthroughs.length && (jumpthroughs[0] === (maskId & index))) {
                            index = maskJumpThrough | index;
                        }
                        importCollision[x][y] = index;
                    }
                }
                for (x = 0; x < tileDefinition.components.length; x++) {
                    if (tileDefinition.components[x].type === 'RenderTiles') {
                        renderTiles = tileDefinition.components[x];
                    }
                    if (tileDefinition.components[x].spriteSheet === 'import') {
                        tileDefinition.components[x].spriteSheet = {
                            images: (layer.image ? [layer.image] : images),
                            frames: {
                                width: tWidth * this.unitsPerPixel / this.imagesScale,
                                height: tHeight * this.unitsPerPixel / this.imagesScale,
                                regX: (tWidth * this.unitsPerPixel / this.imagesScale) / 2,
                                regY: (tHeight * this.unitsPerPixel / this.imagesScale) / 2
                            },
                            animations: importAnimation
                        };
                    } else if (tileDefinition.components[x].spriteSheet) {
                        if (typeof tileDefinition.components[x].spriteSheet === 'string' && platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet]) {
                            tileDefinition.components[x].spriteSheet = platypus.game.settings.spriteSheets[tileDefinition.components[x].spriteSheet];
                        }
                        if (!tileDefinition.components[x].spriteSheet.animations) {
                            tileDefinition.components[x].spriteSheet.animations = importAnimation;
                        }
                    }
                    if (tileDefinition.components[x].collisionMap === 'import') {
                        tileDefinition.components[x].collisionMap = importCollision;
                    }
                    if (tileDefinition.components[x].imageMap === 'import') {
                        tileDefinition.components[x].imageMap = importRender;
                    }
                }
                this.layerZ += this.layerIncrement;

                if ((entityKind === 'render-layer') && (!this.separateTiles) && combineRenderLayer && (combineRenderLayer.tileHeight === tHeight) && (combineRenderLayer.tileWidth === tWidth) && (combineRenderLayer.columns === width) && (combineRenderLayer.rows === height)) {
                    combineRenderLayer.triggerEvent('add-tiles', renderTiles);
                    return combineRenderLayer;
                } else {
                    props = {};
                    if ((entityKind === 'render-layer') && this.spriteSheet) {
                        if (typeof this.spriteSheet === 'string') {
                            props.spriteSheet = platypus.game.settings.spriteSheets[this.spriteSheet];
                        } else {
                            props.spriteSheet = this.spriteSheet;
                        }
                        if (!props.spriteSheet.animations) {
                            props.spriteSheet.animations = importAnimation;
                        }
                    }
                    return this.owner.addEntity(new Entity(tileDefinition, {
                        properties: props
                    }));
                }
            },
            
            convertImageLayer: function (imageLayer, tileHeight, tileWidth) {
                var i = 0,
                    dataCells = 0,
                    props = imageLayer.properties || {},
                    tileLayer = {
                        data: [],
                        image: '',
                        height: 1,
                        name: imageLayer.name,
                        type: 'tilelayer',
                        width: 1,
                        tileheight: tileHeight,
                        tilewidth: tileWidth,
                        x: imageLayer.x,
                        y: imageLayer.y,
                        properties: props
                    };

                if (props.repeat) {
                    tileLayer.width = +props.repeat;
                    tileLayer.height = +props.repeat;
                }
                if (props['repeat-x']) {
                    tileLayer.width = +props['repeat-x'];
                }
                if (props['repeat-y']) {
                    tileLayer.height = +props['repeat-y'];
                }
                dataCells = tileLayer.width * tileLayer.height;
                for (i = 0; i < dataCells; i++) {
                    tileLayer.data.push(1);
                }

                // Prefer to have name in tiled match image id in game
                if (this.assetCache.read(imageLayer.name)) {
                    tileLayer.image = imageLayer.name;
                    tileLayer.tileheight = this.assetCache.read(imageLayer.name).height;
                    tileLayer.tilewidth = this.assetCache.read(imageLayer.name).width;
                } else {
                    platypus.debug.warn('Component TiledLoader: Cannot find the "' + imageLayer.name + '" sprite sheet. Add it to the list of assets in config.json and give it the id "' + imageLayer.name + '".');
                    tileLayer.image = imageLayer.image;
                }

                return tileLayer;
            },
            
            loadLevel: function (levelData) {
                var actionLayerCollides = true,
                    layers = null,
                    level = null,
                    height = 0,
                    i = 0,
                    images = null,
                    layer = null,
                    layerDefinition = null,
                    tilesets = null,
                    tileWidth = 0,
                    tileHeight = 0,
                    progress = Data.setUp('count', 0, 'progress', 0, 'total', 0),
                    width = 0,
                    x = 0,
                    y = 0,
                    message = Data.setUp(
                        "level", null,
                        "world", AABB.setUp(),
                        "width", 0, // deprecate in 0.8.0
                        "height", 0, // deprecate in 0.8.0
                        "tile", AABB.setUp(),
                        "camera", null
                    );
                
                //format level appropriately
                if (typeof levelData.level === 'string') {
                    level = platypus.game.settings.levels[levelData.level];
                } else {
                    level = levelData.level;
                }
                layers = level.layers;
                tilesets = importTilesetData(level.tilesets);
                tileWidth = level.tilewidth;
                tileHeight = level.tileheight;

                if (level.properties) {
                    mergeAndFormatProperties(level.properties, this.owner);
                }
                
                if (this.images) {
                    images = this.images.greenSlice();
                } else {
                    images = Array.setUp();
                }
                if (images.length === 0) {
                    for (i = 0; i < tilesets.length; i++) {
                        if (this.assetCache.read(tilesets[i].name)) { // Prefer to have name in tiled match image id in game
                            images.push(tilesets[i].name);
                        } else {
                            platypus.debug.warn('Component TiledLoader: Cannot find the "' + tilesets[x].name + '" sprite sheet. Add it to the list of assets in config.json and give it the id "' + tilesets[x].name + '".');
                            images.push(tilesets[i].image);
                        }
                    }
                }
                
                width = level.width * tileWidth * this.unitsPerPixel;
                height = level.height * tileHeight * this.unitsPerPixel;

                if (this.offsetMap) {
                    x = getPowerOfTen(width);
                    y = getPowerOfTen(height);
                }

                progress.total = i = layers.length;
                while (i--) { // Prepatory pass through layers.
                    if (layers[i].type === 'objectgroup') {
                        progress.total += layers[i].objects.length;
                    } else if (actionLayerCollides && ((layers[i].name === 'collision') || (layers[i].properties && layers[i].properties.entity === 'collision-layer'))) {
                        actionLayerCollides = false;
                    }
                }

                for (i = 0; i < layers.length; i++) {
                    layerDefinition = layers[i];
                    switch (layerDefinition.type) {
                    case 'imagelayer':
                        layer = this.createLayer('image-layer', this.convertImageLayer(layerDefinition, tileHeight, tileWidth), x, y, tileWidth, tileHeight, tilesets, images, layer);
                        break;
                    case 'objectgroup':
                        this.setUpEntities(layerDefinition, x, y, tileWidth, tileHeight, tilesets, progress);
                        layer = null;
                        break;
                    case 'tilelayer':
                        layer = this.setupLayer(layerDefinition, actionLayerCollides, layer, x, y, tileWidth, tileHeight, tilesets, images);
                        break;
                    default:
                        platypus.debug.warn('TiledLoader: Platypus does not support Tiled layers of type "' + layerDefinition.type + '". This layer will not be loaded.');
                    }
                    this.updateLoadingProgress(progress);
                }
                
                progress.recycle();

                /**
                 * Once finished loading the map, this message is triggered on the entity to notify other components of completion.
                 *
                 * @event 'world-loaded'
                 * @param message {platypus.Data} World data.
                 * @param message.level {Object} The Tiled level data used to load the level.
                 * @param message.width {number} The width of the world in world units.
                 * @param message.height {number} The height of the world in world units.
                 * @param message.tile {platypus.AABB} Dimensions of the world tiles.
                 * @param message.world {platypus.AABB} Dimensions of the world.
                 * @param message.camera {platypus.Entity} If a camera property is found on one of the loaded entities, this property will point to the entity on load that a world camera should focus on.
                 */
                message.level = level;
                message.camera = this.followEntity; // TODO: in 0.9.0 this should probably be removed, using something like "child-entity-added" instead. Currently this is particular to TiledLoader and Camera and should be generalized. - DDD 3/15/2016
                message.width = width;
                message.height = height;
                message.world.setBounds(x, y, x + width, y + height);
                message.tile.setBounds(0, 0, tileWidth, tileHeight);
                this.owner.triggerEvent('world-loaded', message);
                message.world.recycle();
                message.tile.recycle();
                message.recycle();
                
                this.owner.removeComponent(this);
            },
            
            setUpEntities: function (layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, progress) {
                var clamp = 1000,
                    widthOffset = 0,
                    heightOffset = 0,
                    x = 0,
                    p = 0,
                    w = 0,
                    h = 0,
                    a = 0,
                    v = null,
                    obj = 0,
                    entity = null,
                    entityDefinition = null,
                    entityDefProps = null,
                    entityPositionX = "",
                    entityPositionY = "",
                    entityType = '',
                    gid = -1,
                    smallestX = Infinity,
                    largestX = -Infinity,
                    smallestY = Infinity,
                    largestY = -Infinity,
                    entityData = null,
                    properties = null,
                    polyPoints = null,
                    fallbackWidth = 0,
                    fallbackHeight = 0;

                entityPositionX = this.entityPositionX;
                entityPositionY = this.entityPositionY;

                if (layer.properties) {
                    if (layer.properties.entityPositionX) {
                        entityPositionX = layer.properties.entityPositionX;
                    }
                    if (layer.properties.entityPositionY) {
                        entityPositionY = layer.properties.entityPositionY;
                    }
                }

                for (obj = 0; obj < layer.objects.length; obj++) {
                    entity     = layer.objects[obj];
                    entityData = getEntityData(entity, tilesets);
                    if (entityData) {
                        gid = entityData.gid;
                        entityType = entityData.type;
                        entityDefinition = platypus.game.settings.entities[entityType];
                        if (entityDefinition) {
                            entityDefProps = entityDefinition.properties || null;
                        } else {
                            entityDefProps = null;
                        }
                        properties = entityData.properties;

                        if (entity.polygon || entity.polyline) {
                            //Figuring out the width of the polygon and shifting the origin so it's in the top-left.
                            smallestX = Infinity;
                            largestX = -Infinity;
                            smallestY = Infinity;
                            largestY = -Infinity;

                            polyPoints = null;
                            if (entity.polygon) {
                                polyPoints = entity.polygon;
                            } else if (entity.polyline) {
                                polyPoints = entity.polyline;
                            }

                            for (x = 0; x < polyPoints.length; x++) {
                                if (polyPoints[x].x > largestX) {
                                    largestX = polyPoints[x].x;
                                }
                                if (polyPoints[x].x < smallestX) {
                                    smallestX = polyPoints[x].x;
                                }
                                if (polyPoints[x].y > largestY) {
                                    largestY = polyPoints[x].y;
                                }
                                if (polyPoints[x].y < smallestY) {
                                    smallestY = polyPoints[x].y;
                                }
                            }
                            properties.width = largestX - smallestX;
                            properties.height = largestY - smallestY;
                            properties.x = entity.x + smallestX;
                            properties.y = entity.y + smallestY;

                            widthOffset = 0;
                            heightOffset = 0;
                            properties.width = properties.width * this.unitsPerPixel;
                            properties.height = properties.height * this.unitsPerPixel;

                            properties.x = properties.x * this.unitsPerPixel + mapOffsetX;
                            properties.y = properties.y * this.unitsPerPixel + mapOffsetY;

                            if (entity.polygon) {
                                properties.shape = {};
                                properties.shape.type = 'polygon';
                                properties.shape.points = [];
                                for (p = 0; p < polyPoints.length; p++) {
                                    properties.shape.points.push({
                                        "x": ((polyPoints[p].x - smallestX) * this.unitsPerPixel + mapOffsetX),
                                        "y": ((polyPoints[p].y - smallestY) * this.unitsPerPixel + mapOffsetY)
                                    });
                                }
                            } else if (entity.polyline) {
                                properties.shape = {};
                                properties.shape.type = 'polyline';
                                properties.shape.points = [];
                                for (p = 0; p < polyPoints.length; p++) {
                                    properties.shape.points.push({
                                        "x": ((polyPoints[p].x - smallestX) * this.unitsPerPixel + mapOffsetX),
                                        "y": ((polyPoints[p].y - smallestY) * this.unitsPerPixel + mapOffsetY)
                                    });
                                }
                            }
                        } else {
                            fallbackWidth = tileWidth * this.unitsPerPixel;
                            fallbackHeight = tileHeight * this.unitsPerPixel;
                            widthOffset = 0;
                            heightOffset = 0;
                            properties.width = (entity.width || 0) * this.unitsPerPixel;
                            properties.height = (entity.height || 0) * this.unitsPerPixel;

                            if (entityDefProps) {
                                if (typeof entityDefProps.width === 'number') {
                                    properties.width = entityDefProps.width;
                                    widthOffset = fallbackWidth;
                                }
                                if (typeof entityDefProps.height === 'number') {
                                    properties.height = entityDefProps.height;
                                    heightOffset = fallbackHeight;
                                }
                            }

                            if (!properties.width) {
                                properties.width = fallbackWidth;
                            }
                            if (!properties.height) {
                                properties.height = fallbackHeight;
                            }
                            widthOffset = widthOffset || properties.width;
                            heightOffset = heightOffset || properties.height;

                            properties.x = entity.x * this.unitsPerPixel;
                            properties.y = entity.y * this.unitsPerPixel;

                            if (entity.rotation) {
                                w = (entity.width || fallbackWidth) / 2;
                                h = (entity.height || fallbackHeight) / 2;
                                a = ((entity.rotation / 180) % 2) * Math.PI;
                                v = platypus.Vector.setUp(w, -h).rotate(a);
                                properties.rotation = entity.rotation;
                                properties.x = Math.round((properties.x + v.x - w) * clamp) / clamp;
                                properties.y = Math.round((properties.y + v.y + h) * clamp) / clamp;
                                v.recycle();
                            }

                            if (entityPositionX === 'left') {
                                properties.regX = 0;
                            } else if (entityPositionX === 'center') {
                                properties.regX = properties.width / 2;
                                properties.x += widthOffset / 2;
                            } else if (entityPositionX === 'right') {
                                properties.regX = properties.width;
                                properties.x += widthOffset;
                            }
                            properties.x += mapOffsetX;

                            if (gid === -1) {
                                properties.y += properties.height;
                            }
                            if (entityPositionY === 'bottom') {
                                properties.regY = properties.height;
                            } else if (entityPositionY === 'center') {
                                properties.regY = properties.height / 2;
                                properties.y -= heightOffset / 2;
                            } else if (entityPositionY === 'top') {
                                properties.regY = 0;
                                properties.y -= heightOffset;
                            }
                            properties.y += mapOffsetY;

                            if (entity.ellipse) {
                                properties.shape = {};
                                properties.shape.type = 'ellipse';
                                properties.shape.width = properties.width * this.unitsPerPixel;
                                properties.shape.height = properties.height * this.unitsPerPixel;
                            } else if (entity.width && entity.height) {
                                properties.shape = {};
                                properties.shape.type = 'rectangle';
                                properties.shape.width = properties.width * this.unitsPerPixel;
                                properties.shape.height = properties.height * this.unitsPerPixel;
                            }
                        }

                        if (entityDefProps) {
                            properties.scaleX *= this.imagesScale * (entityDefProps.scaleX || 1); //this.unitsPerPixel;
                            properties.scaleY *= this.imagesScale * (entityDefProps.scaleY || 1); //this.unitsPerPixel;
                        } else {
                            properties.scaleX *= this.imagesScale;
                            properties.scaleY *= this.imagesScale;
                        }
                        properties.layerZ = this.layerZ;

                        //Setting the z value. All values are getting added to the layerZ value.
                        if (properties.z) {
                            properties.z += this.layerZ;
                        } else if (entityDefProps && (typeof entityDefProps.z === 'number')) {
                            properties.z = this.layerZ + entityDefProps.z;
                        } else {
                            properties.z = this.layerZ;
                        }

                        properties.parent = this.owner;
                        entity = this.owner.addEntity(new Entity(entityDefinition, {
                            properties: properties
                        }));
                        if (entity) {
                            if (entity.camera) {
                                this.followEntity = {
                                    entity: entity,
                                    mode: entity.camera
                                }; //used by camera
                            }
                            this.owner.triggerEvent('entity-created', entity);
                        }
                    }
                    this.updateLoadingProgress(progress);
                }
                this.layerZ += this.layerIncrement;
            },

            setupLayer: function (layer, layerCollides, combineRenderLayer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images) {
                var entity = 'render-layer'; // default
                
                // First determine which type of entity this layer should behave as:
                if (layer.properties && layer.properties.entity) {
                    entity = layer.properties.entity;
                } else if (layer.name === "collision") {
                    entity = 'collision-layer';
                } else if (layer.name === "action") {
                    if (layerCollides) {
                        entity = 'tile-layer';
                    } else {
                        entity = 'render-layer';
                    }
                }

                if (entity === 'tile-layer' || (this.showCollisionTiles && platypus.game.settings.debug)) {
                    this.createLayer('collision-layer', layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer);
                    return this.createLayer('render-layer', layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer);
                } else if (entity === 'collision-layer') {
                    this.createLayer('collision-layer', layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer);
                    return null;
                } else {
                    return this.createLayer(entity, layer, mapOffsetX, mapOffsetY, tileWidth, tileHeight, tilesets, images, combineRenderLayer);
                }
            },
            
            updateLoadingProgress: function (progress) {
                progress.count += 1;
                progress.progress = progress.count / progress.total;

                /**
                 * As a level is loaded, this event is triggered to show progress.
                 *
                 * @event 'level-loading-progress'
                 * @param message {platypus.Data} Contains progress data.
                 * @param message.count {Number} The number of loaded entities.
                 * @param message.progress {Number} A fraction of count / total.
                 * @param message.total {Number} The total number of entities being loaded by this component.
                 * @since 0.8.3
                 */
                this.owner.triggerEvent('level-loading-progress', progress);
            },

            destroy: function () {
            }
        },
        
        publicMethods: {
            /**
             * This method decodes a Tiled layer and sets its data to CSV format.
             *
             * @method decodeLayer
             * @param layer {Object} An object describing a Tiled JSON-exported layer.
             * @return {Object} The same object provided, but with the data field updated.
             * @chainable
             * @since 0.7.1
             */
            decodeLayer: function (layer) {
                if (layer.encoding === 'base64') {
                    layer.data = decodeBase64(layer.data, layer.compression);
                    layer.encoding = 'csv'; // So we won't have to decode again.
                }
                return layer;
            }
        },
        
        getAssetList: function (def, props, defaultProps) {
            var ps = props || {},
                dps = defaultProps || {},
                ss     = def.spriteSheet || ps.spriteSheet || dps.spriteSheet,
                images = def.images || ps.images || dps.images,
                assets = checkLevel(def.level || ps.level || dps.level, ss);
            
            if (ss) {
                if (typeof ss === 'string') {
                    assets.union(platypus.game.settings.spriteSheets[ss].images);
                } else {
                    assets.union(ss.images);
                }
            }
            
            if (images) {
                assets.union(images);
            }
            
            return assets;
        },
        
        getLateAssetList: function (def, props, defaultProps, data) {
            var ps  = props || {},
                dps = defaultProps || {},
                ss  = def.spriteSheet || ps.spriteSheet || dps.spriteSheet;

            if (data && data.level) {
                return checkLevel(data.level, ss);
            } else {
                return Array.setUp();
            }
        }
    });
}());

//##############################################################################
// Timeline.js
//##############################################################################

/**
 * Timeline enables the scheduling of events based on a linear timeline
 *
 * @class Timeline
 * @uses platypus.Component
 * @since 0.8.7
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var Data = include('platypus.Data'),
        pause = function () {
            this.active--;
        },
        play = function () {
            this.active++;
        },
        timelineTrigger = function (timelineId) {
            this.timelineInstances.push(this.createTimeStampedTimeline(this.timelines[timelineId]));
        },
        updateLogic = function (tick) {
            var delta = tick.delta,
                instance = null,
                instances = this.timelineInstances,
                i = instances.length;
            
            while (i--) {
                instance = instances[i];
                if (instance.active) {
                    if (instance.timeline.length === 0) {
                        instances.greenSplice(i);
                        instance.timeline.recycle(2);
                        instance.recycle();
                    } else {
                        this.progressTimeline(instance, delta);
                    }
                }
            }
        };
    
    return platypus.createComponentClass({
        
        id: 'Timeline',
        
        properties: {
            /**
             * Defines the set of timelines. Triggering the key for one of the events will run the timeline. A timeline can contain three different types integers >= 0, strings, and objects. Integers are interpreted as waits and define
             * pauses between events. Strings are intepreted as event calls. Objects can contain several parameters: entity, event, message. The entity is the id of the entity that
             * the event will be fired on. The event can be a string or array. If a string, it will call that event on the entity or owner. If an array, the value will be passed
             * to the event handling system.
             *
             *  "timelines": {
             *      "sample-timeline-1": [
             *          500,
             *          "sample-event",
             *          {"event": "sample-event", "message": "sample-message"},
             *          {"entity": "entity-id-to-trigger-event-on", "event": "sample-event"},
             *          {"event": ["sample-event", "sample-event-2", {"event": "sample-event-3", "message": "sample-message"}]},
             *      ],
             *      "sample-timeline-2": [
             *          200,
             *          "sample-event"
             *      ]
             * }
             *
             * @property timelines
             * @type Object
             * @default {}
             */
            "timelines": {}
        },
        
        constructor: function () {
            var x = 0;
            
            this.timelineInstances = Array.setUp();
            for (x in this.timelines) {
                if (this.timelines.hasOwnProperty(x)) {
                    this.addEventListener(x, timelineTrigger.bind(this, x));
                }
            }
        },

        events: {
            //Using both logic-tick and handle-logic allows this to work at the Scene level or entity level.
            /**
             * Checks game clock against timelines and triggers events as needed.
             *
             * @method 'logic-tick'
             * @param tick.delta {Number} The length of the tick.
             */
            "logic-tick": updateLogic,

            /**
             * Checks game clock against timelines and triggers events as needed.
             *
             * @method 'handle-logic'
             * @param tick.delta {Number} The length of the tick.
             */
            "handle-logic": updateLogic
        },
        
        methods: {
            createTimeStampedTimeline: function (timeline) {
                var timeStampedTimeline = Array.setUp(),
                    x = 0,
                    timeOffset = 0,
                    entry = null;
                
                for (x = 0; x < timeline.length; x++) {
                    entry = timeline[x];
                    if (typeof entry === 'number') {
                        timeOffset += entry;
                    } else {
                        timeStampedTimeline.push(Data.setUp(
                            "time", timeOffset,
                            "value", entry
                        ));
                    }
                }
                timeStampedTimeline.reverse();
                return Data.setUp(
                    "timeline", timeStampedTimeline,
                    "time", 0,
                    "active", 1,
                    "pause", pause,
                    "play", play
                );
            },
            progressTimeline: function (instance, delta) {
                var timeline = instance.timeline,
                    i = timeline.length,
                    entry = null,
                    value = null,
                    triggerOn = this.owner;
                
                instance.time += delta;
                
                //Go through the timeline playing events if the time has progressed far enough to trigger them.
                while (i--) {
                    entry = timeline[i];
                    if (entry.time <= instance.time) {
                        value = entry.value;
                        if (typeof value === 'string') {
                            this.owner.triggerEvent(value);
                        } else {
                            if (value.entity) {
                                if (this.owner.getEntityById) {
                                    triggerOn = this.owner.getEntityById(value.entity);
                                } else {
                                    triggerOn = this.owner.parent.getEntityById(value.entity);
                                }
                                
                                if (!triggerOn) {
                                    platypus.debug.warn('No entity of that id');
                                    triggerOn = this.owner;
                                }
                            }
                            
                            if (value.message) {
                                triggerOn.triggerEvent(value.event, value.message);
                            } else {
                                triggerOn.trigger(value.event);
                            }
                        }
                        
                        entry.recycle();
                        timeline.pop(); //Remove the entry.
                        if (!instance.active) {
                            return; //We bail until the callback.
                        }
                    } else {
                        return;
                    }
                    
                    entry = null;
                    value = null;
                    triggerOn = this.owner;
                }
            },
            destroy: function () {
                var instance = null,
                    instances = this.timelineInstances,
                    i = instances.length;
                
                while (i--) {
                    instance = instances[i];
                    instance.timeline.recycle(2);
                    instance.recycle();
                }
                instances.recycle();
                this.timelineInstances = null;
            }
        }
    });
}());

//##############################################################################
// Tutorial.js
//##############################################################################

/**
 * Tutorial provides a framework for playing tutorials. It allows the user to define things such as under what conditions tutorials will play, how often they play, and which tutorials have priority.
 *
 * @class Tutorial
 * @uses platypus.Component
 * @since 0.8.7
 */
/*global platypus */
(function () {
    'use strict';
    var entityAdded = function (entity) {
            var entityType = null;
                
            for (entityType in this.watchedEntities) {
                if (entity.type === entityType) {
                    this.watchedEntities[entityType].push(entity);
                }
            }
        },
        entityRemoved = function (entity) {
            var x = 0,
                entityType = entity.type;

            for (x = this.watchedEntities[entityType].length - 1; x >= 0; x--) {
                if (this.watchedEntities[entityType][x] === entity) {
                    this.watchedEntities[entityType].splice(x, 1);
                    break;
                }
            }
        },
        updateLogic = function (tick) {
            var delta = tick.delta,
                x = 0,
                tut = null,
                toPlay = null,
                toPlayIndex = -1,
                keepChecking = false,
                tutorial = null;
            
            for (x = 0; x < this.tutorials.length; x++) {
                keepChecking = false;
                tut = this.tutorials[x];

                if (!this.playing && this.theQueue.length === 0) {
                    keepChecking = true;
                } else if ((!this.playing && this.theQueue.length > 0) && (tut.priority > this.theQueue[0].priority)) {
                    keepChecking = true;
                } else if (this.playing && (this.playing.priority < tut.priority)) {
                    keepChecking = true;
                } else if (tut.queue) {
                    keepChecking = true;
                }

                if (!keepChecking) {
                    continue;
                }

                if (this.checkRequirements(tut.requirements)) {
                    if (tut.replayDelay && tut.replayDelayTimer > 0) {
                        tut.replayDelayTimer -= delta;
                        if (tut.replayDelayTimer > 0) {
                            continue;
                        }
                    }
                    
                    if (!toPlay || toPlay.priority < tut.priority) {
                        //TML - If we only have one item we try to play, then we may prevent certain audio from playing if it's only valid for a single tick.
                        toPlay = tut;
                        toPlayIndex = x;
                    }
                }
            }

            if (toPlay) {
                tutorial = this.tutorials.splice(toPlayIndex, 1)[0];
                if (this.playing) {
                    if (tutorial.priority > this.playing.priority) {
                        this.owner.triggerEvent('stop-audio');
                        this.play(tutorial);
                    } else {
                        this.queue(tutorial);
                    }
                } else if (this.theQueue.length > 0) {
                    if (tutorial.priority > this.theQueue[0].priority) {
                        this.play(tutorial);
                    } else {
                        this.play(this.theQueue.splice(0, 1)[0]);
                        this.queue(tutorial);
                    }
                } else {
                    this.play(tutorial);
                }
            } else if (!this.playing && this.theQueue.length > 0) {
                this.play(this.theQueue.splice(0, 1)[0]);
            }
        };

    return platypus.createComponentClass({
        
        id: 'Tutorial',
        
        properties: {
            
            /* An array of tutorial definition objects. These objects define what events will be called by the tutorial, the priority of the tutorial, how often and how many times it will fire, the required conditions for it to fire, and more.
             *
             * "tutorialDefs": [
             *      {
             *          "events": ["example-vo-event"],         //An Array of Strings. Defines the events to fire when all the conditions for this tutorial are met. If there are multiple events, one is chosen at random. All events in the array will play before any repeat.
             *          "priority": 5,                          //The priorioty of the tutorial. Higher numbered tutorials interrupt lower numbered. Default: 0.
             *          "queue": true,                          //Will the tutorial queue up if played while another tutorial is playing? Default: false.
             *          "timesToReplay": 3,                     //The number of times a tutorial will replay. Set to 0 to make a tutorial play only once. Default: Infinity.
             *          "replayDelay": 10000,                   //While the conditions are met, the tutorial will replay at this interval in milliseconds. If set to null, it will not repeat. Default: null.
             *          "level": "example-level",               //Tutorial will only play when this level is the currently loaded level.
             *          "requirements": {                       //The requirements is a collection of entities types that are watched by the tutorial to determine if the conditions to play this tutorial are true.
             *              "example-entity-type": ["example-entity-state"]     //The requirements is a set of key-value pairs. The keys are entity types that the tutorial will watch. The values are arrays of states of that entity type which must be true for the tutorial to play.
             *          }
             *      }
             * ]
             *
             * @property tutorialDefs
             * @type Array [Object]
             * @default []
             */
            "tutorialDefs": []
        },
         
        publicProperties: {
            
        },
        
        constructor: function () {
            var x = 0,
                entityType = null,
                tutDef = null,
                tutorial = null;
                
            this.playing = null;
            this.theQueue = [];
            this.watchedEntities = {};
            this.tutorials = [];

                
            for (x = 0; x < this.tutorialDefs.length; x++) {
                tutDef = this.tutorialDefs[x];
                tutorial = {};
                if (!tutDef.events) {
                    platypus.debug.warn("Tutorial definition lacks events.");
                    continue;
                }
                tutorial.events = tutDef.events.greenSlice();
                tutorial.originalEvents = tutDef.events.greenSlice();
                tutorial.priority = tutDef.priority || 0;
                tutorial.queue = tutDef.queue || false;
                tutorial.timesToReplay = (typeof tutDef.timesToReplay === 'number') ? tutDef.timesToReplay : Infinity;
                tutorial.replayDelay = tutDef.replayDelay || null;
                tutorial.replayDelayTimer = tutorial.replayDelay;
                tutorial.level = tutDef.level;
                tutorial.requirements = {};
                for (entityType in tutDef.requirements) {
                    if (tutDef.requirements.hasOwnProperty(entityType)) {
                        tutorial.requirements[entityType] = tutDef.requirements[entityType].greenSlice();
                        if (!this.watchedEntities[entityType]) {
                            this.watchedEntities[entityType] = [];
                        }
                    }
                }
                this.tutorials.push(tutorial);
            }
            
        },

        events: {// These are messages that this component listens for
            
            /**
             * Checks added entity to determine if it is one of the conditions for one of the tutorials. If so, we track it.
             *
             * @method 'child-entity-added'
             * @param entity {Object} The added entity.
             */
            "child-entity-added": entityAdded,

            /**
             * Checks added entity to determine if it is one of the conditions for one of the tutorials. If so, we track it.
             *
             * @method 'peer-entity-added'
             * @param entity {Object} The added entity.
             */
            "peer-entity-added": entityAdded,

            /**
             * Removes entities from the watch list when they are destroyed.
             *
             * @method 'child-entity-removed'
             * @param entity {Object} The removed entity.
             */
            "child-entity-removed": entityRemoved,

            /**
             * Removes entities from the watch list when they are destroyed.
             *
             * @method 'peer-entity-removed'
             * @param entity {Object} The removed entity.
             */
            "peer-entity-removed": entityRemoved,
            
            //Using both logic-tick and handle-logic allows this to work at the Scene level or entity level.
             /**
             * Checks tutorials to determine if they should play.
             *
             * @method 'logic-tick'
             * @param tick.delta {Number} The length of the tick.
             */
            "logic-tick": updateLogic,

            /**
             * Checks tutorials to determine if they should play.
             *
             * @method 'handle-logic'
             * @param tick.delta {Number} The length of the tick.
             */
            "handle-logic": updateLogic,

            /**
             * Fired when audioVO finishes. Clears the playing tutorial returning it to the internal list of tutorials if it will be played again.
             *
             * @method 'sequence-complete'
             */
            "sequence-complete": function () {
                if (this.playing.timesToReplay >= 0) {
                    this.tutorials.push(this.playing);
                }
                this.playing = null;
            }
        },
        
        methods: {// These are internal methods that are invoked by this component.
            play: function (tutorial) {
                var toCall = null;

                this.playing = tutorial;
                if (this.playing.events.length === 0) {
                    this.playing.events = this.playing.originalEvents.greenSlice();
                }

                toCall = this.playing.events.splice(Math.floor(Math.random() * this.playing.events.length), 1)[0];

                this.owner.triggerEvent(toCall);

                tutorial.timesToReplay -= 1;
                tutorial.replayDelayTimer = tutorial.replayDelay;
            },
            queue: function (tutorial) {
                var x = 0,
                    added = false;

                for (x = 0; x < this.theQueue.length; x++) {
                    if (this.theQueue[x].priority < tutorial.priority) {
                        this.theQueue.splice(x, 0, tutorial);
                        added = true;
                        break;
                    }
                }
                
                if (!added) {
                    this.theQueue.push(tutorial);
                }
            },
            checkRequirements: function (requirements) {
                var x = 0,
                    y = 0,
                    entityType = null,
                    states = null,
                    anEntity = null,
                    metRequirement = true;

                for (entityType in requirements) { //Going through the types of entities
                    if (requirements.hasOwnProperty(entityType)) {
                        states = requirements[entityType];
                        for (y = this.watchedEntities[entityType].length - 1; y >= 0; y--) {  //Going through the instances of those entities
                            anEntity = this.watchedEntities[entityType][y];
                            metRequirement = true;
                            for (x = 0; x < states.length; x++) {   //Going through the required states of an entity instance
                                if (!anEntity.state.get(states[x])) {
                                    metRequirement = false;
                                    break;
                                }
                            }
                            if (metRequirement) {
                                break;
                            }
                        }
                        if (!metRequirement) {
                            return false;
                        }
                    }
                }
                return true;
            },
            destroy: function () {
                this.watchedEntities = null;
                this.theQueue = null;
                this.playing = null;
                this.tutorials = null;
            }
        }
    });
}());

//##############################################################################
// Tween.js
//##############################################################################

/**
# COMPONENT **Tween**
Tween takes a list of tween definitions and plays them as needed.

## Dependencies
- [[TweenJS]] - This component requires the CreateJS TweenJS module.

## Messages

### Listens for:
- **[Messages specified in definition]** - Listens for messages and on receiving them, begins playing the corresponding tween.

### Local Broadcasts:
- **[Messages specified in definition]** - Broadcasts messages from a given tween definition.

## JSON Definition
    {
      "type": "Tween",

      "events": {
      // Required. A key/value list of events and an array representing the tween they should trigger.

            "begin-flying": [
            // When "begin-flying" is triggered on this entity, the following tween begins. Tween definitions adhere to a similar structure outlined by the TweenJS documentation. Each milestone on the tween is an item in this array.

                ["to", {
                    "scaleY": 1,
                    "y": 400
                }, 500],
                // If the definition is an array, the first parameter is the type of milestone, in this case "to", with all following parameters passed directly to the equivalent Tween function.
                
                ["call", "fly"],
                // "call" milestones can take a function or a string. If it's a string, the string will be triggered as an event on the entity. In this case, the component will trigger "fly".
            ]
        }
    }
*/
/* global createjs, platypus */
(function () {
    'use strict';

    var createTrigger = function (entity, event, message, debug) {
            return function () {
                entity.trigger(event, message, debug);
            };
        },
        createTween = function (definition) {
            return function (values) {
                var i  = 0,
                    tweens = definition,
                    tweenDef = null,
                    arr = null,
                    tween = createjs.Tween.get(this.owner);

                if (Array.isArray(values)) {
                    tweens = values;
                } else if (!Array.isArray(tweens)) {
                    return;
                }

                for (i = 0; i < tweens.length; i++) {
                    tweenDef = tweens[i];
                    if (typeof tweenDef === 'string') {
                        tween.call(createTrigger(this.owner, tweenDef));
                    } else if (Array.isArray(tweenDef)) {
                        if (tweenDef[0] === 'call' && typeof tweenDef[1] === 'string') {
                            tween.call(createTrigger(this.owner, tweenDef[1]));
                        } else {
                            arr = tweenDef.greenSlice();
                            arr.greenSplice(0);
                            tween[tweenDef[0]].apply(tween, arr);
                            arr.recycle();
                        }
                    } else if (tweenDef.method === 'call' && typeof tweenDef.params === 'string') {
                        tween.call(createTrigger(this.owner, tweenDef.params));
                    } else {
                        tween[tweenDef.method].apply(tween, tweenDef.params);
                    }
                }
            };
        };

    return platypus.createComponentClass({
        id: 'Tween',
        
        constructor: function (definition) {
            var event = '';
            
            if (definition.events) {
                for (event in definition.events) {
                    if (definition.events.hasOwnProperty(event)) {
                        this.addEventListener(event, createTween(definition.events[event]));
                    }
                }
            }
        }
    });
}());

//##############################################################################
// XHR.js
//##############################################################################

/**
 * This component provides component-based XHR communication with a server.
 *
 * @namespace platypus.components
 * @class XHR
 * @uses platypus.Component
 */
/*global include, platypus */
(function () {
    'use strict';
    
    var XMLHttpRequest = include('window.XMLHttpRequest');

    return platypus.createComponentClass({
        id: 'XHR',
        
        properties: {
            /**
             * Sets the XHR method to use.
             *
             * @property method
             * @type String
             * @default "GET"
             */
            method: "GET",
            
            /**
             * Sets the path to connect to the server.
             *
             * @property path
             * @type String
             * @default ""
             */
            path: "",
            
            /**
             * Sets the XHR response type.
             *
             * @property responseType
             * @type String
             * @default "text"
             */
            responseType: "text",
            
            /**
             * Whether cookies should be retained on cross-domain calls.
             *
             * @property withCredentials
             * @type boolean
             * @default false
             */
            withCredentials: false
        },
        
        constructor: function (definition) {
            this.setProperties(definition);
        },

        events: {// These are messages that this component listens for
            /**
             * On receiving this message, this component makes a request from the server using the provided information. Note that properties set here will reset the properties set by this component's JSON definition.
             *
             * @method 'request'
             * @param message {Object}
             * @param message.method {String} XHR method to use: must be "GET" or "POST".
             * @param message.path {String} The path to the server resource.
             * @param [message.responseType="text"] {String} Response type expected.
             * @param [message.data] {Object} An object of string key/value pairs to be transmitted to the server.
             * @param message.onload {Function} A function that should be run on receiving a response from the server. This defaults to triggering a "response" message containing the responseText value.
             */
            "request": function (resp) {
                this.setProperties(resp);
                
                if (this.method === "GET") {
                    this.get();
                } else if (this.method === "POST") {
                    this.post();
                } else {
                    throw "Method must be GET or POST";
                }
            }
        },
        
        methods: {// These are methods that are called on the component
            setProperties: function (properties) {
                var key     = '',
                    divider = '',
                    props   = properties || this;
                
                this.method       = props.method       || this.method       || "GET";
                this.path         = props.path         || this.path         || null;
                this.responseType = props.responseType || this.responseType || "text";
                this.withCredentials = props.withCredentials || this.withCredentials || false;
                
                if ((props !== this) && props.data) {
                    this.data = '';
                    for (key in props.data) {
                        if (props.data.hasOwnProperty(key)) {
                            this.data += divider + key + '=' + props.data[key];
                            divider = '&';
                        }
                    }
                } else {
                    this.data = '';
                }
                
                this.onload = props.onload || this.onload || function () {
                    if (this.status === 200) {
                        /**
                         * This message is triggered on receiving a response from the server (if "onload" is not set by the original "request" message).
                         *
                         * @event 'response'
                         * @param message {String} The message contains the responseText returned by the server.
                         */
                        this.owner.triggerEvent('response', this.responseText);
                    }
                }.bind(this);
            },
            get: function () {
                var xhr  = new XMLHttpRequest(),
                    path = this.path;
                
                if (this.data) {
                    path += '?' + this.data;
                }
                
                xhr.open(this.method, path, true);
                xhr.withCredentials = this.withCredentials;
                xhr.responseType = this.responseType;
                xhr.onload = this.onload;
                xhr.send();
            },
            post: function () {
                var xhr = new XMLHttpRequest();
                
                xhr.open(this.method, this.path, true);
                xhr.withCredentials = this.withCredentials;
                xhr.responseType = this.responseType;
                xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                xhr.onload = this.onload;
                xhr.send(this.data);
            }
        }
    });
}());

//##############################################################################
// RenderSpine.js
//##############################################################################

(function () {
    'use strict';

    var AABB = include('platypus.AABB'),
        Atlas = include('PIXI.spine.SpineRuntime.Atlas', false),
        AtlasAttachmentParser = include('PIXI.spine.SpineRuntime.AtlasAttachmentParser', false),
        BaseTexture = include('PIXI.BaseTexture'),
        Data = include('platypus.Data'),
        EventRender = include('platypus.components.EventRender'),
        Graphics = include('PIXI.Graphics'),
        Matrix = include('PIXI.Matrix'),
        SkeletonJsonParser = include('PIXI.spine.SpineRuntime.SkeletonJsonParser', false),
        Spine = include('PIXI.spine.Spine', false),
        StateRender = include('platypus.components.StateRender'),
        tempMatrix = new Matrix(),
        processGraphics = (function () {
            var process = function (gfx, value) {
                var i = 0,
                    paren  = value.indexOf('('),
                    func   = value.substring(0, paren),
                    values = value.substring(paren + 1, value.indexOf(')'));

                if (values.length) {
                    values = values.greenSplit(',');
                    i = values.length;
                    while (i--) {
                        values[i] = +values[i];
                    }
                    gfx[func].apply(gfx, values);
                    values.recycle();
                } else {
                    gfx[func]();
                }
            };

            return function (gfx, value) {
                var i = 0,
                    arr = value.greenSplit('.');

                for (i = 0; i < arr.length; i++) {
                    process(gfx, arr[i]);
                }
                
                arr.recycle();
            };
        }());
    
    // If PIXI.spine is unavailable, this component doesn't work.
    if (!Spine) {
        return function () {
            platypus.debug.error('RenderSpine requires `PIXI.spine` to function.');
        };
    }

    return platypus.createComponentClass({

        id: 'RenderSpine',

        properties: {
            /**
             * Optional. An object containg key-value pairs that define a mapping from triggered events or entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the skeleton definition using the animation names as the keys.
             *
             *  "animationMap":{
             *      "standing": "default-animation"  // On receiving a "standing" event, or when this.owner.state.standing === true, the "default" animation will begin playing.
             *      "ground,moving": "walking",  // Comma separated values have a special meaning when evaluating "state-changed" messages. The above example will cause the "walking" animation to play ONLY if the entity's state includes both "moving" and "ground" equal to true.
             *      "ground,striking": "swing!", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.
             *      "default": "default-animation" // Optional. "default" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.
             *  }
             *
             * @property animationMap
             * @type Object
             * @default null
             */
            animationMap: null,

            /**
             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: "mask": "r(10,20,40,40).dc(30,10,12)". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions.
             *
             *  "mask": {
             *      "x": 10,
             *      "y": 10,
             *      "width": 40,
             *      "height": 40
             *  },
             *
             *  -OR-
             *
             *  "mask": "r(10,20,40,40).dc(30,10,12)"
             *
             * @property mask
             * @type Object
             * @default null
             */
            mask: null,

            /**
             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:
             *
             *  "interactive": {
             *      "hover": false,
             *      "hitArea": {
             *          "x": 10,
             *          "y": 10,
             *          "width": 40,
             *          "height": 40
             *      }
             *  }
             *
             * @property interactive
             * @type Boolean|Object
             * @default false
             */
            interactive: false,

            /**
             * Sets the transition time between animations. If a number is defined, the transition time applies to all animation changes. If an object is specified, the key value pairs should match this syntax where the first part of the key lists the animation currently playing and the second part of the key lists the animation being transitioned to:
             *
             *     {
             *         "jump:walk": 0.4,
             *         "walk:jump": 0.2
             *     }
             *
             * @property mixTimes
             * @type Number|Object
             * @default 0
             */
            "mixTimes": 0,

            /**
             * Optional. The offset of the z-index of the spine from the entity's z-index. Will default to 0.
             *
             * @property offsetZ
             * @type Number
             * @default 0
             */
            offsetZ: 0,

            /**
             * Text describing an atlas of graphic assets for the Spine animation or an asset id for the same.
             *
             * @property atlas
             * @type String
             * @default ""
             */
            atlas: "",

            /**
             * A JSON structure defining a Spine skeleton and behaviors for the animation, or an asset id for the same.
             *
             * @property skeleton
             * @type String|Object
             * @default null
             */
            skeleton: null,

            /**
             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.
             *
             * @property visible
             * @type Boolean
             * @default false
             */
            visible: true,

            /**
             * Optional. Specifies whether this component should create an EventRender component to listen to events matching the animationMap to animate. Set this to true if the component should animate for on events. Default is `false`.
             *
             * @property eventBased
             * @type Boolean
             * @default false
             */
            eventBased: false,

            /**
             * Optional. Specifies whether this component should create a StateRender component to handle changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on `this.owner.state`. Default is `true`.
             *
             * @property stateBased
             * @type Boolean
             * @default true
             */
            stateBased: true
        },

        publicProperties: {
            /**
             * Prevents the spine from becoming invisible out of frame and losing mouse input connection.
             *
             * @property dragMode
             * @type Boolean
             * @default false
             */
            dragMode: false,

            /**
             * Optional. The X scaling factor for the image. Defaults to 1.
             *
             * @property scaleX
             * @type Number
             * @default 1
             */
            scaleX: 1,

            /**
             * Optional. The Y scaling factor for the image. Defaults to 1.
             *
             * @property scaleY
             * @type Number
             * @default 1
             */
            scaleY: 1,

            /**
             * Optional. The X swek factor of the sprite. Defaults to 0.
             *
             * @property skewX
             * @type Number
             * @default 0
             */
            skewX: 0,

            /**
             * Optional. The Y skew factor for the image. Defaults to 0.
             *
             * @property skewY
             * @type Number
             * @default 0
             */
            skewY: 0,

            /**
             * Optional. The rotation of the sprite in degrees. All sprites on the same entity are rotated the same amount except when pinned or if they ignore the rotation value by setting 'rotate' to false.
             *
             * @property rotation
             * @type Number
             * @default 1
             */
            rotation: 0,

            /**
             * Optional. The x position of the entity. Defaults to 0.
             *
             * @property x
             * @type Number
             * @default 0
             */
            x: 0,
            
            /**
             * Optional. The y position of the entity. Defaults to 0.
             *
             * @property y
             * @type Number
             * @default 0
             */
            y: 0,
            
            /**
             * Optional. The z position of the entity. Defaults to 0.
             *
             * @property z
             * @type Number
             * @default 0
             */
            z: 0
        },

        constructor: (function () {
            var
                createAnimationMap = function (animationMap, animations) {
                    var map  = null,
                        anim = '';

                    if (animationMap) {
                        return animationMap;
                    } else {
                        // Create 1-to-1 animation map since none was defined
                        map = {};
                        for (anim in animations) {
                            if (animations.hasOwnProperty(anim)) {
                                map[anim] = anim;
                            }
                        }
                        return map;
                    }
                },
                imageCallback = function (line, callback) {
                    // Not sure if this handles memory well - keeping it in for now.
                    callback(BaseTexture.fromImage(line));
                },
                animationEnded = function () {
                    /**
                     * This event fires each time an animation completes.
                     *
                     * @event 'animation-ended'
                     * @param animation {String} The id of the animation that ended.
                     */
                    this.owner.triggerEvent('animation-ended', this.currentAnimation);
                };
            
            return function () {
                var animation = '',
                    definition = null,
                    settings = platypus.game.settings,
                    atlas = settings.atlases[this.atlas],
                    map = null,
                    skeleton = settings.skeletons[this.skeleton],
                    spineAtlas = new Atlas(atlas, imageCallback),
                    spineJsonParser = new SkeletonJsonParser(new AtlasAttachmentParser(spineAtlas)),
                    skeletonData = spineJsonParser.readSkeletonData(skeleton),
                    spine = this.spine = new Spine(skeletonData);

                spine.transformMatrix = new Matrix();
                spine.state.onComplete = animationEnded.bind(this);

                map = createAnimationMap(this.animationMap, skeleton.animations);
                this.stateBased = map && this.stateBased;
                this.eventBased = map && this.eventBased;
                if (map) {
                    animation = map.default || '';

                    if (this.eventBased) {
                        definition = Data.setUp(
                            'animationMap', map
                        );
                        this.owner.addComponent(new EventRender(this.owner, definition));
                        definition.recycle();
                    }

                    if (this.stateBased) {
                        definition = Data.setUp(
                            'animationMap', map,
                            'forcePlayThrough', this.forcePlayThrough
                        );
                        this.owner.addComponent(new StateRender(this.owner, definition));
                        definition.recycle();
                    }
                }

                this.parentContainer = null;
                this.wasVisible = this.visible;
                this.lastX = this.owner.x;
                this.lastY = this.owner.y;
                this.camera = AABB.setUp();
                this.affine = new Matrix();
                this.isOnCamera = true;

                if (this.interactive) {
                    definition = Data.setUp(
                        'container', this.spine,
                        'hitArea', this.interactive.hitArea,
                        'hover', this.interactive.hover
                    );
                    this.owner.addComponent(new platypus.components.Interactive(this.owner, definition));
                    definition.recycle();
                }

                // set up the mixes!
                if (this.mixTimes) {
                    this.setMixTimes(this.mixTimes);
                }

                // play animation
                if (animation) {
                    this.currentAnimation = animation;
                    spine.state.setAnimationByName(0, animation, true);
                }
            };
        }()),

        events: {
            /**
             * Listens for this event to determine whether this spine is visible.
             *
             * @method 'camera-update'
             * @param camera.viewport {platypus.AABB} Camera position and size.
             */
            "camera-update": function (camera) {
                this.camera.set(camera.viewport);
                
                // Set visiblity of sprite if within camera bounds
                if (this.spine) { //TODO: At some point, may want to do this according to window viewport instead of world viewport so that native PIXI bounds checks across the whole stage can be used. - DDD 9-21-15
                    this.checkCameraBounds();
                }
            },

            /**
             * A setup message used to add the spine to the stage. On receiving this message, the component sets its parent container to the stage contained in the message if it doesn't already have one.
             *
             * @method 'handle-render-load'
             * @param handlerData {Object} Data from the render handler
             * @param handlerData.container {PIXI.Container} The parent container.
             */
            "handle-render-load": function (handlerData) {
                if (!this.parentContainer && handlerData && handlerData.container) {
                    this.addStage(handlerData.container);
                    this.updateSprite(true); // Initial set up in case position, etc is needed prior to the first "render" event.
                }
            },

            "handle-render": function (renderData) {
                if (!this.spine) {
                    return;
                }

                if (!this.parentContainer && !this.addStage(renderData.container)) {
                    platypus.debug.warn('No PIXI Stage, removing render component from "' + this.owner.type + '".');
                    this.owner.removeComponent(this);
                    return;
                }

                this.updateSprite(true);
            },

            "set-mix-times": function (mixTimes) {
                this.setMixTimes(mixTimes);
            },
            
            /**
             * This event makes the spine invisible.
             *
             * @method 'hide'
             */
            "hide": function () {
                this.visible = false;
            },

            /**
             * This event makes the spine visible.
             *
             * @method 'show'
             */
            "show": function () {
                this.visible = true;
            },

            /**
             * Defines the mask on the container/sprite. If no mask is specified, the mask is set to null.
             *
             * @method 'set-mask'
             * @param mask {Object} The mask. This can specified the same way as the 'mask' parameter on the component.
             */
            "set-mask": function (mask) {
                this.setMask(mask);
            },
            
            /**
             * Stops the sprite's animation.
             *
             * @method 'stop-animation'
             * @param [animation] {String} The animation to show and pause. If not specified, this method simply pauses the current animation.
             * @since 0.9.0
             */
            "stop-animation": function (animation) {
                var spine = this.spine;

                if (animation && spine.state.hasAnimationByName(animation)) {
                    this.currentAnimation = animation;
                    spine.state.setAnimationByName(0, animation, false);
                }

                this.paused = true;
            },
            
            /**
             * Starts the sprite's animation.
             *
             * @method 'play-animation'
             * @param [animation] {String} The animation to play. If not specified, this method simply unpauses the current animation.
             * @since 0.9.0
             */
            "play-animation": function (animation) {
                var spine = this.spine;

                if (animation && spine.state.hasAnimationByName(animation)) {
                    this.currentAnimation = animation;
                    spine.state.setAnimationByName(0, animation, true);
                }

                this.paused = false;
            },

            "load": function () {

            }
        },

        methods: {
            addStage: function (stage) {
                if (stage) {
                    this.parentContainer = stage;
                    this.parentContainer.addChild(this.spine);

                    //Handle mask
                    if (this.mask) {
                        this.setMask(this.mask);
                    }

                    /**
                     * This event is triggered once the RenderSpine is ready to handle interactivity.
                     *
                     * @event 'input-on'
                     */
                    this.owner.triggerEvent('input-on');
                    return stage;
                } else {
                    return null;
                }
            },
            
            checkCameraBounds: function () { //TODO: Camera check is busted for spine
/*                var bounds = null,
                    spine = this.spine,
                    matrix = null;
                
                matrix = spine.transformMatrix.copy(tempMatrix);

                spine._currentBounds = null;
                bounds = spine.getBounds(matrix);
                
                if (bounds && ((bounds.x + bounds.width < this.camera.left) || (bounds.x > this.camera.right) || (bounds.y + bounds.height < this.camera.top) || (bounds.y > this.camera.bottom))) {
                    this.isOnCamera = false;
                } else {*/
                    this.isOnCamera = true;
                //}
            },

            setMixTimes: function (mixTimes) {
                var spine = this.spine,
                    animations = spine.spineData.animations,
                    colon = 0,
                    i = 0,
                    j = 0,
                    key = '',
                    stateData = spine.stateData;

                if (typeof mixTimes === 'number') {
                    i = animations.length;
                    while (i--) {
                        j = animations.length;
                        while (j--) {
                            if (i !== j) {
                                stateData.setMixByName(animations[i].name, animations[j].name, mixTimes);
                            }
                        }
                    }
                } else {
                    for (key in mixTimes) {
                        if (mixTimes.hasOwnProperty(key)) {
                            colon = key.indexOf(':');
                            if (colon >= 0) {
                                stateData.setMixByName(key.substring(0, colon), key.substring(colon + 1), mixTimes[key]);
                            }
                        }
                    }
                }

                this.mixTimes = stateData.animationToMixTime;
            },

            setMask: function (shape) {
                var gfx = null;
                
                if (this.mask && this.parentContainer) {
                    this.parentContainer.removeChild(this.mask);
                }
                
                if (!shape) {
                    this.mask = this.container.mask = null;
                    return;
                }
                
                if (shape instanceof Graphics) {
                    gfx = shape;
                } else {
                    gfx = new Graphics();
                    gfx.beginFill(0x000000, 1);
                    if (typeof shape === 'string') {
                        processGraphics(gfx, shape);
                    } else if (shape.radius) {
                        gfx.dc(shape.x || 0, shape.y || 0, shape.radius);
                    } else if (shape.width && shape.height) {
                        gfx.r(shape.x || 0, shape.y || 0, shape.width, shape.height);
                    }
                    gfx.endFill();
                }
                
                gfx.isMask = true;

                this.mask = this.container.mask = gfx;

                if (this.parentContainer) {
                    this.parentContainer.addChild(this.mask);
                }
            },

            updateSprite: function (playing) {
                var spine = this.spine,
                    m = this.affine.copy(spine.transformMatrix),
                    o = null,
                    temp = Matrix.TEMP_MATRIX;

                /**
                 * This event is triggered each tick to check for animation updates.
                 *
                 * @event 'update-animation'
                 * @param playing {Boolean} Whether the animation is in a playing or paused state.
                 */
                this.owner.triggerEvent('update-animation', playing);

                if (spine.z !== (this.owner.z + this.offsetZ)) {
                    if (this.parentContainer) {
                        this.parentContainer.reorder = true;
                    }
                    spine.z = (this.owner.z + this.offsetZ);
                }

                if (typeof this.owner.opacity === 'number') {
                    spine.alpha = this.owner.opacity;
                }

                if (this.owner.orientationMatrix) { // This is a 3x3 2D matrix describing an affine transformation.
                    o = this.owner.orientationMatrix;
                    temp.tx = o[0][2];
                    temp.ty = o[1][2];
                    temp.a = o[0][0];
                    temp.b = o[1][0];
                    temp.c = o[0][1];
                    temp.d = o[1][1];
                    m.prepend(temp);
                }
                
                temp.tx = this.owner.x;
                temp.ty = this.owner.y;
                temp.a = this.scaleX || 1;// * mirrored;
                temp.b = this.owner.skewX || 0;
                temp.c = this.owner.skewY || 0;
                temp.d = this.scaleY || 1;// * flipped;
                m.prepend(temp);

                // Set isCameraOn of sprite if within camera bounds
                if (((!this.wasVisible && this.visible) || this.lastX !== this.owner.x || this.lastY !== this.owner.y)) {
                    //TODO: This check is running twice when an object is moving and the camera is moving.
                    //Find a way to remove the duplication!
                    this.checkCameraBounds();
                }
                this.lastX = this.owner.x;
                this.lastY = this.owner.y;
                this.wasVisible = this.visible;
                this.spine.visible = (this.visible && this.isOnCamera) || this.dragMode;
            },

            destroy: function () {
                this.camera.recycle();
                if (this.parentContainer && !this.spine.mouseTarget) {
                    this.parentContainer.removeChild(this.spine);
                    this.parentContainer = null;
                    this.spine.destroy();
                }
                this.spine = null;
                this.mixTimes = null;
            }
        },

        publicMethods: {

        },
        
        getAssetList: (function () {
            var
                getImages = function (atlas, atlases) {
                    var end = 0;

                    if (atlas) {
                        end = atlas.indexOf('\n');
                        if (end < 0) {
                            return getImages(atlases[atlas], atlases);
                        } else {
                            return Array.setUp(atlas.substring(0, end).replace('\r', ''));
                        }
                    }

                    return Array.setUp();
                };
            
            return function (component, props, defaultProps) {
                var arr = null,
                    i = 0,
                    images = null,
                    atlases = platypus.game.settings.atlases,
                    atlas = component.atlas || props.atlas || defaultProps.atlas;
                
                if (Array.isArray(atlas)) {
                    i = atlas.length;
                    images = Array.setUp();
                    while (i--) {
                        arr = getImages(atlas[i], atlases);
                        images.union(arr);
                        arr.recycle();
                    }
                    return images;
                } else {
                    return getImages(atlas, atlases);
                }
            };
        }())
    });
})();

//##############################################################################
// RenderSprite.js
//##############################################################################

/**
 * This component is attached to entities that will appear in the game world. It renders a static or animated image. It listens for messages triggered on the entity or changes in the logical state of the entity to play a corresponding animation.
 *
 * @namespace platypus.components
 * @class RenderSprite
 * @uses platypus.Component
 */
/* global include, platypus */
(function () {
    'use strict';
    
    var AABB = include('platypus.AABB'),
        Container = include('PIXI.Container'),
        Data = include('platypus.Data'),
        EventRender = include('platypus.components.EventRender'),
        Graphics = include('PIXI.Graphics'),
        Interactive = include('platypus.components.Interactive'),
        Matrix = include('PIXI.Matrix'),
        PIXIAnimation = include('platypus.PIXIAnimation'),
        StateRender = include('platypus.components.StateRender'),
        tempMatrix = new Matrix(),
        processGraphics = (function () {
            var process = function (gfx, value) {
                var i = 0,
                    paren  = value.indexOf('('),
                    func   = value.substring(0, paren),
                    values = value.substring(paren + 1, value.indexOf(')'));

                if (values.length) {
                    values = values.greenSplit(',');
                    i = values.length;
                    while (i--) {
                        values[i] = +values[i];
                    }
                    gfx[func].apply(gfx, values);
                    values.recycle();
                } else {
                    gfx[func]();
                }
            };

            return function (gfx, value) {
                var i = 0,
                    arr = value.greenSplit('.');

                for (i = 0; i < arr.length; i++) {
                    process(gfx, arr[i]);
                }
                
                arr.recycle();
            };
        }());
    
    return platypus.createComponentClass({
        
        id: 'RenderSprite',
        
        properties: {
           /**
             * spriteSheet can either be a String or an object. If a string, the spritesheet data will be loaded from the file with a matching name in the spritesheet folder. Otherwise the definition is in full here. That spritesheet data defines an EaselJS sprite sheet to use for rendering. See http://www.createjs.com/Docs/EaselJS/SpriteSheet.html for the full specification.
             *
             *  "spriteSheet": 'hero-image'
             *
             *  -OR-
             *
             *  "spriteSheet": {
             *
             *      "images": ["example0", "example1"], //Can also define 'image' and give the
             *      "frames": {
             *          "width":  100,
             *          "height": 100,
             *          "regY":   100,
             *          "regX":   50
             *      },
             *      "animations":{
             *          "default-animation":[2],
             *          "walking": {"frames": [0, 1, 2], "speed": 4},
             *          "swing": {"frames": [3, 4, 5], "speed": 4}
             *      }
             *  }
             *
             *  -OR- an Array of the above (since 0.8.4)
             *
             * @property spriteSheet
             * @type String|Array|Object
             * @default null
             */
            spriteSheet: null,

            /**
             * Optional. An object containg key-value pairs that define a mapping from triggered events or entity states to the animation that should play. The list is processed from top to bottom, so the most important actions should be listed first (for example, a jumping animation might take precedence over an idle animation). If not specified, an 1-to-1 animation map is created from the list of animations in the sprite sheet definition using the animation names as the keys.
             *
             *     "animationMap":{
             *         "standing": "default-animation"  // On receiving a "standing" event, or when this.owner.state.standing === true, the "default" animation will begin playing.
             *         "ground,moving": "walking",  // Comma separated values have a special meaning when evaluating "state-changed" messages. The above example will cause the "walking" animation to play ONLY if the entity's state includes both "moving" and "ground" equal to true.
             *         "ground,striking": "swing!", // Putting an exclamation after an animation name causes this animation to complete before going to the next animation. This is useful for animations that would look poorly if interrupted.
             *         "default": "default-animation" // Optional. "default" is a special property that matches all states. If none of the above states are valid for the entity, it will use the default animation listed here.
             *     }
             *
             * This data is used to create EventRender or StateRender components on the entity if the `eventBased` or `stateBased` properties are set to `true`.
             *
             * @property animationMap
             * @type Object
             * @default null
             */
            animationMap: null,

            /**
             * Optional. A mask definition that determines where the image should clip. A string can also be used to create more complex shapes via the PIXI graphics API like: "mask": "r(10,20,40,40).dc(30,10,12)". Defaults to no mask or, if simply set to true, a rectangle using the entity's dimensions.
             *
             *  "mask": {
             *      "x": 10,
             *      "y": 10,
             *      "width": 40,
             *      "height": 40
             *  },
             *
             *  -OR-
             *
             *  "mask": "r(10,20,40,40).dc(30,10,12)"
             *
             * @property mask
             * @type Object
             * @default null
             */
            mask: null,

            /**
             * Defines whether the entity will respond to touch and click events. Setting this value will create an Interactive component on this entity with these properties. For example:
             *
             *  "interactive": {
             *      "hover": false,
             *      "hitArea": {
             *          "x": 10,
             *          "y": 10,
             *          "width": 40,
             *          "height": 40
             *      }
             *  }
             *
             * @property interactive
             * @type Boolean|Object
             * @default false
             * @since 0.9.0
             */
            interactive: false,

            /**
             * This property's functionality is now provided by the `interactive` property.
             *
             * @property acceptInput
             * @type Object
             * @default null
             * @deprecated since 0.9.0
             */
            acceptInput: null,

            /**
             * Optional. Defines locations where other sprites on this entity can pin themselves to this sprite. This is useful for puppet-like dynamics. Each pin location has an id, which is used in the 'pinTo' property of another sprite to define where it connects. A pin location is defined as a set of (x,y,z) coordinates or, for moving pins, as a collection of (x,y,z) coordinates cooresponding to frames in the spritesheet. These coordinates are relative to the top-left corner of the sprite.
             *
             *  "pinLocations": [{
             *      "pinId": "head",
             *      "x": 15,
             *      "y": -30,
             *      "z": 1,
             *
             *      -AND/OR one of the following two-
             *
             *      "frames": {"0": {"x": 12, "y": -32}, "3": {"x": 12}}  //The keys specify the the frame to match the pin to. If a frame doesn't have coordinates or a parameter is undefined, the x/y/z values above are used. If they're not specified, the pinned sprite is invisible.
             *
             *      "frames": [{"x": 12, "y": -32}, null, {"x": 12}]  //In this format, we assume the indexes of the array match those of the frames. If a given index is null or a parameter is undefined, the x/y/z values above are used. If they're not specified, the pinned sprite is invisible.
             *
             *  }],
             *
             * @property pinLocations
             * @type Object
             * @default null
             * @deprecated since 0.9.0, Use RenderSpine for better functionality.
             */
            pinLocations: null,

            /**
             * Optional. Pin id of another sprite on this entity to pin this sprite to.
             *
             * @property pinTo
             * @type String
             * @default null
             * @deprecated since 0.9.0, Use RenderSpine for better functionality.
             */
            pinTo: null,

            /**
             * Optional. The offset of the z-index of the sprite from the entity's z-index. Will default to 0.
             *
             * @property offsetZ
             * @type Number
             * @default 0
             */
            offsetZ: 0,

            /**
             * Optional. Whether this object can be rotated. It's rotational angle is set by setting the this.owner.rotation value on the entity.
             *
             * @property rotate
             * @type Boolean
             * @default false
             */
            rotate: false,

            /**
             * Whether this object can be mirrored over X. To mirror it over X set the this.owner.rotation value to be > 90  and < 270.
             *
             * @property mirror
             * @type Boolean
             * @default false
             */
            mirror: false,

            /**
             * Optional. Whether this object can be flipped over Y. To flip it over Y set the this.owner.rotation to be > 180.
             *
             * @property flip
             * @type Boolean
             * @default false
             */
            flip: false,

            /**
             * Optional. Whether this object is visible or not. To change the visible value dynamically set this.owner.state.visible to true or false.
             *
             * @property visible
             * @type Boolean
             * @default false
             */
            visible: true,

            /**
             * Optional. Specifies whether this component should create an EventRender component to listen to events matching the animationMap to animate. Set this to true if the component should animate for on events. Default is `false`.
             *
             * @property eventBased
             * @type Boolean
             * @default false
             */
            eventBased: false,

            /**
             * Optional. Specifies whether this component should create a StateRender component to handle changes in the entity's state that match the animationMap to animate. Set this to true if the component should animate based on `this.owner.state`. Default is `true`.
             *
             * @property stateBased
             * @type Boolean
             * @default true
             */
            stateBased: true,

            /**
             * Optional. Whether this sprite should be cached into an entity with a `RenderTiles` component (like "render-layer"). The `RenderTiles` component must have its "entityCache" property set to `true`. Warning! This is a one-direction setting and will remove this component from the entity once the current frame has been cached.
             *
             * @property cache
             * @type Boolean
             * @default false
             */
            cache: false,

            /**
             * Optional. When using state-based animations, forces animations to complete before starting a new animation. Defaults to false.
             *
             * @property forcePlayThrough
             * @type Boolean
             * @default false
             */
            forcePlayThrough: false,

            /**
             * Optional. Ignores the opacity of the owner. Used when multiple RenderSprite components are on the same entity.
             *
             * @property ignoreOpacity
             * @type Boolean
             * @default false
             */
            ignoreOpacity: false
        },

        publicProperties: {
            /**
             * Prevents sprite from becoming invisible out of frame and losing mouse input connection.
             *
             * @property dragMode
             * @type Boolean
             * @default false
             * @since 0.8.3
             */
            dragMode: false,

            /**
             * Optional. The X scaling factor for the image. Defaults to 1.
             *
             * @property scaleX
             * @type Number
             * @default 1
             */
            scaleX: 1,

            /**
             * Optional. The Y scaling factor for the image. Defaults to 1.
             *
             * @property scaleY
             * @type Number
             * @default 1
             */
            scaleY: 1,

            /**
             * Optional. The X swek factor of the sprite. Defaults to 0.
             *
             * @property skewX
             * @type Number
             * @default 0
             */
            skewX: 0,

            /**
             * Optional. The Y skew factor for the image. Defaults to 0.
             *
             * @property skewY
             * @type Number
             * @default 0
             */
            skewY: 0,

            /**
             * Optional. The rotation of the sprite in degrees. All sprites on the same entity are rotated the same amount except when pinned or if they ignore the rotation value by setting 'rotate' to false.
             *
             * @property rotation
             * @type Number
             * @default 1
             */
            rotation: 0,

            /**
             * Optional. The x position of the entity. Defaults to 0.
             *
             * @property x
             * @type Number
             * @default 0
             */
            x: 0,
            
            /**
             * Optional. The y position of the entity. Defaults to 0.
             *
             * @property y
             * @type Number
             * @default 0
             */
            y: 0,
            
            /**
             * Optional. The z position of the entity. Defaults to 0.
             *
             * @property z
             * @type Number
             * @default 0
             */
            z: 0
        },
        
        constructor: (function () {
            var
                createAnimationMap = function (animationMap, ss) {
                    var map  = null,
                        anim = '';

                    if (animationMap) {
                        return animationMap;
                    } else if (Array.isArray(ss.frames) && (ss.frames.length === 1)) {
                        // This is a single frame animation, so no mapping is necessary
                        return null;
                    } else {
                        // Create 1-to-1 animation map since none was defined
                        map = {};
                        for (anim in ss.animations) {
                            if (ss.animations.hasOwnProperty(anim)) {
                                map[anim] = anim;
                            }
                        }
                        return map;
                    }
                },
                animationEnded = function (animation) {
                    /**
                     * This event fires each time an animation completes.
                     *
                     * @event 'animation-ended'
                     * @param animation {String} The id of the animation that ended.
                     */
                    this.owner.triggerEvent('animation-ended', animation);
                };
            
            return function () {
                var animation = '',
                    definition = null,
                    ss = PIXIAnimation.formatSpriteSheet(this.spriteSheet),
                    map  = null;

                if (this.acceptInput) {
                    platypus.debug.warn('Entity "' + this.owner.type + '": RenderSprite "acceptInput" property has been deprecated since 0.9.0 in favor of the "interactive" property which adds an "Interactive" component to the entity to handle input.');
                    this.interactive = this.interactive || this.acceptInput;
                }
                
                if (ss === PIXIAnimation.EmptySpriteSheet) {
                    platypus.debug.warn('Entity "' + this.owner.type + '": RenderSprite sprite sheet not defined.');
                }
                
                map = createAnimationMap(this.animationMap, ss);
                this.stateBased = map && this.stateBased;
                this.eventBased = map && this.eventBased;
                if (map) {
                    animation = map.default || '';

                    if (this.eventBased) {
                        definition = Data.setUp(
                            'animationMap', map
                        );
                        this.owner.addComponent(new EventRender(this.owner, definition));
                        definition.recycle();
                    }

                    if (this.stateBased) {
                        definition = Data.setUp(
                            'animationMap', map,
                            'forcePlayThrough', this.forcePlayThrough
                        );
                        this.owner.addComponent(new StateRender(this.owner, definition));
                        definition.recycle();
                    }
                }
                
                this.parentContainer = null;
                this.wasVisible = this.visible;
                this.lastX = this.owner.x;
                this.lastY = this.owner.y;
                this.camera = AABB.setUp();
                this.affine = new Matrix();
                this.isOnCamera = true;

                /*
                 * PIXIAnimation created here:
                 */
                this.sprite = new PIXIAnimation(ss, animation);
                this.sprite.on('complete', animationEnded.bind(this));
                
                // add pins to sprite and setup this.container if needed.
                if (this.pinLocations) {
                    platypus.debug.warn('Entity "' + this.owner.type + '": RenderSprite pinning has been deprecated in favor of the "RenderSpine" component which provides better functionality.');

                    this.container = new Container();
                    this.container.transformMatrix = new Matrix();
                    this.container.addChild(this.sprite);
                    this.sprite.z = 0;

                    this.addPins(this.pinLocations, ss.frames);
                    this.sprite.transformMatrix = new Matrix();
                } else {
                    this.container = this.sprite;
                    this.sprite.transformMatrix = new Matrix();
                }
    
                // pin to another RenderSprite
                if (this.pinTo) {
                    this.owner.triggerEvent('pin-me', this.pinTo);
                }
                
                /* These next few need this.container set up */
                
                //handle hitArea
                if (this.interactive) {
                    definition = Data.setUp(
                        'container', this.container,
                        'hitArea', this.interactive.hitArea,
                        'hover', this.interactive.hover
                    );
                    this.owner.addComponent(new Interactive(this.owner, definition));
                    definition.recycle();
                }
    
                if (this.cache) {
                    this.updateSprite(false);
                    this.owner.cacheRender = this.container;
                }
                
                ss.recycleSpriteSheet();
            };
        }()),
        
        events: {
            /**
             * On receiving a "cache" event, this component triggers "cache-sprite" to cache its rendering into the background. This is an optimization for static images to reduce render calls.
             *
             * @method 'cache'
             */
            "cache": function () {
                this.updateSprite(false);
                this.owner.cacheRender = this.container;
                this.cache = true;
                if (this.owner.parent && this.owner.parent.triggerEventOnChildren) {
                    /**
                     * On receiving a "cache" event, this component triggers "cache-sprite" to cache its rendering into the background. This is an optimization for static images to reduce render calls.
                     *
                     * @event 'cache-sprite'
                     * @param entity {platypus.Entity} This component's owner.
                     */
                    this.owner.parent.triggerEventOnChildren('cache-sprite', this.owner);
                } else {
                    platypus.debug.warn('Unable to cache sprite for ' + this.owner.type);
                }
            },

            /**
             * Listens for this event to determine whether this sprite is visible.
             *
             * @method 'camera-update'
             * @param camera.viewport {platypus.AABB} Camera position and size.
             */
            "camera-update": function (camera) {
                this.camera.set(camera.viewport);
                
                // Set visiblity of sprite if within camera bounds
                if (this.sprite) { //TODO: At some point, may want to do this according to window viewport instead of world viewport so that native PIXI bounds checks across the whole stage can be used. - DDD 9-21-15
                    this.checkCameraBounds();
                }
            },
            
            /**
             * A setup message used to add the sprite to the stage. On receiving this message, the component sets its parent container to the stage contained in the message if it doesn't already have one.
             *
             * @method 'handle-render-load'
             * @param handlerData {Object} Data from the render handler
             * @param handlerData.container {PIXI.Container} The parent container.
             */
            "handle-render-load": function (handlerData) {
                if (!this.parentContainer && handlerData && handlerData.container) {
                    this.addStage(handlerData.container);
                    this.updateSprite(true); // Initial set up in case position, etc is needed prior to the first "render" event.
                }
            },
            
            /**
             * The render update message. This updates the sprite. If a sprite doesn't have a container, it's removed.
             *
             * @method 'handle-render'
             * @param renderData {Object} Data from the render handler
             * @param renderData.container {PIXI.Container} The parent container.
             */
            "handle-render": function (renderData) {
                if (!this.container) { // If this component's removal is pending
                    return;
                }

                if (!this.parentContainer) {
                    if (!this.pinTo) { //In case this component was added after handler-render is initiated
                        if (!this.addStage(renderData.container)) {
                            platypus.debug.warn('No PIXI Stage, removing render component from "' + this.owner.type + '".');
                            this.owner.removeComponent(this);
                            return;
                        }
                    } else {
                        return;
                    }
                }
                
                this.updateSprite(true);
            },
            
            /**
             * This event makes the sprite invisible. When multiple sprites are pinned together, the entire group is invisible.
             *
             * @method 'hide-sprite'
             */
            "hide-sprite": function () {
                this.visible = false;
            },

            /**
             * This event makes the sprite visible. When multiple sprites are pinned together, the entire group is made visible.
             *
             * @method 'show-sprite'
             */
            "show-sprite": function () {
                this.visible = true;
            },
            
            /**
             * If this component has a matching pin location, it will trigger "attach-pin" on the entity with the matching pin location.
             *
             * @method 'pin-me'
             * @param pinId {String} The id of the pin location we're trying to attach to.
             * @deprecated since 0.9.0
             */
            "pin-me": function (pinId) {
                if (this.pins && this.pins[pinId]) {
                    /**
                     * Called by "pin-me", this event is responding to the inquiring component with the information about the pin it should attach to.
                     *
                     * @event 'attach-pin'
                     * @param pinInfo {Object} Information about the pin.
                     */
                    this.owner.triggerEvent("attach-pin", this.pins[pinId]);
                }
            },
            
            /**
             * On receiving this message, the component checks whether it wants to be pinned, and if so, adds itself to the provided container.
             *
             * @method 'attach-pin'
             * @param pinInfo {Object} Information about the pin.
             * @param pinInfo.pinId {String} The pin id.
             * @param pinInfo.container {PIXI.Container} The container to add this sprite to.
             * @deprecated since 0.9.0
             */
            "attach-pin": function (pinInfo) {
                if (pinInfo.pinId === this.pinTo) {
                    this.parentContainer = pinInfo.container;
                    this.parentContainer.addChild(this.container);
                    this.owner.triggerEvent('input-on');
                    this.pinnedTo = pinInfo;
                    this.updateSprite(true); // Initial set up in case position, etc is needed prior to the first "render" event.
                }
            },
            
            /**
             * On receiving this message, the component checks whether it is pinned to the specified pin. If so, it removes itself from the container.
             *
             * @method 'remove-pin'
             * @param pinInfo {Object} Information about the pin.
             * @param pinInfo.pinId {String} The pin id.
             * @param pinInfo.container {PIXI.Container} The container to add this sprite to.
             * @deprecated since 0.9.0
             */
            "remove-pin": function (pinInfo) {
                if (pinInfo.pinId === this.pinTo) {
                    this.parentContainer.removeChild(this.container);
                    this.parentContainer = null;
                    this.pinnedTo = null;
                }
            },
            
            /**
             * Defines the mask on the container/sprite. If no mask is specified, the mask is set to null.
             *
             * @method 'set-mask'
             * @param mask {Object} The mask. This can specified the same way as the 'mask' parameter on the component.
             */
            "set-mask": function (mask) {
                this.setMask(mask);
            },
            
            /**
             * Stops the sprite's animation.
             *
             * @method 'stop-animation'
             * @param [animation] {String} The animation to show and pause. If not specified, this method simply pauses the current animation.
             * @since 0.9.0
             */
            "stop-animation": function (animation) {
                var sprite = this.sprite;

                if (animation && sprite.has(animation)) {
                    sprite.gotoAndStop(animation);
                } else {
                    sprite.stop();
                }
            },
            
            /**
             * Starts the sprite's animation.
             *
             * @method 'play-animation'
             * @param [animation] {String} The animation to play. If not specified, this method simply unpauses the current animation.
             * @since 0.9.0
             */
            "play-animation": function (animation) {
                var sprite = this.sprite;

                if (animation && sprite.has(animation)) {
                    sprite.gotoAndPlay(animation);
                } else {
                    sprite.play();
                }
            },
            
            /**
             * Stops the sprite's animation.
             *
             * @method 'stop-sprite'
             * @deprecated since 0.9.0
             */
            "stop-sprite": function () {
                this.sprite.stop();
            },
            
            /**
             * Starts the sprite's animation.
             *
             * @method 'play-sprite'
             * @deprecated since 0.9.0
             */
            "play-sprite": function () {
                this.sprite.play();
            }
        },
        
        methods: {
            checkCameraBounds: function () {
                var bounds = null,
                    sprite   = this.sprite,
                    matrix   = null,
                    pinning  = null;
                
                matrix = sprite.transformMatrix.copy(tempMatrix);
                pinning = this.pinnedTo;
                while (pinning) {
                    matrix.prepend(pinning.container.transformMatrix);
                    pinning = pinning.pinnedTo;
                }

                sprite._currentBounds = null;
                bounds = sprite.getBounds(matrix);
                
                if (bounds && ((bounds.x + bounds.width < this.camera.left) || (bounds.x > this.camera.right) || (bounds.y + bounds.height < this.camera.top) || (bounds.y > this.camera.bottom))) {
                    this.isOnCamera = false;
                } else {
                    this.isOnCamera = true;
                }
            },
            
            addStage: function (stage) {
                if (stage && !this.pinTo) {
                    this.parentContainer = stage;
                    this.parentContainer.addChild(this.container);

                    //Handle mask
                    if (this.mask) {
                        this.setMask(this.mask);
                    }

                    /**
                     * This event is triggered once the RenderSprite is ready to handle interactivity.
                     *
                     * @event 'input-on'
                     */
                    this.owner.triggerEvent('input-on');
                    return stage;
                } else {
                    return null;
                }
            },
            
            updateSprite: (function () {
                var sort = function (a, b) {
                    return a.z - b.z;
                };
                
                return function (playing) {
                    var x = 0,
                        y = 0,
                        o = null,
                        rotation = 0,
                        mirrored = 1,
                        flipped  = 1,
                        angle    = null,
                        m        = this.affine.copy(this.container.transformMatrix),
                        temp     = Matrix.TEMP_MATRIX;
                    
                    if (this.pinnedTo) {
                        if (this.pinnedTo.frames && this.pinnedTo.frames[this.pinnedTo.sprite.currentFrame]) {
                            x = this.pinnedTo.frames[this.pinnedTo.sprite.currentFrame].x;
                            y = this.pinnedTo.frames[this.pinnedTo.sprite.currentFrame].y;
                            if (this.container.z !== this.pinnedTo.frames[this.pinnedTo.sprite.currentFrame].z) {
                                if (this.parentContainer) {
                                    this.parentContainer.reorder = true;
                                }
                                this.container.z = this.pinnedTo.frames[this.pinnedTo.sprite.currentFrame].z;
                            }
                            rotation = this.pinnedTo.frames[this.pinnedTo.sprite.currentFrame].angle || 0;
                            this.visible = true;
                        } else if (this.pinnedTo.defaultPin) {
                            x = this.pinnedTo.defaultPin.x;
                            y = this.pinnedTo.defaultPin.y;
                            if (this.container.z !== this.pinnedTo.defaultPin.z) {
                                if (this.parentContainer) {
                                    this.parentContainer.reorder = true;
                                }
                                this.container.z = this.pinnedTo.defaultPin.z;
                            }
                            rotation = this.pinnedTo.defaultPin.angle || 0;
                            this.visible = true;
                        } else {
                            this.visible = false;
                        }
                    } else {
                        x = this.owner.x;
                        y = this.owner.y;
                        if (this.rotate) {
                            rotation = this.rotation;
                        }
                        if (this.container.z !== (this.owner.z + this.offsetZ)) {
                            if (this.parentContainer) {
                                this.parentContainer.reorder = true;
                            }
                            this.container.z = (this.owner.z + this.offsetZ);
                        }
    
                        if (!this.ignoreOpacity && (this.owner.opacity || (this.owner.opacity === 0))) {
                            this.container.alpha = this.owner.opacity;
                        }
                    }
                    
                    if (this.container.reorder) {
                        this.container.reorder = false;
                        this.container.children.sort(sort);
                    }
                    
                    if (this.mirror || this.flip) {
                        angle = this.rotation % 360;
                        
                        if (this.mirror && (angle > 90) && (angle < 270)) {
                            mirrored = -1;
                        }
                        
                        if (this.flip && (angle < 180)) {
                            flipped = -1;
                        }
                    }
                    
                    /**
                     * This event is triggered each tick to check for animation updates.
                     *
                     * @event 'update-animation'
                     * @param playing {Boolean} Whether the animation is in a playing or paused state.
                     */
                    this.owner.triggerEvent('update-animation', playing);

                    // Handle rotation
                    if (rotation) {
                        m.rotate((rotation / 180) * Math.PI);
                    }

                    if (this.pinnedTo) {
                        temp.tx = x;
                        temp.ty = y;
                        temp.a = mirrored;
                        temp.b = 0;
                        temp.c = 0;
                        temp.d = flipped;
                        m.prepend(temp);
                    } else {
                        if (this.owner.orientationMatrix) { // This is a 3x3 2D matrix describing an affine transformation.
                            o = this.owner.orientationMatrix;
                            temp.tx = o[0][2];
                            temp.ty = o[1][2];
                            temp.a = o[0][0];
                            temp.b = o[1][0];
                            temp.c = o[0][1];
                            temp.d = o[1][1];
                            m.prepend(temp);
                        }
                        
                        temp.tx = x;
                        temp.ty = y;
                        temp.a = this.scaleX * mirrored;
                        temp.b = this.owner.skewX;
                        temp.c = this.owner.skewY;
                        temp.d = this.scaleY * flipped;
                        m.prepend(temp);
                    }
                    
                    // Set isCameraOn of sprite if within camera bounds
                    if (this.sprite && ((!this.wasVisible && this.visible) || this.lastX !== this.owner.x || this.lastY !== this.owner.y)) {
                        //TODO: This check is running twice when an object is moving and the camera is moving.
                        //Find a way to remove the duplication!
                        this.checkCameraBounds();
                    }
                    this.lastX = this.owner.x;
                    this.lastY = this.owner.y;
                    this.wasVisible = this.visible;
                    this.container.visible = (this.visible && this.isOnCamera) || this.dragMode;
                };
            }()),
            
            addPins: function (pins, frames) {
                var i = 0,
                    j = 0,
                    pin   = null,
                    regX  = frames.regX || 0,
                    regY  = frames.regY || 0,
                    isArray = Array.isArray(frames),
                    zFix = 0.00000001;
                
                this.pinsToRemove = this.pinsToRemove || Array.setUp();
                
                this.pins = {};
                
                for (i = 0; i < pins.length; i++) {
                    this.pinsToRemove.push(pins[i].pinId);

                    if (isArray) {
                        regX = frames[0][5] || 0;
                        regY = frames[0][6] || 0;
                    }
                    
                    this.pins[pins[i].pinId] = pin = {
                        pinId: pins[i].pinId,
                        sprite: this.sprite,
                        container: this.container
                    };

                    if ((typeof pins[i].x === 'number') && (typeof pins[i].y === 'number')) {
                        pin.defaultPin = {
                            x: (pins[i].x - regX),
                            y: (pins[i].y - regY),
                            z: pins[i].z || zFix, //force z to prevent flickering z-order issues.
                            angle: (pins[i].angle || 0)
                        };
                    }
                    
                    if (pins[i].frames) {
                        pin.frames = Array.setUp();
                        for (j = 0; j < pins[i].frames.length; j++) {
                            if (pins[i].frames[j]) {
                                if (isArray) {
                                    regX = frames[j][5] || 0;
                                    regY = frames[j][6] || 0;
                                }
                                if ((typeof pins[i].frames[j].x === 'number') && (typeof pins[i].frames[j].y === 'number')) {
                                    pin.frames.push({
                                        x: (pins[i].frames[j].x - regX),
                                        y: (pins[i].frames[j].y - regY),
                                        z: pins[i].frames[j].z || (pin.defaultPin ? pin.defaultPin.z : zFix),
                                        angle: pins[i].frames[j].angle || (pin.defaultPin ? pin.defaultPin.angle : 0)
                                    });
                                } else if (pin.defaultPin) {
                                    if (typeof pins[i].frames[j].x === 'number') {
                                        pin.frames.push({
                                            x: (pins[i].frames[j].x - regX),
                                            y: pin.defaultPin.y,
                                            z: pins[i].frames[j].z || pin.defaultPin.z,
                                            angle: pins[i].frames[j].angle || pin.defaultPin.angle
                                        });
                                    } else if (typeof pins[i].frames[j].y === 'number') {
                                        pin.frames.push({
                                            x: pin.defaultPin.x,
                                            y: (pins[i].frames[j].y - regY),
                                            z: pins[i].frames[j].z || pin.defaultPin.z,
                                            angle: pins[i].frames[j].angle || pin.defaultPin.angle
                                        });
                                    } else {
                                        pin.frames.push(null);
                                    }
                                } else {
                                    pin.frames.push(null);
                                }
                            } else {
                                pin.frames.push(null);
                            }
                        }
                    }
                    /**
                     * This event is triggered for each pin created. It is intended for other RenderSprite components looking to pin to this pin.
                     *
                     * @event 'attach-pin'
                     * @param pin {Object} The created pin.
                     */
                    this.owner.triggerEvent('attach-pin', pin);
                }
            },

            removePins: function () {
                var i = 0;
                
                if (this.pins && this.pinsToRemove) {
                    for (i = 0; i < this.pinsToRemove.length; i++) {
                        this.owner.triggerEvent('remove-pin', this.pins[this.pinsToRemove[i]].pinId);
                        if (this.pins[this.pinsToRemove[i]].frames) {
                            this.pins[this.pinsToRemove[i]].frames.recycle();
                        }
                        delete this.pins[this.pinsToRemove[i]];
                    }
                    this.pinsToRemove.recycle();
                }
            },
            
            setMask: function (shape) {
                var gfx = null;
                
                if (this.mask && this.parentContainer) {
                    this.parentContainer.removeChild(this.mask);
                }
                
                if (!shape) {
                    this.mask = this.container.mask = null;
                    return;
                }
                
                if (shape instanceof Graphics) {
                    gfx = shape;
                } else {
                    gfx = new Graphics();
                    gfx.beginFill(0x000000, 1);
                    if (typeof shape === 'string') {
                        processGraphics(gfx, shape);
                    } else if (shape.radius) {
                        gfx.dc(shape.x || 0, shape.y || 0, shape.radius);
                    } else if (shape.width && shape.height) {
                        gfx.r(shape.x || 0, shape.y || 0, shape.width, shape.height);
                    }
                    gfx.endFill();
                }
                
                gfx.isMask = true;

                this.mask = this.container.mask = gfx;

                if (this.parentContainer) {
                    this.parentContainer.addChild(this.mask);
                }
            },
            
            destroy: function () {
                this.camera.recycle();
                if (this.parentContainer && !this.container.mouseTarget) {
                    this.parentContainer.removeChild(this.container);
                    this.parentContainer = null;
                    this.container = null;
                }
                this.removePins();
                if (!this.cache) {
                    this.sprite.destroy();
                }
                this.sprite = null;
            }
        },
        
        getAssetList: (function () {
            var
                getImages = function (ss, spriteSheets) {
                    if (ss) {
                        if (typeof ss === 'string') {
                            return getImages(spriteSheets[ss], spriteSheets);
                        } else if (ss.images) {
                            return ss.images.greenSlice();
                        }
                    }

                    return Array.setUp();
                };
            
            return function (component, props, defaultProps) {
                var arr = null,
                    i = 0,
                    images = null,
                    spriteSheets = platypus.game.settings.spriteSheets,
                    ss = component.spriteSheet || props.spriteSheet || defaultProps.spriteSheet;
                
                if (Array.isArray(ss)) {
                    i = ss.length;
                    images = Array.setUp();
                    while (i--) {
                        arr = getImages(ss[i], spriteSheets);
                        images.union(arr);
                        arr.recycle();
                    }
                    return images;
                } else {
                    return getImages(ss, spriteSheets);
                }
            };
        }())
    });
}());

//##############################################################################
// VoiceOver.js
//##############################################################################

/**
 * This component uses its definition to load AudioVO and RenderSprite components who work in an interconnected way to render animations corresponding to one or more audio tracks.
 *
 * In addition to its own properties, this component also accepts all properties accepted by either [RenderSprite](platypus.components.RenderSprite.html) or [AudioVO](platypus.components.AudioVO.html) and passes them along when it creates those components.
 *
 * @namespace platypus.components
 * @class VoiceOver
 * @uses platypus.Component
 */
/* global platypus */
(function () {
    'use strict';

    var getEventName = function (msg, VO) {
            if (VO === ' ') {
                return msg + 'default';
            } else {
                return msg + VO;
            }
        },
        createAudioDefinition = function (sound, events, message, frameLength) {
            var i          = 0,
                key        = '',
                definition = {},
                time       = 0,
                lastFrame  = '',
                thisFrame  = '',
                voice = sound.voice;

            if (typeof sound.sound === 'string') {
                definition.sound = sound.sound;
                definition.events = Array.setUp();
            } else {
                for (key in sound.sound) {
                    if (sound.sound.hasOwnProperty(key)) {
                        definition[key] = sound.sound[key];
                    }
                }

                if (definition.events) {
                    definition.events = definition.events.greenSlice();
                } else {
                    definition.events = Array.setUp();
                }
            }

            if (voice) {
                voice += ' ';

                for (i = 0; i < voice.length; i++) {
                    thisFrame = voice[i];
                    if (thisFrame !== lastFrame) {
                        lastFrame = thisFrame;
                        definition.events.push({
                            "time": time,
                            "event": getEventName(message, thisFrame)
                        });
                    }
                    time += frameLength;
                }
            }

            return definition;
        },
        createVO = function (sound, events, message, frameLength) {
            var i = 0,
                definitions = Array.setUp();

            if (!events[' ']) {
                events[' '] = events.default;
            }

            if (Array.isArray(sound)) {
                for (i = 0; i < sound.length; i++) {
                    definitions.push(createAudioDefinition(sound[i], events, message, frameLength));
                }
                return definitions;
            } else {
                return createAudioDefinition(sound, events, message, frameLength);
            }
        };

    return platypus.createComponentClass({
        id: 'VoiceOver',
        
        properties: {
            /**
             * Sets the pairing between letters in the voice-over strings and the animation frame to play.
             *
             *       "animationMap": {
             *         "default": "mouth-closed"
             *         // Required. Specifies animation of default position.
             *
             *         "w": "mouth-o",
             *         "a": "mouth-aah",
             *         "t": "mouth-t"
             *         // Optional. Also list single characters that should map to a given voice-over animation frame.
             *       }
             *
             * @property animationMap
             * @type Object
             * @default: {"default": "default"}
             */
            animationMap: {"default": "default"},

            /**
             * Specifies how long a described voice-over frame should last in milliseconds.
             *
             * @property frameLength
             * @type Number
             * @default 100
             */
            frameLength: 100,

            /**
             * Specifies the prefix that messages between the render and Audio components should use. This will cause the audio to trigger events like "i-say-w" and "i-say-a" (characters listed in the animationMap), that the RenderSprite uses to show the proper frame.
             *
             * @property messagePrefix
             * @type String
             * @default "VoiceOver"
             */
            messagePrefix: "VoiceOver",

            /**
             * This maps events to audio clips and voice over strings.
             *
             *      "voiceOverMap": {
             *          "message-triggered": [{
             *              "sound": "audio-id",
             *              // Required. This is the audio clip to play when "message-triggered" is triggered. It may be a string as shown or an object of key/value pairs as described in an [[audio]] component definition.
             *              "voice": "waat"
             *              // Optional. This string defines the voice-over sequence according to the frames defined by animationMap. Each character lasts the length specified by "frameLength" above. If not specified, voice will be the default frame.
             *          }]
             *      }
             *
             * @property voiceOverMap
             * @type Object
             * @default {}
             */
            voiceOverMap: {}
        },

        constructor: function (definition) {
            var i = '',
                audioDefinition     = {
                    audioMap: {},
                    aliases: definition.aliases
                },
                animationDefinition = {
                    acceptInput: definition.acceptInput,
                    aliases: definition.aliases,
                    animationMap: {},
                    eventBased: true, // VO triggers events for changing lip-sync frames.
                    flip: definition.flip,
                    hidden: definition.hidden,
                    mask: definition.mask,
                    mirror: definition.mirror,
                    offsetZ: definition.offsetZ,
                    pins: definition.pins,
                    pinTo: definition.pinTo,
                    rotate: definition.rotate,
                    scaleX: definition.scaleX,
                    scaleY: definition.scaleY,
                    spriteSheet: definition.spriteSheet,
                    stateBased: definition.stateBased || false
                };
            
            this.message = this.messagePrefix + '-';
            
            for (i in this.animationMap) {
                if (this.animationMap.hasOwnProperty(i)) {
                    animationDefinition.animationMap[getEventName(this.message, i)] = this.animationMap[i];
                }
            }
            animationDefinition.animationMap.default = this.animationMap.default;
            this.owner.addComponent(new platypus.components.RenderSprite(this.owner, animationDefinition));

            for (i in this.voiceOverMap) {
                if (this.voiceOverMap.hasOwnProperty(i)) {
                    audioDefinition.audioMap[i] = createVO(this.voiceOverMap[i], this.animationMap, this.message, this.frameLength);
                }
            }
            this.owner.addComponent(new platypus.components.AudioVO(this.owner, audioDefinition));
        },

        events: {
            /**
             * On receiving this message, this component removes itself from the entity. (It creates the [[RenderSprite]] and [[AudioVO]] components in its constructor.)
             *
             * @method 'load'
             */
            "load": function () {
                this.owner.removeComponent(this);
            }
        },
        
        getAssetList: function (component, props, defaultProps) {
            var ss = component.spriteSheet || props.spriteSheet || defaultProps.spriteSheet;
            
            if (typeof ss === 'string') {
                return platypus.game.settings.spriteSheets[ss].images.greenSlice();
            } else {
                return ss.images.greenSlice();
            }
        }
    });
}());